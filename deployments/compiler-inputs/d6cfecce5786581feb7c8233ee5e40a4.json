{
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23",
	"id": "d6cfecce5786581feb7c8233ee5e40a4",
	"input": {
		"language": "Solidity",
		"settings": {
			"viaIR": false,
			"optimizer": {
				"runs": 1000,
				"enabled": true
			},
			"metadata": {
				"useLiteralContent": false,
				"bytecodeHash": "ipfs",
				"appendCBOR": true
			},
			"outputSelection": {
				"lib/forge-std/lib/ds-test/src/test.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Base.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Script.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdAssertions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdChains.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdCheats.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdError.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdInvariant.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdJson.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdMath.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdStorage.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdStyle.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Test.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Vm.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/console.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/console2.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/interfaces/IMulticall3.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/mocks/MockERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/mocks/MockERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/safeconsole.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IBridge.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IDelayedMessageProvider.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IInbox.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IInboxBase.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IOutbox.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IOwnable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/ISequencerInbox.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@arbitrum/nitro-contracts/src/libraries/AddressAliasHelper.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@arbitrum/nitro-contracts/src/libraries/IGasRefunder.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@arbitrum/nitro-contracts/src/precompiles/ArbSys.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/script/helpers/Hook721DeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/JB721TiersHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/JB721TiersHookDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/JB721TiersHookStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/abstract/ERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/abstract/JB721Hook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721Hook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookProjectDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/interfaces/IJB721TokenUriResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/libraries/JB721Constants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/libraries/JB721TiersRulesetMetadataResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/libraries/JBBitmap.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/libraries/JBIpfsDecoder.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721InitTiersConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721Tier.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721TierConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721TiersHookFlags.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721TiersMintReservesConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721TiersRulesetMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JB721TiersSetDiscountPercentConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBBitmapWord.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBDeploy721TiersHookConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBLaunchProjectConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBLaunchRulesetsConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBPayDataHookRulesetConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBPayDataHookRulesetMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBQueueRulesetsConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/721-hook/src/structs/JBStored721Tier.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/address-registry/src/JBAddressRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/address-registry/src/interfaces/IJBAddressRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/buyback-hook/script/helpers/BuybackDeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/buyback-hook/src/interfaces/IJBBuybackHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/buyback-hook/src/interfaces/external/IWETH9.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/script/helpers/CoreDeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBController.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBDeadline.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBDirectory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBFeelessAddresses.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBFundAccessLimits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBMultiTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBPermissions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBPrices.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBProjects.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBRulesets.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBSplits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBTerminalStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBTokens.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/abstract/JBControlled.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBControlled.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFeeTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFeelessAddresses.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBMigratable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBMultiTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPayoutTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermitTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRedeemHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRedeemTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesetDataHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTerminalStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBConstants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBCurrencyIds.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBFees.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBFixedPointNumber.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBMetadataResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBRedemptions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBRulesetMetadataResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBSplitGroupIds.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBSurplus.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBAfterRedeemRecordedContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBBeforePayRecordedContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBBeforeRedeemRecordedContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBFee.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBPayHookSpecification.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRedeemHookSpecification.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetWeightCache.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSingleAllowance.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/test/helpers/JBTest.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/test/helpers/MetadataResolverHelper.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/test/helpers/TestBaseWorkflow.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/test/mock/MockERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/test/mock/MockPriceFeed.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/JBOwnable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/JBOwnableOverrides.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/interfaces/IJBOwnable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/struct/JBOwner.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/script/helpers/SuckerDeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/JBArbitrumSucker.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/JBSucker.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/JBSuckerRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/deployers/JBArbitrumSuckerDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/enums/JBAddToBalanceMode.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/enums/JBLayer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/interfaces/IArbGatewayRouter.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/interfaces/IArbL1GatewayRouter.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/interfaces/IArbL2GatewayRouter.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/interfaces/IJBArbitrumSucker.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/interfaces/IJBArbitrumSuckerDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/interfaces/IJBSucker.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/interfaces/IJBSuckerDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/interfaces/IJBSuckerRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/libraries/ARBAddresses.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/libraries/ARBChains.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/structs/JBClaim.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/structs/JBInboxTreeRoot.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/structs/JBLeaf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/structs/JBMessageRoot.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/structs/JBOutboxTree.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/structs/JBRemoteToken.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/structs/JBSuckerDeployerConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/structs/JBSuckersPair.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/structs/JBTokenMapping.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/suckers/src/utils/MerkleLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/swap-terminal/script/helpers/SwapTerminalDeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/swap-terminal/src/JBSwapTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/swap-terminal/src/interfaces/IJBSwapTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/swap-terminal/src/interfaces/IWETH9.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@croptop/core/script/helpers/CroptopDeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@croptop/core/src/CTDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@croptop/core/src/CTProjectOwner.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@croptop/core/src/CTPublisher.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@croptop/core/src/interfaces/ICTDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@croptop/core/src/interfaces/ICTProjectOwner.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@croptop/core/src/interfaces/ICTPublisher.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@croptop/core/src/structs/CTAllowedPost.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@croptop/core/src/structs/CTPost.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/access/Ownable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/governance/utils/IVotes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/governance/utils/Votes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC2981.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC5267.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC5805.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC6372.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/proxy/Clones.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Address.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Context.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Nonces.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/ShortStrings.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/StorageSlot.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Strings.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/structs/BitMaps.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/structs/Checkpoints.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/types/Time.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/Common.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/UD60x18.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd1x18/Casting.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd1x18/Constants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd1x18/Errors.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd1x18/ValueType.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/Casting.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/Constants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/Errors.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/Helpers.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/Math.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/ValueType.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud2x18/Casting.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud2x18/Constants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud2x18/Errors.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud2x18/ValueType.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Casting.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Constants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Conversions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Errors.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Helpers.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Math.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/ValueType.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/SphinxDataTypes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/interfaces/ISphinxModule.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/interfaces/ISphinxModuleProxyFactory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/StdUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/Vm.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC165.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IMulticall3.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/mocks/MockERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/mocks/MockERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/Sphinx.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxConstants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxForkCheck.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxPlugin.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxPluginTypes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/ICreateCall.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IEnum.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafe.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafeProxy.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafeProxyFactory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IMultiSend.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/permit2/src/interfaces/IEIP712.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/permit2/src/interfaces/IPermit2.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/permit2/src/interfaces/ISignatureTransfer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/permit2/test/utils/DeployPermit2.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolErrors.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/libraries/FullMath.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-core/contracts/libraries/TickMath.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"script/Deploy.s.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"script/helpers/RevnetCoreDeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/REVDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/REVLoans.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IREVDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IREVLoans.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVAutoMint.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVBuybackHookConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVBuybackPoolConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVCroptopAllowedPost.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVDeploy721TiersHookConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVDescription.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVLoan.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVLoanSource.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVStageConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/REVSuckerDeploymentConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/REV.integrations.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/REVBasicDeployer.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/REVLoans.invariants.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/REVLoansSourced.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/REVLoansUnSourced.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				}
			},
			"evmVersion": "paris",
			"libraries": {},
			"remappings": [
				"@sphinx-labs/contracts/=node_modules/@sphinx-labs/contracts/contracts/foundry/",
				"@arbitrum/=node_modules/@arbitrum/",
				"@bananapus/=node_modules/@bananapus/",
				"@chainlink/=node_modules/@chainlink/",
				"@croptop/=node_modules/@croptop/",
				"@eth-optimism/=node_modules/@eth-optimism/",
				"@exhausted-pigeon/=node_modules/@exhausted-pigeon/",
				"@offchainlabs/=node_modules/@offchainlabs/",
				"@openzeppelin/=node_modules/@openzeppelin/",
				"@prb/=node_modules/@prb/",
				"@rev-net/=node_modules/@rev-net/",
				"@scroll-tech/=node_modules/@scroll-tech/",
				"@uniswap/=node_modules/@uniswap/",
				"base64-sol/=node_modules/base64-sol/",
				"ds-test/=lib/forge-std/lib/ds-test/src/",
				"forge-std/=lib/forge-std/src/",
				"hardhat/=node_modules/hardhat/",
				"solady/=node_modules/solady/",
				"solmate/=node_modules/solmate/",
				"sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"
			]
		},
		"sources": {
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721Hook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\n\ninterface IJB721Hook {\n    function DIRECTORY() external view returns (IJBDirectory);\n    function METADATA_ID_TARGET() external view returns (address);\n    function PROJECT_ID() external view returns (uint256);\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {IJBRulesets} from \"@bananapus/core/src/interfaces/IJBRulesets.sol\";\n\nimport {IJB721Hook} from \"./IJB721Hook.sol\";\nimport {IJB721TiersHookStore} from \"./IJB721TiersHookStore.sol\";\nimport {IJB721TokenUriResolver} from \"./IJB721TokenUriResolver.sol\";\nimport {JB721InitTiersConfig} from \"../structs/JB721InitTiersConfig.sol\";\nimport {JB721TierConfig} from \"../structs/JB721TierConfig.sol\";\nimport {JB721TiersHookFlags} from \"../structs/JB721TiersHookFlags.sol\";\nimport {JB721TiersMintReservesConfig} from \"../structs/JB721TiersMintReservesConfig.sol\";\nimport {JB721TiersSetDiscountPercentConfig} from \"../structs/JB721TiersSetDiscountPercentConfig.sol\";\n\ninterface IJB721TiersHook is IJB721Hook {\n    event AddPayCredits(\n        uint256 indexed amount, uint256 indexed newTotalCredits, address indexed account, address caller\n    );\n    event AddTier(uint256 indexed tierId, JB721TierConfig tier, address caller);\n    event Mint(\n        uint256 indexed tokenId,\n        uint256 indexed tierId,\n        address indexed beneficiary,\n        uint256 totalAmountPaid,\n        address caller\n    );\n    event MintReservedNft(uint256 indexed tokenId, uint256 indexed tierId, address indexed beneficiary, address caller);\n    event RemoveTier(uint256 indexed tierId, address caller);\n    event SetBaseUri(string indexed baseUri, address caller);\n    event SetContractUri(string indexed uri, address caller);\n    event SetDiscountPercent(uint256 indexed tierId, uint256 discountPercent, address caller);\n    event SetEncodedIPFSUri(uint256 indexed tierId, bytes32 encodedUri, address caller);\n    event SetTokenUriResolver(IJB721TokenUriResolver indexed resolver, address caller);\n    event UsePayCredits(\n        uint256 indexed amount, uint256 indexed newTotalCredits, address indexed account, address caller\n    );\n\n    function RULESETS() external view returns (IJBRulesets);\n    function STORE() external view returns (IJB721TiersHookStore);\n\n    function baseURI() external view returns (string memory);\n    function contractURI() external view returns (string memory);\n    function firstOwnerOf(uint256 tokenId) external view returns (address);\n    function payCreditsOf(address addr) external view returns (uint256);\n    function pricingContext() external view returns (uint256, uint256, IJBPrices);\n\n    function adjustTiers(JB721TierConfig[] calldata tierDataToAdd, uint256[] calldata tierIdsToRemove) external;\n    function initialize(\n        uint256 projectId,\n        string memory name,\n        string memory symbol,\n        string memory baseUri,\n        IJB721TokenUriResolver tokenUriResolver,\n        string memory contractUri,\n        JB721InitTiersConfig memory tiersConfig,\n        JB721TiersHookFlags memory flags\n    )\n        external;\n    function setDiscountPercentOf(uint256 tierId, uint256 discountPercent) external;\n    function setDiscountPercentsOf(JB721TiersSetDiscountPercentConfig[] calldata configs) external;\n    function mintFor(uint16[] calldata tierIds, address beneficiary) external returns (uint256[] memory tokenIds);\n    function mintPendingReservesFor(JB721TiersMintReservesConfig[] calldata reserveMintConfigs) external;\n    function mintPendingReservesFor(uint256 tierId, uint256 count) external;\n    function setMetadata(\n        string calldata baseUri,\n        string calldata contractMetadataUri,\n        IJB721TokenUriResolver tokenUriResolver,\n        uint256 encodedIPFSUriTierId,\n        bytes32 encodedIPFSUri\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TiersHook} from \"./IJB721TiersHook.sol\";\nimport {JBDeploy721TiersHookConfig} from \"../structs/JBDeploy721TiersHookConfig.sol\";\n\ninterface IJB721TiersHookDeployer {\n    event HookDeployed(uint256 indexed projectId, IJB721TiersHook hook, address caller);\n\n    function deployHookFor(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig memory deployTiersHookConfig\n    )\n        external\n        returns (IJB721TiersHook hook);\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookStore.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TokenUriResolver} from \"./IJB721TokenUriResolver.sol\";\nimport {JB721Tier} from \"../structs/JB721Tier.sol\";\nimport {JB721TierConfig} from \"../structs/JB721TierConfig.sol\";\nimport {JB721TiersHookFlags} from \"../structs/JB721TiersHookFlags.sol\";\n\ninterface IJB721TiersHookStore {\n    event CleanTiers(address indexed hook, address caller);\n\n    function balanceOf(address hook, address owner) external view returns (uint256);\n    function defaultReserveBeneficiaryOf(address hook) external view returns (address);\n    function encodedIPFSUriOf(address hook, uint256 tierId) external view returns (bytes32);\n    function encodedTierIPFSUriOf(address hook, uint256 tokenId) external view returns (bytes32);\n    function flagsOf(address hook) external view returns (JB721TiersHookFlags memory);\n    function isTierRemoved(address hook, uint256 tierId) external view returns (bool);\n    function maxTierIdOf(address hook) external view returns (uint256);\n    function numberOfBurnedFor(address hook, uint256 tierId) external view returns (uint256);\n    function numberOfPendingReservesFor(address hook, uint256 tierId) external view returns (uint256);\n    function numberOfReservesMintedFor(address hook, uint256 tierId) external view returns (uint256);\n    function redemptionWeightOf(address hook, uint256[] calldata tokenIds) external view returns (uint256 weight);\n    function reserveBeneficiaryOf(address hook, uint256 tierId) external view returns (address);\n    function tierBalanceOf(address hook, address owner, uint256 tier) external view returns (uint256);\n    function tierIdOfToken(uint256 tokenId) external pure returns (uint256);\n    function tierOf(address hook, uint256 id, bool includeResolvedUri) external view returns (JB721Tier memory tier);\n    function tierOfTokenId(\n        address hook,\n        uint256 tokenId,\n        bool includeResolvedUri\n    )\n        external\n        view\n        returns (JB721Tier memory tier);\n\n    function tiersOf(\n        address hook,\n        uint256[] calldata categories,\n        bool includeResolvedUri,\n        uint256 startingSortIndex,\n        uint256 size\n    )\n        external\n        view\n        returns (JB721Tier[] memory tiers);\n\n    function tierVotingUnitsOf(address hook, address account, uint256 tierId) external view returns (uint256 units);\n    function tokenUriResolverOf(address hook) external view returns (IJB721TokenUriResolver);\n    function totalRedemptionWeight(address hook) external view returns (uint256 weight);\n    function totalSupplyOf(address hook) external view returns (uint256);\n    function votingUnitsOf(address hook, address account) external view returns (uint256 units);\n\n    function cleanTiers(address hook) external;\n    function recordAddTiers(JB721TierConfig[] calldata tierData) external returns (uint256[] memory tierIds);\n    function recordBurn(uint256[] calldata tokenIds) external;\n    function recordFlags(JB721TiersHookFlags calldata flag) external;\n    function recordMint(\n        uint256 amount,\n        uint16[] calldata tierIds,\n        bool isOwnerMint\n    )\n        external\n        returns (uint256[] memory tokenIds, uint256 leftoverAmount);\n    function recordMintReservesFor(uint256 tierId, uint256 count) external returns (uint256[] memory tokenIds);\n    function recordRemoveTierIds(uint256[] calldata tierIds) external;\n    function recordSetEncodedIPFSUriOf(uint256 tierId, bytes32 encodedIPFSUri) external;\n    function recordSetDiscountPercentOf(uint256 tierId, uint256 discountPercent) external;\n    function recordSetTokenUriResolver(IJB721TokenUriResolver resolver) external;\n    function recordTransferForTier(uint256 tierId, address from, address to) external;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJB721TokenUriResolver {\n    function tokenUriOf(address nft, uint256 tokenId) external view returns (string memory tokenUri);\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721InitTiersConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\n\nimport {JB721TierConfig} from \"./JB721TierConfig.sol\";\n\n/// @notice Config to initialize a `JB721TiersHook` with tiers and price data.\n/// @dev The `tiers` must be sorted by price (from least to greatest).\n/// @custom:member tiers The tiers to initialize the hook with.\n/// @custom:member currency The currency that the tier prices are denoted in. See `JBPrices`.\n/// @custom:member decimals The number of decimals in the fixed point tier prices.\n/// @custom:member prices A contract that exposes price feeds that can be used to calculate prices in different\n/// currencies. To only accept payments in `currency`, set `prices` to the zero address. See `JBPrices`.\nstruct JB721InitTiersConfig {\n    JB721TierConfig[] tiers;\n    uint32 currency;\n    uint8 decimals;\n    IJBPrices prices;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721Tier.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member id The tier's ID.\n/// @custom:member price The price to buy an NFT in this tier, in terms of the currency in its `JBInitTiersConfig`.\n/// @custom:member remainingSupply The remaining number of NFTs which can be minted from this tier.\n/// @custom:member initialSupply The total number of NFTs which can be minted from this tier.\n/// @custom:member votingUnits The number of votes that each NFT in this tier gets.\n/// @custom:member reserveFrequency The frequency at which an extra NFT is minted for the `reserveBeneficiary` from this\n/// tier. With a `reserveFrequency` of 5, an extra NFT will be minted for the `reserveBeneficiary` for every 5 NFTs\n/// purchased.\n/// @custom:member reserveBeneficiary The address which receives any reserve NFTs from this tier.\n/// @custom:member encodedIPFSUri The IPFS URI to use for each NFT in this tier.\n/// @custom:member category The category that NFTs in this tier belongs to. Used to group NFT tiers.\n/// @custom:member discountPercent The discount that should be applied to the tier.\n/// @custom:member allowOwnerMint A boolean indicating whether the contract's owner can mint NFTs from this tier\n/// on-demand.\n/// @custom:member cannotBeRemoved A boolean indicating whether attempts to remove this tier will revert.\n/// @custom:member cannotIncreaseDiscountPercent If the tier cannot have its discount increased.\n/// @custom:member transfersPausable A boolean indicating whether transfers for NFTs in tier can be paused.\n/// @custom:member resolvedUri A resolved token URI for NFTs in this tier. Only available if the NFT this tier belongs\n/// to has a resolver.\nstruct JB721Tier {\n    uint32 id;\n    uint104 price;\n    uint32 remainingSupply;\n    uint32 initialSupply;\n    uint104 votingUnits;\n    uint16 reserveFrequency;\n    address reserveBeneficiary;\n    bytes32 encodedIPFSUri;\n    uint24 category;\n    uint8 discountPercent;\n    bool allowOwnerMint;\n    bool transfersPausable;\n    bool cannotBeRemoved;\n    bool cannotIncreaseDiscountPercent;\n    string resolvedUri;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TierConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Config for a single NFT tier within a `JB721TiersHook`.\n/// @custom:member price The price to buy an NFT in this tier, in terms of the currency in its `JBInitTiersConfig`.\n/// @custom:member initialSupply The total number of NFTs which can be minted from this tier.\n/// @custom:member votingUnits The number of votes that each NFT in this tier gets if `useVotingUnits` is true.\n/// @custom:member reserveFrequency The frequency at which an extra NFT is minted for the `reserveBeneficiary` from this\n/// tier. With a `reserveFrequency` of 5, an extra NFT will be minted for the `reserveBeneficiary` for every 5 NFTs\n/// purchased.\n/// @custom:member reserveBeneficiary The address which receives any reserve NFTs from this tier. Overrides the default\n/// reserve beneficiary if one is set.\n/// @custom:member encodedIPFSUri The IPFS URI to use for each NFT in this tier.\n/// @custom:member category The category that NFTs in this tier belongs to. Used to group NFT tiers.\n/// @custom:member discountPercent The discount that should be applied to the tier.\n/// @custom:member allowOwnerMint A boolean indicating whether the contract's owner can mint NFTs from this tier\n/// on-demand.\n/// @custom:member useReserveBeneficiaryAsDefault A boolean indicating whether this tier's `reserveBeneficiary` should\n/// be stored as the default beneficiary for all tiers.\n/// @custom:member transfersPausable A boolean indicating whether transfers for NFTs in tier can be paused.\n/// @custom:member useVotingUnits A boolean indicating whether the `votingUnits` should be used to calculate voting\n/// power. If `useVotingUnits` is false, voting power is based on the tier's price.\n/// @custom:member cannotBeRemoved If the tier cannot be removed once added.\n/// @custom:member cannotIncreaseDiscount If the tier cannot have its discount increased.\nstruct JB721TierConfig {\n    uint104 price;\n    uint32 initialSupply;\n    uint32 votingUnits;\n    uint16 reserveFrequency;\n    address reserveBeneficiary;\n    bytes32 encodedIPFSUri;\n    uint24 category;\n    uint8 discountPercent;\n    bool allowOwnerMint;\n    bool useReserveBeneficiaryAsDefault;\n    bool transfersPausable;\n    bool useVotingUnits;\n    bool cannotBeRemoved;\n    bool cannotIncreaseDiscountPercent;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TiersHookFlags.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member noNewTiersWithReserves A boolean indicating whether attempts to add new tiers with a non-zero\n/// `reserveFrequency` will revert.\n/// @custom:member noNewTiersWithVotes A boolean indicating whether attempts to add new tiers with non-zero\n/// `votingUnits` will revert.\n/// @custom:member noNewTiersWithOwnerMinting A boolean indicating whether attempts to add new tiers with\n/// `allowOwnerMint` set to true will revert.\n/// @custom:member preventOverspending A boolean indicating whether payments attempting to spend more than the price of\n/// the NFTs being minted will revert.\nstruct JB721TiersHookFlags {\n    bool noNewTiersWithReserves;\n    bool noNewTiersWithVotes;\n    bool noNewTiersWithOwnerMinting;\n    bool preventOverspending;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TiersMintReservesConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member tierId The ID of the tier to mint from.\n/// @custom:member count The number of NFTs to mint from that tier.\nstruct JB721TiersMintReservesConfig {\n    uint32 tierId;\n    uint16 count;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TiersSetDiscountPercentConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member tierId The ID of the tier to set the discount percent for.\n/// @custom:member discountPercent The discount percent to set for the tier.\nstruct JB721TiersSetDiscountPercentConfig {\n    uint32 tierId;\n    uint16 discountPercent;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JBDeploy721TiersHookConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JB721InitTiersConfig} from \"./JB721InitTiersConfig.sol\";\nimport {JB721TiersHookFlags} from \"./JB721TiersHookFlags.sol\";\nimport {IJB721TokenUriResolver} from \"../interfaces/IJB721TokenUriResolver.sol\";\n\n/// @custom:member name The NFT collection's name.\n/// @custom:member symbol The NFT collection's symbol.\n/// @custom:member baseUri The URI to use as a base for full NFT URIs.\n/// @custom:member tokenUriResolver The contract responsible for resolving the URI for each NFT.\n/// @custom:member contractUri The URI where this contract's metadata can be found.\n/// @custom:member tiersConfig The NFT tiers and pricing config to launch the hook with.\n/// @custom:member reserveBeneficiary The default reserved beneficiary for all tiers.\n/// @custom:member flags A set of boolean options to configure the hook with.\nstruct JBDeploy721TiersHookConfig {\n    string name;\n    string symbol;\n    string baseUri;\n    IJB721TokenUriResolver tokenUriResolver;\n    string contractUri;\n    JB721InitTiersConfig tiersConfig;\n    address reserveBeneficiary;\n    JB721TiersHookFlags flags;\n}\n"
			},
			"node_modules/@bananapus/buyback-hook/src/interfaces/IJBBuybackHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBPayHook} from \"@bananapus/core/src/interfaces/IJBPayHook.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IJBRulesetDataHook} from \"@bananapus/core/src/interfaces/IJBRulesetDataHook.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IUniswapV3SwapCallback} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport {IWETH9} from \"./external/IWETH9.sol\";\n\ninterface IJBBuybackHook is IJBPayHook, IJBRulesetDataHook, IUniswapV3SwapCallback {\n    event Swap(\n        uint256 indexed projectId, uint256 amountToSwapWith, IUniswapV3Pool pool, uint256 amountReceived, address caller\n    );\n    event Mint(uint256 indexed projectId, uint256 leftoverAmount, uint256 tokenCount, address caller);\n    event PoolAdded(uint256 indexed projectId, address indexed terminalToken, address pool, address caller);\n    event TwapWindowChanged(uint256 indexed projectId, uint256 oldWindow, uint256 newWindow, address caller);\n    event TwapSlippageToleranceChanged(\n        uint256 indexed projectId, uint256 oldTolerance, uint256 newTolerance, address caller\n    );\n\n    function CONTROLLER() external view returns (IJBController);\n    function DIRECTORY() external view returns (IJBDirectory);\n    function MAX_TWAP_SLIPPAGE_TOLERANCE() external view returns (uint256);\n    function MIN_TWAP_SLIPPAGE_TOLERANCE() external view returns (uint256);\n    function MAX_TWAP_WINDOW() external view returns (uint256);\n    function MIN_TWAP_WINDOW() external view returns (uint256);\n    function TWAP_SLIPPAGE_DENOMINATOR() external view returns (uint256);\n    function PROJECTS() external view returns (IJBProjects);\n    function UNISWAP_V3_FACTORY() external view returns (address);\n    function WETH() external view returns (IWETH9);\n\n    function poolOf(uint256 projectId, address terminalToken) external view returns (IUniswapV3Pool pool);\n    function projectTokenOf(uint256 projectId) external view returns (address projectTokenOf);\n    function twapSlippageToleranceOf(uint256 projectId) external view returns (uint256 slippageTolerance);\n    function twapWindowOf(uint256 projectId) external view returns (uint32 window);\n\n    function setPoolFor(\n        uint256 projectId,\n        uint24 fee,\n        uint32 twapWindow,\n        uint256 twapSlippageTolerance,\n        address terminalToken\n    )\n        external\n        returns (IUniswapV3Pool newPool);\n    function setTwapSlippageToleranceOf(uint256 projectId, uint256 newSlippageTolerance) external;\n    function setTwapWindowOf(uint256 projectId, uint32 newWindow) external;\n}\n"
			},
			"node_modules/@bananapus/buyback-hook/src/interfaces/external/IWETH9.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBPermissioned} from \"./../interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./../interfaces/IJBPermissions.sol\";\n\n/// @notice Modifiers to allow access to transactions based on which permissions the message's sender has.\nabstract contract JBPermissioned is Context, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n\n    error JBPermissioned_Unauthorized(address account, address sender, uint256 projectId, uint256 permissionId);\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    constructor(IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Require the message sender to be the account or have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view {\n        address sender = _msgSender();\n        if (\n            sender != account\n                && !PERMISSIONS.hasPermission({\n                    operator: sender,\n                    account: account,\n                    projectId: projectId,\n                    permissionId: permissionId,\n                    includeRoot: true,\n                    includeWildcardProjectId: true\n                })\n        ) revert JBPermissioned_Unauthorized(account, sender, projectId, permissionId);\n    }\n\n    /// @notice If the 'alsoGrantAccessIf' condition is truthy, proceed. Otherwise, require the message sender to be the\n    /// account or\n    /// have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n    {\n        if (alsoGrantAccessIf) return;\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string projectUri, string memo, address caller);\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedPercent,\n        address caller\n    );\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 tokenCount, bytes reason, address caller\n    );\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed groupId,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address owner,\n        uint256 tokenCount,\n        uint256 leftoverAmount,\n        address caller\n    );\n    event SetUri(uint256 indexed projectId, string uri, address caller);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n    function PRICES() external view returns (IJBPrices);\n    function PROJECTS() external view returns (IJBProjects);\n    function RULESETS() external view returns (IJBRulesets);\n    function SPLITS() external view returns (IJBSplits);\n    function TOKENS() external view returns (IJBTokens);\n\n    function allRulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function addPriceFeed(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 tokenCount, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedPercent\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function sendReservedTokensToSplitsOf(uint256 projectId) external returns (uint256);\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 creditCount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed isAllowed, address caller);\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\n\ninterface IJBFundAccessLimits {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        JBFundAccessLimitGroup fundAccessLimitGroup,\n        address caller\n    );\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessLimitGroups\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPayoutTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {JBSplit} from \"../structs/JBSplit.sol\";\n\n/// @notice A terminal that can send payouts.\ninterface IJBPayoutTerminal is IJBTerminal {\n    event PayoutReverted(uint256 indexed projectId, JBSplit split, uint256 amount, bytes reason, address caller);\n    event SendPayouts(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address projectOwner,\n        uint256 amount,\n        uint256 amountPaidOut,\n        uint256 fee,\n        uint256 netLeftoverPayoutAmount,\n        address caller\n    );\n    event SendPayoutToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed group,\n        JBSplit split,\n        uint256 amount,\n        uint256 netAmount,\n        address caller\n    );\n    event UseAllowance(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address beneficiary,\n        address feeBeneficiary,\n        uint256 amount,\n        uint256 amountPaidOut,\n        uint256 netAmountPaidOut,\n        string memo,\n        address caller\n    );\n\n    function sendPayoutsOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut\n    )\n        external\n        returns (uint256 netLeftoverPayoutAmount);\n    function useAllowanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut,\n        address payable beneficiary,\n        address payable feeBeneficiary,\n        string calldata memo\n    )\n        external\n        returns (uint256 netAmountPaidOut);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint8[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function WILDCARD_PROJECT_ID() external view returns (uint256);\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId,\n        uint256 indexed pricingCurrency,\n        uint256 indexed unitCurrency,\n        IJBPriceFeed feed,\n        address caller\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata uri) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n    function setTokenUriResolver(IJBTokenUriResolver resolver) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRedeemHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterRedeemRecordedContext} from \"./../structs/JBAfterRedeemRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `redeemTokensOf(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBRedeemHook is IERC165 {\n    /// @notice This function is called by the terminal's `redeemTokensOf(...)` function after the redemption has been\n    /// recorded in the terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterRedeemRecordedContext` struct.\n    function afterRedeemRecordedWith(JBAfterRedeemRecordedContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 start\n    )\n        external\n        view\n        returns (JBApprovalStatus);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesetDataHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBBeforePayRecordedContext} from \"./../structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeRedeemRecordedContext} from \"./../structs/JBBeforeRedeemRecordedContext.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\nimport {JBRedeemHookSpecification} from \"./../structs/JBRedeemHookSpecification.sol\";\n\n/// @notice Data hooks can extend a terminal's core pay/redeem functionality by overriding the weight or memo. They can\n/// also specify pay/redeem hooks for the terminal to fulfill, or allow addresses to mint a project's tokens on-demand.\n/// @dev If a project's ruleset has `useDataHookForPay` or `useDataHookForRedeem` enabled, its `dataHook` is called by\n/// the terminal upon payments/redemptions (respectively).\ninterface IJBRulesetDataHook is IERC165 {\n    /// @notice A flag indicating whether an address has permission to mint a project's tokens on-demand.\n    /// @dev A project's data hook can allow any address to mint its tokens.\n    /// @param projectId The ID of the project whose token can be minted.\n    /// @param addr The address to check the token minting permission of.\n    /// @return flag A flag indicating whether the address has permission to mint the project's tokens on-demand.\n    function hasMintPermissionFor(uint256 projectId, address addr) external view returns (bool flag);\n\n    /// @notice The data calculated before a payment is recorded in the terminal store. This data is provided to the\n    /// terminal's `pay(...)` transaction.\n    /// @param context The context passed to this data hook by the `pay(...)` function as a `JBBeforePayRecordedContext`\n    /// struct.\n    /// @return weight The new `weight` to use, overriding the ruleset's `weight`.\n    /// @return hookSpecifications The amount and data to send to pay hooks instead of adding to the terminal's balance.\n    function beforePayRecordedWith(JBBeforePayRecordedContext calldata context)\n        external\n        view\n        returns (uint256 weight, JBPayHookSpecification[] memory hookSpecifications);\n\n    /// @notice The data calculated before a redemption is recorded in the terminal store. This data is provided to the\n    /// terminal's `redeemTokensOf(...)` transaction.\n    /// @param context The context passed to this data hook by the `redeemTokensOf(...)` function as a\n    /// `JBBeforeRedeemRecordedContext` struct.\n    /// @return redemptionRate The rate determining the amount that should be reclaimable for a given surplus and token\n    /// supply.\n    /// @return redeemCount The amount of tokens that should be considered redeemed.\n    /// @return totalSupply The total amount of tokens that are considered to be existing.\n    /// @return hookSpecifications The amount and data to send to redeem hooks instead of returning to the beneficiary.\n    function beforeRedeemRecordedWith(JBBeforeRedeemRecordedContext calldata context)\n        external\n        view\n        returns (\n            uint256 redemptionRate,\n            uint256 redeemCount,\n            uint256 totalSupply,\n            JBRedeemHookSpecification[] memory hookSpecifications\n        );\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetInitialized(\n        uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId, address caller\n    );\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n    function allOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\n\ninterface IJBSplits {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed groupId, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 groupId) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBPayHook} from \"./IJBPayHook.sol\";\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 returnedFees, string memo, bytes metadata, address caller\n    );\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n    event SetAccountingContext(uint256 indexed projectId, JBAccountingContext context, address caller);\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n    function currentSurplusOf(uint256 projectId, uint256 decimals, uint256 currency) external view returns (uint256);\n\n    function addAccountingContextsFor(uint256 projectId, JBAccountingContext[] calldata accountingContexts) external;\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function balanceOf(address account) external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n\n    function initialize(string memory name, string memory symbol, address owner) external;\n    function burn(address account, uint256 amount) external;\n    function mint(address account, uint256 amount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\n\ninterface IJBTokens {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 count,\n        uint256 creditBalance,\n        uint256 tokenBalance,\n        address caller\n    );\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 creditBalance,\n        uint256 count,\n        address beneficiary,\n        address caller\n    );\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 count, bool shouldClaimTokens, address caller\n    );\n    event SetToken(uint256 indexed projectId, IJBToken indexed token, address caller);\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 count, address caller\n    );\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n    function projectIdOf(IJBToken token) external view returns (uint256);\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function burnFrom(address holder, uint256 projectId, uint256 count) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 count, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function mintFor(address holder, uint256 projectId, uint256 count) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 count) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBConstants.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint16 public constant MAX_RESERVED_PERCENT = 10_000;\n    uint16 public constant MAX_REDEMPTION_RATE = 10_000;\n    uint32 public constant MAX_DECAY_PERCENT = 1_000_000_000;\n    uint32 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint16 public constant MAX_FEE = 1000;\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBFees.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBConstants} from \"./../libraries/JBConstants.sol\";\n\n/// @notice Fee calculations.\nlibrary JBFees {\n    /// @notice Returns the amount of tokens to pay as a fee out of the specified `amount`.\n    /// @dev The resulting fee will be `feePercent` of the REMAINING `amount` after subtracting the fee, not the full\n    /// `amount`.\n    /// @param amount The amount that the fee is based on, as a fixed point number.\n    /// @param feePercent The fee percent, out of `JBConstants.MAX_FEE`.\n    /// @return The amount of tokens to pay as a fee, as a fixed point number with the same number of decimals as the\n    /// provided `amount`.\n    function feeAmountIn(uint256 amount, uint256 feePercent) internal pure returns (uint256) {\n        // The amount of tokens from the `amount` to pay as a fee. If reverse, the fee taken from a payout of\n        // `amount`.\n        return amount - mulDiv(amount, JBConstants.MAX_FEE, feePercent + JBConstants.MAX_FEE);\n    }\n\n    /// @notice Returns the fee that would have been paid based on an `amount` which has already had the fee subtracted\n    /// from it.\n    /// @dev The resulting fee will be `feePercent` of the full `amount`.\n    /// @param amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as\n    /// this terminal.\n    /// @param feePercent The fee percent, out of `JBConstants.MAX_FEE`.\n    /// @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n    function feeAmountFrom(uint256 amount, uint256 feePercent) internal pure returns (uint256) {\n        // The amount of tokens from the `amount` to pay as a fee. If reverse, the fee taken from a payout of\n        // `amount`.\n        return mulDiv(amount, feePercent, JBConstants.MAX_FEE);\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice Library to parse and create metadata to store {id: data} entries.\n *\n * @dev    Metadata are built as:\n *         - 32B of reserved space for the protocol\n *         - a lookup table `Id: offset`, defining the offset of the data for a given 4 bytes id.\n *           The offset fits 1 bytes, the ID 4 bytes. This table is padded to 32B.\n *         - the data for each id, padded to 32B each\n *\n *            +-----------------------+ offset: 0\n *            | 32B reserved          |\n *            +-----------------------+ offset: 1 = end of first 32B\n *            |      (ID1,offset1)    |\n *            |      (ID2,offset2)    |\n *            |       0's padding     |\n *            +-----------------------+ offset: offset1 = 1 + number of words taken by the padded table\n *            |       id1 data1       |\n *            | 0's padding           |\n *            +-----------------------+ offset: offset2 = offset1 + number of words taken by the data1\n *            |       id2 data2       |\n *            | 0's padding           |\n *            +-----------------------+\n */\nlibrary JBMetadataResolver {\n    error JBMetadataResolver_DataNotPadded();\n    error JBMetadataResolver_LengthMismatch();\n    error JBMetadataResolver_MetadataTooLong();\n    error JBMetadataResolver_MetadataTooShort();\n\n    // The various sizes used in bytes.\n    uint256 constant ID_SIZE = 4;\n    uint256 constant ID_OFFSET_SIZE = 1;\n    uint256 constant WORD_SIZE = 32;\n\n    // The size that an ID takes in the lookup table (Identifier + Offset).\n    uint256 constant TOTAL_ID_SIZE = 5; // ID_SIZE + ID_OFFSET_SIZE;\n\n    // The amount of bytes to go forward to get to the offset of the next ID (aka. the end of the offset of the current\n    // ID).\n    uint256 constant NEXT_ID_OFFSET = 9; // TOTAL_ID_SIZE + ID_SIZE;\n\n    // 1 word (32B) is reserved for the protocol .\n    uint256 constant RESERVED_SIZE = 32; // 1 * WORD_SIZE;\n    uint256 constant MIN_METADATA_LENGTH = 37; // RESERVED_SIZE + ID_SIZE + ID_OFFSET_SIZE;\n\n    /// @notice Add an {id: data} entry to an existing metadata. This is an append-only mechanism.\n    /// @param originalMetadata The original metadata\n    /// @param idToAdd The id to add\n    /// @param dataToAdd The data to add\n    /// @return newMetadata The new metadata with the entry added\n    function addToMetadata(\n        bytes memory originalMetadata,\n        bytes4 idToAdd,\n        bytes memory dataToAdd\n    )\n        internal\n        pure\n        returns (bytes memory newMetadata)\n    {\n        // Empty original metadata and maybe something in the first 32 bytes: create new metadata\n        if (originalMetadata.length <= RESERVED_SIZE) {\n            return abi.encodePacked(bytes32(originalMetadata), bytes32(abi.encodePacked(idToAdd, uint8(2))), dataToAdd);\n        }\n\n        // There is something in the table offset, but not a valid entry - avoid overwriting\n        if (originalMetadata.length < RESERVED_SIZE + ID_SIZE + 1) revert JBMetadataResolver_MetadataTooShort();\n\n        // Make sure the data is padded to 32 bytes.\n        if (dataToAdd.length < 32) revert JBMetadataResolver_DataNotPadded();\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)...\n        uint256 firstOffset = uint8(originalMetadata[RESERVED_SIZE + ID_SIZE]);\n\n        // ...go back to the beginning of the previous word (ie the last word of the table, as it can be padded)\n        uint256 lastWordOfTable = firstOffset - 1;\n\n        // The last offset stored in the table and its index\n        uint256 lastOffset;\n\n        // The number of words taken by the last data stored\n        uint256 numberOfWordslastData;\n\n        // Iterate to find the last entry of the table, lastOffset - we start from the end as the first value\n        // encountered\n        // will be the last offset\n        for (uint256 i = firstOffset * WORD_SIZE - 1; i > lastWordOfTable * WORD_SIZE - 1; i--) {\n            // If the byte is not 0, this is the last offset we're looking for\n            if (originalMetadata[i] != 0) {\n                lastOffset = uint8(originalMetadata[i]);\n                uint256 lastOffsetIndex = i;\n\n                // No rounding as this should be padded to 32B\n                numberOfWordslastData = (originalMetadata.length - lastOffset * WORD_SIZE) / WORD_SIZE;\n\n                // Copy the reserved word and the table and remove the previous padding\n                newMetadata = _sliceBytes(originalMetadata, 0, lastOffsetIndex + 1);\n\n                // Check if the new entry is still fitting in this word\n                if (i + TOTAL_ID_SIZE >= firstOffset * WORD_SIZE) {\n                    // Increment every offset by 1 (as the table now takes one more word)\n                    for (uint256 j = RESERVED_SIZE + ID_SIZE; j < lastOffsetIndex + 1; j += TOTAL_ID_SIZE) {\n                        newMetadata[j] = bytes1(uint8(originalMetadata[j]) + 1);\n                    }\n\n                    // Increment the last offset so the new offset will be properly set too\n                    lastOffset++;\n                }\n\n                break;\n            }\n        }\n\n        // Add the new entry after the last entry of the table, the new offset is the last offset + the number of words\n        // taken by the last data\n        newMetadata = abi.encodePacked(newMetadata, idToAdd, bytes1(uint8(lastOffset + numberOfWordslastData)));\n\n        // Pad as needed - inlined for gas saving\n        uint256 paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Add existing data at the end\n        newMetadata = abi.encodePacked(\n            newMetadata, _sliceBytes(originalMetadata, firstOffset * WORD_SIZE, originalMetadata.length)\n        );\n\n        // Pad as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Append new data at the end\n        newMetadata = abi.encodePacked(newMetadata, dataToAdd);\n\n        // Pad again again as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n    }\n\n    /// @notice Create the metadata for a list of {id:data}\n    /// @dev Intended for offchain use (gas heavy)\n    /// @param ids The list of ids\n    /// @param datas The list of corresponding datas\n    /// @return metadata The resulting metadata\n    function createMetadata(bytes4[] memory ids, bytes[] memory datas) internal pure returns (bytes memory metadata) {\n        if (ids.length != datas.length) revert JBMetadataResolver_LengthMismatch();\n\n        // Add a first empty 32B for the protocol reserved word\n        metadata = abi.encodePacked(bytes32(0));\n\n        // First offset for the data is after the first reserved word...\n        uint256 offset = 1;\n\n        // ... and after the id/offset lookup table, rounding up to 32 bytes words if not a multiple\n        offset += ((ids.length * JBMetadataResolver.TOTAL_ID_SIZE) - 1) / JBMetadataResolver.WORD_SIZE + 1;\n\n        // Keep a reference to the number of ids.\n        uint256 numberOfIds = ids.length;\n\n        // For each id, add it to the lookup table with the next free offset, then increment the offset by the data\n        // length (rounded up)\n        for (uint256 i; i < numberOfIds; ++i) {\n            // Set the data being iterated on.\n            bytes memory data = datas[i];\n\n            if (data.length < 32 || data.length % JBMetadataResolver.WORD_SIZE != 0) {\n                revert JBMetadataResolver_DataNotPadded();\n            }\n\n            metadata = abi.encodePacked(metadata, ids[i], bytes1(uint8(offset)));\n            offset += data.length / JBMetadataResolver.WORD_SIZE;\n\n            // Overflowing a bytes1?\n            if (offset > 255) revert JBMetadataResolver_MetadataTooLong();\n        }\n\n        // Pad the table to a multiple of 32B\n        uint256 paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n            ? metadata.length\n            : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n        assembly {\n            mstore(metadata, paddedLength)\n        }\n\n        // Keep a reference to the number of datas.\n        uint256 numberOfDatas = datas.length;\n\n        // Add each metadata to the array, each padded to 32 bytes\n        for (uint256 i; i < numberOfDatas; i++) {\n            metadata = abi.encodePacked(metadata, datas[i]);\n            paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n                ? metadata.length\n                : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n\n            assembly {\n                mstore(metadata, paddedLength)\n            }\n        }\n    }\n\n    /// @notice Parse the metadata to find the data for a specific ID\n    /// @dev Returns false and an empty bytes if no data is found\n    /// @param id The ID to find.\n    /// @param metadata The metadata to parse.\n    /// @return found Whether the {id:data} was found\n    /// @return targetData The data for the ID (can be empty)\n    function getDataFor(bytes4 id, bytes memory metadata) internal pure returns (bool found, bytes memory targetData) {\n        // Either no data or empty one with only one selector (32+4+1)\n        if (metadata.length <= MIN_METADATA_LENGTH) return (false, \"\");\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)\n        uint256 firstOffset = uint8(metadata[RESERVED_SIZE + ID_SIZE]);\n\n        // Parse the id's to find id, stop when next offset == 0 or current = first offset\n        for (uint256 i = RESERVED_SIZE; metadata[i + ID_SIZE] != bytes1(0) && i < firstOffset * WORD_SIZE;) {\n            // Set the current offset.\n            uint256 currentOffset = uint256(uint8(metadata[i + ID_SIZE]));\n\n            bytes4 parsedId;\n            assembly {\n                parsedId := mload(add(add(metadata, 0x20), i))\n            }\n\n            // _id found?\n            if (parsedId == id) {\n                // Are we at the end of the lookup table (either at the start of data's or next offset is 0/in the\n                // padding)\n                // If not, only return until from this offset to the begining of the next offset\n                uint256 end = (i + NEXT_ID_OFFSET >= firstOffset * WORD_SIZE || metadata[i + NEXT_ID_OFFSET] == 0)\n                    ? metadata.length\n                    : uint256(uint8(metadata[i + NEXT_ID_OFFSET])) * WORD_SIZE;\n\n                return (true, _sliceBytes(metadata, currentOffset * WORD_SIZE, end));\n            }\n            unchecked {\n                i += TOTAL_ID_SIZE;\n            }\n        }\n    }\n\n    /// @notice Returns an unique id following a suggested format (`xor(address(this), purpose name)` where purpose name\n    /// is a string giving context to the id (Permit2, quoteForSwap, etc)\n    /// @param purpose A string describing the purpose associated with the id\n    /// @return id The resulting ID.\n    function getId(string memory purpose) internal view returns (bytes4) {\n        return getId(purpose, address(this));\n    }\n\n    /// @notice Returns an unique id following a suggested format (`xor(address(this), purpose name)` where purpose name\n    /// is a string giving context to the id (Permit2, quoteForSwap, etc)\n    /// @param purpose A string describing the purpose associated with the id\n    /// @param target The target which will use the metadata\n    /// @return id The resulting ID.\n    function getId(string memory purpose, address target) internal pure returns (bytes4) {\n        return bytes4(bytes20(target) ^ bytes20(keccak256(bytes(purpose))));\n    }\n\n    /// @notice Slice bytes from a start index to an end index.\n    /// @param data The bytes array to slice\n    /// @param start The start index to slice at.\n    /// @param end The end index to slice at.\n    /// @param slicedBytes The sliced array.\n    function _sliceBytes(\n        bytes memory data,\n        uint256 start,\n        uint256 end\n    )\n        private\n        pure\n        returns (bytes memory slicedBytes)\n    {\n        assembly {\n            let length := sub(end, start)\n\n            // Allocate memory at the freemem(add 0x20 to include the length)\n            slicedBytes := mload(0x40)\n            mstore(0x40, add(add(slicedBytes, length), 0x20))\n\n            // Store the length (first element)\n            mstore(slicedBytes, length)\n\n            // compute the actual data first offset only once\n            let startBytes := add(add(data, 0x20), start)\n\n            // same for the out array\n            let sliceBytesStartOfData := add(slicedBytes, 0x20)\n\n            // store dem data\n            for { let i := 0 } lt(i, end) { i := add(i, 0x20) } {\n                mstore(add(sliceBytesStartOfData, i), mload(add(startBytes, i)))\n            }\n        }\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBRedemptions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBConstants} from \"./JBConstants.sol\";\n\n/// @notice Redemption calculations.\nlibrary JBRedemptions {\n    /// @notice Returns the amount of surplus terminal tokens which can be reclaimed based on the total surplus, the\n    /// number of tokens being redeemed, the total token supply, and the ruleset's redemption rate.\n    /// @param surplus The total amount of surplus terminal tokens.\n    /// @param tokensRedeemed The number of tokens being redeemed, as a fixed point number with 18 decimals.\n    /// @param totalSupply The total token supply, as a fixed point number with 18 decimals.\n    /// @param redemptionRate The current ruleset's redemption rate.\n    /// @return reclaimableSurplus The amount of surplus tokens that can be reclaimed.\n    function reclaimFrom(\n        uint256 surplus,\n        uint256 tokensRedeemed,\n        uint256 totalSupply,\n        uint256 redemptionRate\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // If the redemption rate is 0, no surplus can be reclaimed.\n        if (redemptionRate == 0) return 0;\n\n        // If the total supply is being redeemed, return the entire surplus.\n        if (tokensRedeemed >= totalSupply) return surplus;\n\n        // Get a reference to the linear proportion.\n        uint256 base = mulDiv(surplus, tokensRedeemed, totalSupply);\n\n        // These conditions are all part of the same curve.\n        // Edge conditions are separated to minimize the operations performed in those cases.\n        if (redemptionRate == JBConstants.MAX_REDEMPTION_RATE) {\n            return base;\n        }\n\n        return mulDiv(\n            base,\n            redemptionRate + mulDiv(JBConstants.MAX_REDEMPTION_RATE - redemptionRate, tokensRedeemed, totalSupply),\n            JBConstants.MAX_REDEMPTION_RATE\n        );\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBRulesetMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\n\nlibrary JBRulesetMetadataResolver {\n    function reservedPercent(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 4);\n    }\n\n    function redemptionRate(JBRuleset memory ruleset) internal pure returns (uint16) {\n        // Redemption rate is a number 0-10000.\n        return uint16(ruleset.metadata >> 20);\n    }\n\n    function baseCurrency(JBRuleset memory ruleset) internal pure returns (uint32) {\n        // Currency is a number 0-4294967296.\n        return uint32(ruleset.metadata >> 36);\n    }\n\n    function pausePay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 68) & 1) == 1;\n    }\n\n    function pauseCreditTransfers(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 69) & 1) == 1;\n    }\n\n    function allowOwnerMinting(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 70) & 1) == 1;\n    }\n\n    function allowSetCustomToken(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 71) & 1) == 1;\n    }\n\n    function allowTerminalMigration(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 72) & 1) == 1;\n    }\n\n    function allowSetTerminals(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 73) & 1) == 1;\n    }\n\n    function allowSetController(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 74) & 1) == 1;\n    }\n\n    function allowAddAccountingContext(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 75) & 1) == 1;\n    }\n\n    function allowAddPriceFeed(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 76) & 1) == 1;\n    }\n\n    function allowCrosschainSuckerExtension(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 77) & 1) == 1;\n    }\n\n    function ownerMustSendPayouts(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 78) & 1) == 1;\n    }\n\n    function holdFees(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 79) & 1) == 1;\n    }\n\n    function useTotalSurplusForRedemptions(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 80) & 1) == 1;\n    }\n\n    function useDataHookForPay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 81) & 1 == 1;\n    }\n\n    function useDataHookForRedeem(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 82) & 1 == 1;\n    }\n\n    function dataHook(JBRuleset memory ruleset) internal pure returns (address) {\n        return address(uint160(ruleset.metadata >> 83));\n    }\n\n    function metadata(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 243);\n    }\n\n    /// @notice Pack the funding cycle metadata.\n    /// @param rulesetMetadata The ruleset metadata to validate and pack.\n    /// @return packed The packed uint256 of all metadata params. The first 8 bits specify the version.\n    function packRulesetMetadata(JBRulesetMetadata memory rulesetMetadata) internal pure returns (uint256 packed) {\n        // version 1 in the bits 0-3 (4 bits).\n        packed = 1;\n        // reserved percent in bits 4-19 (16 bits).\n        packed |= uint256(rulesetMetadata.reservedPercent) << 4;\n        // redemption rate in bits 20-35 (16 bits).\n        // redemption rate is a number 0-10000.\n        packed |= uint256(rulesetMetadata.redemptionRate) << 20;\n        // base currency in bits 36-67 (32 bits).\n        // base currency is a number 0-16777215.\n        packed |= uint256(rulesetMetadata.baseCurrency) << 36;\n        // pause pay in bit 68.\n        if (rulesetMetadata.pausePay) packed |= 1 << 68;\n        // pause credit transfers in bit 69.\n        if (rulesetMetadata.pauseCreditTransfers) packed |= 1 << 69;\n        // allow discretionary minting in bit 70.\n        if (rulesetMetadata.allowOwnerMinting) packed |= 1 << 70;\n        // allow a custom token to be set in bit 71.\n        if (rulesetMetadata.allowSetCustomToken) packed |= 1 << 71;\n        // allow terminal migration in bit 72.\n        if (rulesetMetadata.allowTerminalMigration) packed |= 1 << 72;\n        // allow set terminals in bit 73.\n        if (rulesetMetadata.allowSetTerminals) packed |= 1 << 73;\n        // allow set controller in bit 74.\n        if (rulesetMetadata.allowSetController) packed |= 1 << 74;\n        // allow add accounting context in bit 75.\n        if (rulesetMetadata.allowAddAccountingContext) packed |= 1 << 75;\n        // allow add price feed in bit 76.\n        if (rulesetMetadata.allowAddPriceFeed) packed |= 1 << 76;\n        // allow crosschain sucker extension in bit 77.\n        if (rulesetMetadata.allowCrosschainSuckerExtension) packed |= 1 << 77;\n        // allow controller migration in bit 78.\n        if (rulesetMetadata.ownerMustSendPayouts) packed |= 1 << 78;\n        // hold fees in bit 79.\n        if (rulesetMetadata.holdFees) packed |= 1 << 79;\n        // useTotalSurplusForRedemptions in bit 80.\n        if (rulesetMetadata.useTotalSurplusForRedemptions) packed |= 1 << 80;\n        // use pay data source in bit 81.\n        if (rulesetMetadata.useDataHookForPay) packed |= 1 << 81;\n        // use redeem data source in bit 82.\n        if (rulesetMetadata.useDataHookForRedeem) packed |= 1 << 82;\n        // data source address in bits 83-242.\n        packed |= uint256(uint160(address(rulesetMetadata.dataHook))) << 83;\n        // metadata in bits 243-255 (13 bits).\n        packed |= (uint256(rulesetMetadata.metadata) >> 3) << 243;\n    }\n\n    /// @notice Expand the funding cycle metadata.\n    /// @param ruleset The funding cycle having its metadata expanded.\n    /// @return rulesetMetadata The ruleset's metadata object.\n    function expandMetadata(JBRuleset memory ruleset) internal pure returns (JBRulesetMetadata memory) {\n        return JBRulesetMetadata(\n            reservedPercent(ruleset),\n            redemptionRate(ruleset),\n            baseCurrency(ruleset),\n            pausePay(ruleset),\n            pauseCreditTransfers(ruleset),\n            allowOwnerMinting(ruleset),\n            allowSetCustomToken(ruleset),\n            allowTerminalMigration(ruleset),\n            allowSetTerminals(ruleset),\n            allowSetController(ruleset),\n            allowAddAccountingContext(ruleset),\n            allowAddPriceFeed(ruleset),\n            allowCrosschainSuckerExtension(ruleset),\n            ownerMustSendPayouts(ruleset),\n            holdFees(ruleset),\n            useTotalSurplusForRedemptions(ruleset),\n            useDataHookForPay(ruleset),\n            useDataHookForRedeem(ruleset),\n            dataHook(ruleset),\n            metadata(ruleset)\n        );\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBSurplus.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IJBTerminal} from \"../interfaces/IJBTerminal.sol\";\n\n/// @notice Surplus calculations.\nlibrary JBSurplus {\n    /// @notice Gets the total current surplus amount across all of a project's terminals.\n    /// @dev This amount changes as the value of the balances changes in relation to the currency being used to measure\n    /// the project's payout limits.\n    /// @param projectId The ID of the project to get the total surplus for.\n    /// @param terminals The terminals to look for surplus within.\n    /// @param decimals The number of decimals that the fixed point surplus result should include.\n    /// @param currency The currency that the surplus result should be in terms of.\n    /// @return surplus The total surplus of a project's funds in terms of `currency`, as a fixed point number with the\n    /// specified number of decimals.\n    function currentSurplusOf(\n        uint256 projectId,\n        IJBTerminal[] memory terminals,\n        uint256 decimals,\n        uint256 currency\n    )\n        internal\n        view\n        returns (uint256 surplus)\n    {\n        // Keep a reference to the number of termainls.\n        uint256 numberOfTerminals = terminals.length;\n\n        // Add the current surplus for each terminal.\n        for (uint256 i; i < numberOfTerminals; i++) {\n            surplus += terminals[i].currentSurplusOf(projectId, decimals, currency);\n        }\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member projectTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 projectTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAfterRedeemRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member holder The holder of the tokens being redeemed.\n/// @custom:member projectId The ID of the project being redeemed from.\n/// @custom:member rulesetId The ID of the ruleset the redemption is being made during.\n/// @custom:member redeemCount The number of project tokens being redeemed.\n/// @custom:member redemptionRate The current ruleset's redemption rate.\n/// @custom:member reclaimedAmount The token amount being reclaimed from the project's terminal balance. Includes the\n/// token being\n/// reclaimed, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the redeem hook. Includes the token\n/// being forwarded, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member beneficiary The address the reclaimed amount will be sent to.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the redeem hook.\n/// @custom:member redeemerMetadata Extra data specified by the redeemer, which is sent to the redeem hook.\nstruct JBAfterRedeemRecordedContext {\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 redeemCount;\n    JBTokenAmount reclaimedAmount;\n    JBTokenAmount forwardedAmount;\n    uint256 redemptionRate;\n    address payable beneficiary;\n    bytes hookMetadata;\n    bytes redeemerMetadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBBeforePayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon payment.\n/// @custom:member terminal The terminal that is facilitating the payment.\n/// @custom:member payer The address that the payment originated from.\n/// @custom:member amount The payment's token amount, including the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member beneficiary The specified address that should be the beneficiary of anything that this payment\n/// yields.\n/// @custom:member weight The weight of the ruleset during which the payment is being made.\n/// @custom:member reservedPercent The reserved percent of the ruleset the payment is being made during.\n/// @custom:member metadata Extra data specified by the payer.\nstruct JBBeforePayRecordedContext {\n    address terminal;\n    address payer;\n    JBTokenAmount amount;\n    uint256 projectId;\n    uint256 rulesetId;\n    address beneficiary;\n    uint256 weight;\n    uint256 reservedPercent;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBBeforeRedeemRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon redemption.\n/// @custom:member terminal The terminal that is facilitating the redemption.\n/// @custom:member holder The holder of the tokens being redeemed.\n/// @custom:member projectId The ID of the project whose tokens are being redeemed.\n/// @custom:member rulesetId The ID of the ruleset the redemption is being made during.\n/// @custom:member redeemCount The number of tokens being redeemed, as a fixed point number with 18 decimals.\n/// @custom:member totalSupply The total token supply being used for the calculation, as a fixed point number with 18\n/// decimals.\n/// @custom:member surplus The surplus amount used for the calculation, as a fixed point number with 18 decimals.\n/// Includes the token of the surplus, the surplus value, the number of decimals\n/// included, and the currency of the surplus.\n/// @custom:member useTotalSurplus If surplus across all of a project's terminals is being used when making redemptions.\n/// @custom:member redemptionRate The redemption rate of the ruleset the redemption is being made during.\n/// @custom:member metadata Extra data provided by the redeemer.\nstruct JBBeforeRedeemRecordedContext {\n    address terminal;\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 redeemCount;\n    uint256 totalSupply;\n    JBTokenAmount surplus;\n    bool useTotalSurplus;\n    uint256 redemptionRate;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBCurrencyAmount {\n    uint224 amount;\n    uint32 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBPayHookSpecification.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A pay hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The pay hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass the hook.\nstruct JBPayHookSpecification {\n    IJBPayHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint56 projectId;\n    uint8[] permissionIds;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRedeemHookSpecification.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRedeemHook} from \"../interfaces/IJBRedeemHook.sol\";\n\n/// @notice A redeem hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The redeem hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass to the hook.\nstruct JBRedeemHookSpecification {\n    IJBRedeemHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `decayPercent`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member decayPercent The percentage by which to reduce the `weight` each time a new ruleset starts. `weight`\n/// is\n/// a percentage out of `JBConstants.MAX_DECAY_PERCENT`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `decayPercent` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint48 cycleNumber;\n    uint48 id;\n    uint48 basedOnId;\n    uint48 start;\n    uint32 duration;\n    uint112 weight;\n    uint32 decayPercent;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active  any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a decayed `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member decayPercent A percent by how much the `weight` of the subsequent ruleset should be reduced, if the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_DECAY_PERCENT`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint48 mustStartAtOrAfter;\n    uint32 duration;\n    uint112 weight;\n    uint32 decayPercent;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedPercent The reserved percent of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_PERCENT`.\n/// @custom:member redemptionRate The redemption rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_REDEMPTION_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member allowAddAccountingContext A flag indicating if a project can add new accounting contexts for its\n/// terminals to use.\n/// @custom:member allowAddPriceFeed A flag indicating if a project can add new price feeds to calculate exchange rates\n/// between its tokens.\n/// @custom:member allowCrosschainSuckerExtension A flag indicating if the crosschain sucker extension should be\n/// allowed during this ruleset.\n/// @custom:member ownerMustSendPayouts A flag indicating if privileged payout distribution should be\n/// enforced, otherwise payouts can be distributed by anyone.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForRedemptions A flag indicating if redemptions should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the redemption is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForRedeem A flag indicating if the data hook should be used for redeem transactions during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, up to uint16 in size though only the first 14 bits can be used.\nstruct JBRulesetMetadata {\n    uint16 reservedPercent;\n    uint16 redemptionRate;\n    uint32 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowSetCustomToken;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool allowAddAccountingContext;\n    bool allowAddPriceFeed;\n    bool allowCrosschainSuckerExtension;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForRedemptions;\n    bool useDataHookForPay;\n    bool useDataHookForRedeem;\n    address dataHook;\n    uint16 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSingleAllowance.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member sigDeadline Deadline on the permit signature.\n/// @custom:member amount The maximum amount allowed to spend.\n/// @custom:member expiration Timestamp at which a spender's token allowances become invalid.\n/// @custom:member nonce An incrementing value indexed per owner,token,and spender for each signature.\n/// @custom:member signature The signature over the permit data. Supports EOA signatures, compact signatures defined by\n/// EIP-2098, and contract signatures defined by EIP-1271.\nstruct JBSingleAllowance {\n    uint256 sigDeadline;\n    uint160 amount;\n    uint48 expiration;\n    uint48 nonce;\n    bytes signature;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    bool preferAddToBalance;\n    uint32 percent;\n    uint56 projectId;\n    address payable beneficiary;\n    uint48 lockedUntil;\n    IJBSplitHook hook;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group. By convention, this ID is `uint256(uint160(tokenAddress))` for\n/// payouts and `1` for reserved tokens.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to. By convention, this ID is `uint256(uint160(tokenAddress))`\n/// for payouts and `1` for reserved tokens.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAccountingContext} from \"./JBAccountingContext.sol\";\nimport {IJBTerminal} from \"./../interfaces/IJBTerminal.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member accountingContextsToAccept The accounting contexts to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    JBAccountingContext[] accountingContextsToAccept;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\nstruct JBTokenAmount {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n    uint256 value;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\n\nimport {JBOwnableOverrides} from \"./JBOwnableOverrides.sol\";\n\ncontract JBOwnable is JBOwnableOverrides {\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param initialProjectIdOwner The initial project id that owns this contract.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        address initialOwner,\n        uint88 initialProjectIdOwner\n    )\n        JBOwnableOverrides(permissions, projects, initialOwner, initialProjectIdOwner)\n    {}\n\n    //*********************************************************************//\n    // --------------------------- modifiers ----------------------------- //\n    //*********************************************************************//\n\n    /// @notice Reverts if called by an address that is not the owner and does not have permission from the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Either `newOwner` or `newProjectId` is non-zero or both are zero. But they can never both be non-zero.\n    /// @dev This function exists because some contracts will try to deploy contracts for a project before\n    function _emitTransferEvent(\n        address previousOwner,\n        address newOwner,\n        uint88 newProjectId\n    )\n        internal\n        virtual\n        override\n    {\n        emit OwnershipTransferred({\n            previousOwner: previousOwner,\n            newOwner: newProjectId == 0 ? newOwner : PROJECTS.ownerOf(newProjectId),\n            caller: msg.sender\n        });\n    }\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnableOverrides.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBOwnable} from \"./interfaces/IJBOwnable.sol\";\nimport {JBOwner} from \"./struct/JBOwner.sol\";\n\n/// @notice Access control module to grant exclusive access to a specified address (the owner) for specific functions.\n/// The owner can also grant access permissions to other addresses via `JBPermissions`.\n/// @dev Inherit this contract to make the `onlyOwner` modifier available. When applied to a function, this modifier\n/// restricts use to the owner and addresses with the appropriate permission from the owner.\nabstract contract JBOwnableOverrides is Context, JBPermissioned, IJBOwnable {\n    //*********************************************************************//\n    // --------------------------- custom errors --------------------------//\n    //*********************************************************************//b\n\n    error JBOwnableOverrides_InvalidNewOwner();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice This contract's owner information.\n    JBOwner public override jbOwner;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param initialProjectIdOwner The initial project id that owns this contract.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        address initialOwner,\n        uint88 initialProjectIdOwner\n    )\n        JBPermissioned(permissions)\n    {\n        PROJECTS = projects;\n\n        // We force the inheriting contract to set an owner, as there is a\n        // low chance someone will use `JBOwnable` to create an unowned contract.\n        // But a higher chance that both are accidentally set to be `0`.\n        // If you really want an unowned contract, set the owner to any address then renounce in the constructor body.\n        if (initialProjectIdOwner == 0 && initialOwner == address(0)) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n\n        _transferOwnership(initialOwner, initialProjectIdOwner);\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the owner's address based on this contract's `JBOwner` owner information.\n    /// @return owner The owner's address.\n    function owner() public view virtual returns (address) {\n        JBOwner memory ownerInfo = jbOwner;\n\n        if (ownerInfo.projectId == 0) {\n            return ownerInfo.owner;\n        }\n\n        return PROJECTS.ownerOf(ownerInfo.projectId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Reverts if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        JBOwner memory ownerInfo = jbOwner;\n\n        _requirePermissionFrom({\n            account: ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId),\n            projectId: ownerInfo.projectId,\n            permissionId: ownerInfo.permissionId\n        });\n    }\n\n    //*********************************************************************//\n    // ---------------------- public transactions ------------------------ //\n    //*********************************************************************//\n\n    /// @notice Gives up ownership of this contract, making it impossible to call `onlyOwner`/`_checkOwner` functions.\n    /// Can only be called by the current owner.\n    function renounceOwnership() public virtual override {\n        _checkOwner();\n        _transferOwnership(address(0), 0);\n    }\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function setPermissionId(uint8 permissionId) public virtual override {\n        _checkOwner();\n        _setPermissionId(permissionId);\n    }\n\n    /// @notice Transfers ownership of this contract to a new account (the `newOwner`). Can only be called by the\n    /// current owner.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function transferOwnership(address newOwner) public virtual override {\n        _checkOwner();\n        if (newOwner == address(0)) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfer ownership of this contract to a new Juicebox project.\n    /// @dev The `projectId` must fit within a `uint88`.\n    /// @param projectId The ID of the project that should receive ownership of this contract.\n    function transferOwnershipToProject(uint256 projectId) public virtual override {\n        _checkOwner();\n        if (projectId == 0 || projectId > type(uint88).max) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n\n        _transferOwnership(address(0), uint88(projectId));\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Either `newOwner` or `newProjectId` is non-zero or both are zero. But they can never both be non-zero.\n    /// @dev This function exists because some contracts will try to deploy contracts for a project before\n    function _emitTransferEvent(address previousOwner, address newOwner, uint88 newProjectId) internal virtual;\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @dev Internal function without access restriction.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function _setPermissionId(uint8 permissionId) internal virtual {\n        jbOwner.permissionId = permissionId;\n        emit PermissionIdChanged({newId: permissionId, caller: msg.sender});\n    }\n\n    /// @notice Helper to allow for drop-in replacement of OpenZeppelin.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function _transferOwnership(address newOwner) internal virtual {\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfers this contract's ownership to an address (`newOwner`) OR a Juicebox project (`projectId`).\n    /// @dev Updates this contract's `JBOwner` owner information.\n    /// @dev If both `newOwner` and `projectId` are set, this will revert.\n    /// @dev Internal function without access restriction.\n    /// @param newOwner The address that should receive ownership of this contract.\n    /// @param projectId The ID of the project that this contract should respect the ownership of.\n    function _transferOwnership(address newOwner, uint88 projectId) internal virtual {\n        // Can't set both a new owner and a new project ID.\n        if (projectId != 0 && newOwner != address(0)) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n        // Load the owner information from storage.\n        JBOwner memory ownerInfo = jbOwner;\n        // Get the address of the old owner.\n        address oldOwner = ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId);\n        // Update the stored owner information to the new owner and reset the `permissionId`.\n        // This is to prevent permissions clashes for the new user/owner.\n        jbOwner = JBOwner({owner: newOwner, projectId: projectId, permissionId: 0});\n        // Emit a transfer event with the new owner's address.\n        _emitTransferEvent(oldOwner, newOwner, projectId);\n    }\n}\n"
			},
			"node_modules/@bananapus/ownable/src/interfaces/IJBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\n\ninterface IJBOwnable {\n    event PermissionIdChanged(uint8 newId, address caller);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n    function jbOwner() external view returns (address owner, uint88 projectOwner, uint8 permissionId);\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n    function setPermissionId(uint8 permissionId) external;\n    function transferOwnership(address newOwner) external;\n    function transferOwnershipToProject(uint256 projectId) external;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/struct/JBOwner.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Owner information for a given instance of `JBOwnableOverrides`.\n/// @custom:member owner If `projectId` is 0 and this is set, this static address has owner access.\n/// @custom:member projectId Unless this is 0, this project's owner has owner access.\n/// @custom:member permissionId The ID of the permission required from the project's owner to have owner access. See\n/// `JBPermissions` in `juice-contracts-v4`.\nstruct JBOwner {\n    address owner;\n    uint88 projectId;\n    uint8 permissionId;\n}\n"
			},
			"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem. See\n/// [`JBPermissions`](https://github.com/Bananapus/nana-core/blob/main/src/JBPermissions.sol)\n/// @dev `JBPermissions` allows one address to grant another address permission to call functions in Juicebox contracts\n/// on their behalf. Each ID in `JBPermissionIds` grants access to a specific set of these functions.\nlibrary JBPermissionIds {\n    uint8 internal constant ROOT = 1; // All permissions across every contract. Very dangerous. BE CAREFUL!\n\n    /* Used by `nana-core`: https://github.com/Bananapus/nana-core */\n    uint8 internal constant QUEUE_RULESETS = 2; // Permission to call `JBController.queueRulesetsOf` and\n        // `JBController.launchRulesetsFor`.\n    uint8 internal constant REDEEM_TOKENS = 3; // Permission to call `JBMultiTerminal.redeemTokensOf`.\n    uint8 internal constant SEND_PAYOUTS = 4; // Permission to call `JBMultiTerminal.sendPayoutsOf`.\n    uint8 internal constant MIGRATE_TERMINAL = 5; // Permission to call `JBMultiTerminal.migrateBalanceOf`.\n    uint8 internal constant SET_PROJECT_URI = 6; // Permission to call `JBController.setUriOf`.\n    uint8 internal constant DEPLOY_ERC20 = 7; // Permission to call `JBController.deployERC20For`.\n    uint8 internal constant SET_TOKEN = 8; // Permission to call `JBController.setTokenFor`.\n    uint8 internal constant MINT_TOKENS = 9; // Permission to call `JBController.mintTokensOf`.\n    uint8 internal constant BURN_TOKENS = 10; // Permission to call `JBController.burnTokensOf`.\n    uint8 internal constant CLAIM_TOKENS = 11; // Permission to call `JBController.claimTokensFor`.\n    uint8 internal constant TRANSFER_CREDITS = 12; // Permission to call `JBController.transferCreditsFrom`.\n    uint8 internal constant SET_CONTROLLER = 13; // Permission to call `JBDirectory.setControllerOf`.\n    uint8 internal constant SET_TERMINALS = 14; // Permission to call `JBDirectory.setTerminalsOf`.\n    // Be careful - `SET_TERMINALS` can be used to remove the primary terminal.\n    uint8 internal constant SET_PRIMARY_TERMINAL = 15; // Permission to call `JBDirectory.setPrimaryTerminalOf`.\n    uint8 internal constant USE_ALLOWANCE = 16; // Permission to call `JBMultiTerminal.useAllowanceOf`.\n    uint8 internal constant SET_SPLIT_GROUPS = 17; // Permission to call `JBController.setSplitGroupsOf`.\n    uint8 internal constant ADD_PRICE_FEED = 18; // Permission to call `JBPrices.addPriceFeedFor`.\n    uint8 internal constant ADD_ACCOUNTING_CONTEXTS = 19; // Permission to call\n        // `JBMultiTerminal.addAccountingContextsFor`.\n\n    /* Used by `nana-721-hook`: https://github.com/Bananapus/nana-721-hook */\n    uint8 internal constant ADJUST_721_TIERS = 20; // Permission to call `JB721TiersHook.adjustTiers`.\n    uint8 internal constant SET_721_METADATA = 21; // Permission to call `JB721TiersHook.setMetadata`.\n    uint8 internal constant MINT_721 = 22; // Permission to call `JB721TiersHook.mintFor`.\n    uint8 internal constant SET_721_DISCOUNT_PERCENT = 23; // Permission to call `JB721TiersHook.setDiscountPercentOf`.\n\n    /* Used by `nana-buyback-hook`: https://github.com/Bananapus/nana-buyback-hook */\n    uint8 internal constant SET_BUYBACK_TWAP = 24; // Permission to call `JBBuybackHook.setTwapWindowOf` and\n        // `JBBuybackHook.setTwapSlippageToleranceOf`.\n    uint8 internal constant SET_BUYBACK_POOL = 25; // Permission to call `JBBuybackHook.setPoolFor`.\n\n    /* Used by `nana-swap-terminal`: https://github.com/Bananapus/nana-swap-terminal */\n    uint8 internal constant ADD_SWAP_TERMINAL_POOL = 26; // Permission to call `JBSwapTerminal.addDefaultPool`.\n    uint8 internal constant ADD_SWAP_TERMINAL_TWAP_PARAMS = 27; // Permission to call\n        // `JBSwapTerminal.addTwapParamsFor`.\n\n    /* Used by `nana-suckers`: https://github.com/Bananapus/nana-suckers */\n    uint8 internal constant MAP_SUCKER_TOKEN = 28; // Permission to call `BPSucker.mapToken`.\n    uint8 internal constant DEPLOY_SUCKERS = 29; // Permission to call `BPSuckerRegistry.deploySuckersFor`.\n}\n"
			},
			"node_modules/@bananapus/suckers/src/enums/JBAddToBalanceMode.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Options for how a `JBSucker`'s `amountToAddToBalance` gets added to its project's balance.\n/// @custom:element MANUAL The amount gets added to the project's balance manually by calling\n/// `addOutstandingAmountToBalance`.\n/// @custom:element ON_CLAIM The amount gets added to the project's balance automatically when `claim` is called.\nenum JBAddToBalanceMode {\n    MANUAL,\n    ON_CLAIM\n}\n"
			},
			"node_modules/@bananapus/suckers/src/interfaces/IJBSucker.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\n\nimport {JBAddToBalanceMode} from \"../enums/JBAddToBalanceMode.sol\";\nimport {JBInboxTreeRoot} from \"../structs/JBInboxTreeRoot.sol\";\nimport {JBOutboxTree} from \"../structs/JBOutboxTree.sol\";\nimport {JBRemoteToken} from \"../structs/JBRemoteToken.sol\";\nimport {JBTokenMapping} from \"../structs/JBTokenMapping.sol\";\n\ninterface IJBSucker {\n    event Claimed(\n        address beneficiary,\n        address token,\n        uint256 projectTokenCount,\n        uint256 terminalTokenAmount,\n        uint256 index,\n        bool autoAddedToBalance,\n        address caller\n    );\n    event InsertToOutboxTree(\n        address indexed beneficiary,\n        address indexed token,\n        bytes32 hashed,\n        uint256 index,\n        bytes32 root,\n        uint256 projectTokenCount,\n        uint256 terminalTokenAmount,\n        address caller\n    );\n    event NewInboxTreeRoot(address indexed token, uint64 nonce, bytes32 root, address caller);\n    event RootToRemote(bytes32 indexed root, address indexed token, uint256 index, uint64 nonce, address caller);\n\n    function MESSENGER_BASE_GAS_LIMIT() external view returns (uint32);\n    function MESSENGER_ERC20_MIN_GAS_LIMIT() external view returns (uint32);\n\n    function ADD_TO_BALANCE_MODE() external view returns (JBAddToBalanceMode);\n    function DEPLOYER() external view returns (address);\n    function DIRECTORY() external view returns (IJBDirectory);\n    function PEER() external view returns (address);\n    function PROJECT_ID() external view returns (uint256);\n    function TOKENS() external view returns (IJBTokens);\n\n    function amountToAddToBalanceOf(address token) external view returns (uint256 amount);\n    function inboxOf(address token) external view returns (JBInboxTreeRoot memory);\n    function outboxOf(address token) external view returns (JBOutboxTree memory);\n    function remoteTokenFor(address token) external view returns (JBRemoteToken memory);\n\n    function peerChainId() external view returns (uint256 chainId);\n    function isMapped(address token) external view returns (bool);\n\n    function prepare(\n        uint256 projectTokenAmount,\n        address beneficiary,\n        uint256 minTokensReclaimed,\n        address token\n    )\n        external;\n    function mapToken(JBTokenMapping calldata map) external;\n    function mapTokens(JBTokenMapping[] calldata maps) external;\n}\n"
			},
			"node_modules/@bananapus/suckers/src/interfaces/IJBSuckerDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\n\nimport {IJBSucker} from \"./IJBSucker.sol\";\n\ninterface IJBSuckerDeployer {\n    function DIRECTORY() external view returns (IJBDirectory);\n    function TOKENS() external view returns (IJBTokens);\n    function LAYER_SPECIFIC_CONFIGURATOR() external view returns (address);\n\n    function isSucker(address sucker) external view returns (bool);\n    function tempStoreId() external view returns (uint256);\n\n    function createForSender(uint256 localProjectId, bytes32 salt) external returns (IJBSucker sucker);\n}\n"
			},
			"node_modules/@bananapus/suckers/src/interfaces/IJBSuckerRegistry.sol": {
				"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.21;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\n\nimport {JBSuckerDeployerConfig} from \"../structs/JBSuckerDeployerConfig.sol\";\n\ninterface IJBSuckerRegistry {\n    event SuckerDeployedFor(uint256 projectId, address sucker, JBSuckerDeployerConfig configuration, address caller);\n    event SuckerDeployerAllowed(address deployer, address caller);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n    function PROJECTS() external view returns (IJBProjects);\n\n    function isSuckerOf(uint256 projectId, address addr) external view returns (bool);\n    function suckersOf(uint256 projectId) external view returns (address[] memory);\n    function suckerDeployerIsAllowed(address deployer) external view returns (bool);\n\n    function allowSuckerDeployer(address deployer) external;\n    function deploySuckersFor(\n        uint256 projectId,\n        bytes32 salt,\n        JBSuckerDeployerConfig[] memory configurations\n    )\n        external\n        returns (address[] memory suckers);\n}\n"
			},
			"node_modules/@bananapus/suckers/src/structs/JBInboxTreeRoot.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice The root of an inbox tree for a given token in a `JBSucker`.\n/// @dev Inbox trees are used to receive from the remote chain to the local chain. Tokens can be `claim`ed from the\n/// inbox tree.\n/// @custom:member nonce Tracks the nonce of the tree. The nonce cannot decrease.\n/// @custom:member root The root of the tree.\nstruct JBInboxTreeRoot {\n    uint64 nonce;\n    bytes32 root;\n}\n"
			},
			"node_modules/@bananapus/suckers/src/structs/JBOutboxTree.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {MerkleLib} from \"../utils/MerkleLib.sol\";\n\n/// @notice A merkle tree used to track the outbox for a given token in a `JBSucker`.\n/// @dev The outbox is used to send from the local chain to the remote chain.\n/// @custom:member nonce The nonce of the outbox.\n/// @custom:member balance The balance of the outbox.\n/// @custom:member tree The merkle tree.\nstruct JBOutboxTree {\n    uint64 nonce;\n    uint256 balance;\n    MerkleLib.Tree tree;\n}\n"
			},
			"node_modules/@bananapus/suckers/src/structs/JBRemoteToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A struct that represents a token on the remote chain.\n/// @custom:member minGas The minimum gas to use when bridging.\n/// @custom:member addr The address of the token on the remote chain.\n/// @custom:member minBridgeAmount The minimum amount to bridge.\nstruct JBRemoteToken {\n    uint32 minGas;\n    address addr;\n    uint256 minBridgeAmount;\n}\n"
			},
			"node_modules/@bananapus/suckers/src/structs/JBSuckerDeployerConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSuckerDeployer} from \"../interfaces/IJBSuckerDeployer.sol\";\nimport {JBTokenMapping} from \"./JBTokenMapping.sol\";\n\n/// @custom:member deployer The deployer to use.\n/// @custom:member mappings The token mappings to use.\nstruct JBSuckerDeployerConfig {\n    IJBSuckerDeployer deployer;\n    JBTokenMapping[] mappings;\n}\n"
			},
			"node_modules/@bananapus/suckers/src/structs/JBTokenMapping.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member localToken The local token address.\n/// @custom:member minGas The minimum gas amount to bridge.\n/// @custom:member remoteToken The remote token address.\n/// @custom:member minBridgeAmount The minimum bridge amount.\nstruct JBTokenMapping {\n    address localToken;\n    uint32 minGas;\n    address remoteToken;\n    uint256 minBridgeAmount;\n}\n"
			},
			"node_modules/@bananapus/suckers/src/utils/MerkleLib.sol": {
				"content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.23;\n\n/**\n * @title MerkleLib\n * @author Illusory Systems Inc.\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\n *\n */\nlibrary MerkleLib {\n    // ========== Custom Errors ===========\n\n    error MerkleLib__insert_treeIsFull();\n\n    // ============ Constants =============\n\n    uint256 internal constant TREE_DEPTH = 32;\n    uint256 internal constant MAX_LEAVES = 2 ** TREE_DEPTH - 1;\n\n    /**\n     * @dev Z_i represent the hash values at different heights for a binary tree with leaf values equal to `0`.\n     * (e.g. Z_1 is the keccak256 hash of (0x0, 0x0), Z_2 is the keccak256 hash of (Z_1, Z_1), etc...)\n     * Z_0 is the bottom of the 33-layer tree, Z_32 is the top (i.e. root).\n     * Used to shortcut calculation in root calculation methods below.\n     */\n    bytes32 internal constant Z_0 = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n    bytes32 internal constant Z_1 = hex\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\";\n    bytes32 internal constant Z_2 = hex\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\";\n    bytes32 internal constant Z_3 = hex\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\";\n    bytes32 internal constant Z_4 = hex\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\";\n    bytes32 internal constant Z_5 = hex\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\";\n    bytes32 internal constant Z_6 = hex\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\";\n    bytes32 internal constant Z_7 = hex\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\";\n    bytes32 internal constant Z_8 = hex\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\";\n    bytes32 internal constant Z_9 = hex\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\";\n    bytes32 internal constant Z_10 = hex\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\";\n    bytes32 internal constant Z_11 = hex\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\";\n    bytes32 internal constant Z_12 = hex\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\";\n    bytes32 internal constant Z_13 = hex\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\";\n    bytes32 internal constant Z_14 = hex\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\";\n    bytes32 internal constant Z_15 = hex\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\";\n    bytes32 internal constant Z_16 = hex\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\";\n    bytes32 internal constant Z_17 = hex\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\";\n    bytes32 internal constant Z_18 = hex\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\";\n    bytes32 internal constant Z_19 = hex\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\";\n    bytes32 internal constant Z_20 = hex\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\";\n    bytes32 internal constant Z_21 = hex\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\";\n    bytes32 internal constant Z_22 = hex\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\";\n    bytes32 internal constant Z_23 = hex\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\";\n    bytes32 internal constant Z_24 = hex\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\";\n    bytes32 internal constant Z_25 = hex\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\";\n    bytes32 internal constant Z_26 = hex\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\";\n    bytes32 internal constant Z_27 = hex\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\";\n    bytes32 internal constant Z_28 = hex\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\";\n    bytes32 internal constant Z_29 = hex\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\";\n    bytes32 internal constant Z_30 = hex\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\";\n    bytes32 internal constant Z_31 = hex\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\";\n    bytes32 internal constant Z_32 = hex\"27ae5ba08d7291c96c8cbddcc148bf48a6d68c7974b94356f53754ef6171d757\";\n\n    // ============= Structs ==============\n\n    /**\n     * @notice Struct representing incremental merkle tree. Contains current\n     * branch and the number of inserted leaves in the tree.\n     *\n     */\n    struct Tree {\n        bytes32[TREE_DEPTH] branch;\n        uint256 count;\n    }\n\n    // ========= Write Methods =========\n\n    /**\n     * @notice Inserts a given node (leaf) into merkle tree. Operates on an in-memory tree and\n     * returns an updated version of that tree.\n     * @dev Reverts if the tree is already full.\n     * @param node Element to insert into tree.\n     * @return Tree Updated tree.\n     *\n     */\n    function insert(Tree memory tree, bytes32 node) internal pure returns (Tree memory) {\n        // Update tree.count to increase the current count by 1 since we'll be including a new node.\n        uint256 size = ++tree.count;\n        if (size > MAX_LEAVES) revert MerkleLib__insert_treeIsFull();\n\n        // Loop starting at 0, ending when we've finished inserting the node (i.e. hashing it) into\n        // the active branch. Each loop we cut size in half, hashing the inserted node up the active\n        // branch along the way.\n        for (uint256 i; i < TREE_DEPTH;) {\n            // Check if the current size is odd; if so, we set this index in the branch to be the node.\n            if ((size & 1) == 1) {\n                // If i > 0, then this node will be a hash of the original node with every layer up\n                // until layer `i`.\n                tree.branch[i] = node;\n                return tree;\n            }\n            // If the size is not yet odd, we hash the current index in the tree branch with the node.\n            node = keccak256(abi.encodePacked(tree.branch[i], node));\n            size >>= 1; // Cut size in half (statement equivalent to: `size /= 2`).\n\n            unchecked {\n                ++i;\n            }\n        }\n        // As the loop should always end prematurely with the `return` statement, this code should\n        // be unreachable. We revert here just to be safe.\n        revert MerkleLib__insert_treeIsFull();\n    }\n\n    // ========= Read Methods =========\n\n    /**\n     * @notice Calculates and returns tree's current root.\n     * @return _current bytes32 root.\n     *\n     */\n    function root(Tree storage tree) internal view returns (bytes32 _current) {\n        uint256 _index = tree.count;\n\n        if (_index == 0) {\n            return Z_32;\n        }\n\n        uint256 i;\n        assembly {\n            let TREE_SLOT := tree.slot\n\n            for {} true {} {\n                for {} true {} {\n                    if and(_index, 1) {\n                        mstore(0, sload(TREE_SLOT))\n                        mstore(0x20, Z_0)\n                        _current := keccak256(0, 0x40)\n                        break\n                    }\n\n                    if and(_index, shl(1, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 1)))\n                        mstore(0x20, Z_1)\n                        _current := keccak256(0, 0x40)\n                        i := 1\n                        break\n                    }\n\n                    if and(_index, shl(2, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 2)))\n                        mstore(0x20, Z_2)\n                        _current := keccak256(0, 0x40)\n                        i := 2\n                        break\n                    }\n\n                    if and(_index, shl(3, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 3)))\n                        mstore(0x20, Z_3)\n                        _current := keccak256(0, 0x40)\n                        i := 3\n                        break\n                    }\n\n                    if and(_index, shl(4, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 4)))\n                        mstore(0x20, Z_4)\n                        _current := keccak256(0, 0x40)\n                        i := 4\n                        break\n                    }\n\n                    if and(_index, shl(5, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 5)))\n                        mstore(0x20, Z_5)\n                        _current := keccak256(0, 0x40)\n                        i := 5\n                        break\n                    }\n\n                    if and(_index, shl(6, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 6)))\n                        mstore(0x20, Z_6)\n                        _current := keccak256(0, 0x40)\n                        i := 6\n                        break\n                    }\n\n                    if and(_index, shl(7, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 7)))\n                        mstore(0x20, Z_7)\n                        _current := keccak256(0, 0x40)\n                        i := 7\n                        break\n                    }\n\n                    if and(_index, shl(8, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 8)))\n                        mstore(0x20, Z_8)\n                        _current := keccak256(0, 0x40)\n                        i := 8\n                        break\n                    }\n\n                    if and(_index, shl(9, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 9)))\n                        mstore(0x20, Z_9)\n                        _current := keccak256(0, 0x40)\n                        i := 9\n                        break\n                    }\n\n                    if and(_index, shl(10, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 10)))\n                        mstore(0x20, Z_10)\n                        _current := keccak256(0, 0x40)\n                        i := 10\n                        break\n                    }\n\n                    if and(_index, shl(11, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 11)))\n                        mstore(0x20, Z_11)\n                        _current := keccak256(0, 0x40)\n                        i := 11\n                        break\n                    }\n\n                    if and(_index, shl(12, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 12)))\n                        mstore(0x20, Z_12)\n                        _current := keccak256(0, 0x40)\n                        i := 12\n                        break\n                    }\n\n                    if and(_index, shl(13, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 13)))\n                        mstore(0x20, Z_13)\n                        _current := keccak256(0, 0x40)\n                        i := 13\n                        break\n                    }\n\n                    if and(_index, shl(14, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 14)))\n                        mstore(0x20, Z_14)\n                        _current := keccak256(0, 0x40)\n                        i := 14\n                        break\n                    }\n\n                    if and(_index, shl(15, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 15)))\n                        mstore(0x20, Z_15)\n                        _current := keccak256(0, 0x40)\n                        i := 15\n                        break\n                    }\n\n                    if and(_index, shl(16, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 16)))\n                        mstore(0x20, Z_16)\n                        _current := keccak256(0, 0x40)\n                        i := 16\n                        break\n                    }\n\n                    if and(_index, shl(17, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 17)))\n                        mstore(0x20, Z_17)\n                        _current := keccak256(0, 0x40)\n                        i := 17\n                        break\n                    }\n\n                    if and(_index, shl(18, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 18)))\n                        mstore(0x20, Z_18)\n                        _current := keccak256(0, 0x40)\n                        i := 18\n                        break\n                    }\n\n                    if and(_index, shl(19, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 19)))\n                        mstore(0x20, Z_19)\n                        _current := keccak256(0, 0x40)\n                        i := 19\n                        break\n                    }\n\n                    if and(_index, shl(20, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 20)))\n                        mstore(0x20, Z_20)\n                        _current := keccak256(0, 0x40)\n                        i := 20\n                        break\n                    }\n\n                    if and(_index, shl(21, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 21)))\n                        mstore(0x20, Z_21)\n                        _current := keccak256(0, 0x40)\n                        i := 21\n                        break\n                    }\n\n                    if and(_index, shl(22, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 22)))\n                        mstore(0x20, Z_22)\n                        _current := keccak256(0, 0x40)\n                        i := 22\n                        break\n                    }\n\n                    if and(_index, shl(23, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 23)))\n                        mstore(0x20, Z_23)\n                        _current := keccak256(0, 0x40)\n                        i := 23\n                        break\n                    }\n\n                    if and(_index, shl(24, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 24)))\n                        mstore(0x20, Z_24)\n                        _current := keccak256(0, 0x40)\n                        i := 24\n                        break\n                    }\n\n                    if and(_index, shl(25, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 25)))\n                        mstore(0x20, Z_25)\n                        _current := keccak256(0, 0x40)\n                        i := 25\n                        break\n                    }\n\n                    if and(_index, shl(26, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 26)))\n                        mstore(0x20, Z_26)\n                        _current := keccak256(0, 0x40)\n                        i := 26\n                        break\n                    }\n\n                    if and(_index, shl(27, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 27)))\n                        mstore(0x20, Z_27)\n                        _current := keccak256(0, 0x40)\n                        i := 27\n                        break\n                    }\n\n                    if and(_index, shl(28, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 28)))\n                        mstore(0x20, Z_28)\n                        _current := keccak256(0, 0x40)\n                        i := 28\n                        break\n                    }\n\n                    if and(_index, shl(29, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 29)))\n                        mstore(0x20, Z_29)\n                        _current := keccak256(0, 0x40)\n                        i := 29\n                        break\n                    }\n\n                    if and(_index, shl(30, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 30)))\n                        mstore(0x20, Z_30)\n                        _current := keccak256(0, 0x40)\n                        i := 30\n                        break\n                    }\n\n                    if and(_index, shl(31, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 31)))\n                        mstore(0x20, Z_31)\n                        _current := keccak256(0, 0x40)\n                        // slither-disable-next-line write-after-write\n                        i := 31\n                        break\n                    }\n\n                    // slither-disable-next-line write-after-write\n                    _current := Z_32\n                    i := 32\n                    break\n                }\n\n                if gt(i, 30) { break }\n\n                {\n                    if lt(i, 1) {\n                        switch and(_index, shl(1, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_1)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 1)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 2) {\n                        switch and(_index, shl(2, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_2)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 2)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 3) {\n                        switch and(_index, shl(3, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_3)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 3)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 4) {\n                        switch and(_index, shl(4, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_4)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 4)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 5) {\n                        switch and(_index, shl(5, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_5)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 5)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 6) {\n                        switch and(_index, shl(6, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_6)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 6)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 7) {\n                        switch and(_index, shl(7, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_7)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 7)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 8) {\n                        switch and(_index, shl(8, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_8)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 8)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 9) {\n                        switch and(_index, shl(9, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_9)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 9)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 10) {\n                        switch and(_index, shl(10, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_10)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 10)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 11) {\n                        switch and(_index, shl(11, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_11)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 11)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 12) {\n                        switch and(_index, shl(12, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_12)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 12)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 13) {\n                        switch and(_index, shl(13, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_13)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 13)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 14) {\n                        switch and(_index, shl(14, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_14)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 14)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 15) {\n                        switch and(_index, shl(15, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_15)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 15)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 16) {\n                        switch and(_index, shl(16, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_16)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 16)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 17) {\n                        switch and(_index, shl(17, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_17)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 17)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 18) {\n                        switch and(_index, shl(18, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_18)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 18)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 19) {\n                        switch and(_index, shl(19, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_19)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 19)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 20) {\n                        switch and(_index, shl(20, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_20)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 20)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 21) {\n                        switch and(_index, shl(21, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_21)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 21)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 22) {\n                        switch and(_index, shl(22, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_22)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 22)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 23) {\n                        switch and(_index, shl(23, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_23)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 23)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 24) {\n                        switch and(_index, shl(24, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_24)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 24)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 25) {\n                        switch and(_index, shl(25, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_25)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 25)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 26) {\n                        switch and(_index, shl(26, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_26)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 26)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 27) {\n                        switch and(_index, shl(27, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_27)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 27)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 28) {\n                        switch and(_index, shl(28, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_28)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 28)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 29) {\n                        switch and(_index, shl(29, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_29)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 29)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 30) {\n                        switch and(_index, shl(30, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_30)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 30)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 31) {\n                        switch and(_index, shl(31, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_31)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 31)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n                }\n\n                break\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates and returns the merkle root for the given leaf `_item`,\n     * a merkle branch, and the index of `_item` in the tree.\n     * @param _item Merkle leaf\n     * @param _branch Merkle proof\n     * @param _index Index of `_item` in tree\n     * @return _current Calculated merkle root\n     *\n     */\n    function branchRoot(\n        bytes32 _item,\n        bytes32[TREE_DEPTH] memory _branch,\n        uint256 _index\n    )\n        internal\n        pure\n        returns (bytes32 _current)\n    {\n        assembly {\n            _current := _item\n            let BRANCH_DATA_OFFSET := _branch\n            let f\n\n            f := shl(5, and(_index, 1))\n            mstore(f, _current)\n            mstore(sub(0x20, f), mload(BRANCH_DATA_OFFSET))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(1, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 1))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(2, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 2))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(3, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 3))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(4, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 4))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(5, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 5))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(6, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 6))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(7, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 7))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(8, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 8))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(9, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 9))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(10, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 10))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(11, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 11))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(12, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 12))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(13, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 13))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(14, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 14))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(15, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 15))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(16, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 16))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(17, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 17))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(18, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 18))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(19, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 19))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(20, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 20))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(21, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 21))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(22, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 22))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(23, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 23))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(24, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 24))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(25, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 25))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(26, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 26))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(27, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 27))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(28, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 28))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(29, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 29))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(30, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 30))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(31, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 31))))\n            _current := keccak256(0, 0x40)\n        }\n    }\n}\n"
			},
			"node_modules/@croptop/core/src/CTPublisher.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {JB721Tier} from \"@bananapus/721-hook/src/structs/JB721Tier.sol\";\nimport {JB721TierConfig} from \"@bananapus/721-hook/src/structs/JB721TierConfig.sol\";\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBTerminal} from \"@bananapus/core/src/interfaces/IJBTerminal.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\nimport {JBMetadataResolver} from \"@bananapus/core/src/libraries/JBMetadataResolver.sol\";\nimport {JBOwnable} from \"@bananapus/ownable/src/JBOwnable.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {ICTPublisher} from \"./interfaces/ICTPublisher.sol\";\nimport {CTAllowedPost} from \"./structs/CTAllowedPost.sol\";\nimport {CTPost} from \"./structs/CTPost.sol\";\n\n/// @notice A contract that facilitates the permissioned publishing of NFT posts to a Juicebox project.\ncontract CTPublisher is JBPermissioned, ERC2771Context, ICTPublisher {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error CTPublisher_EmptyEncodedIPFSUri();\n    error CTPublisher_InsufficientEthSent(uint256 expected, uint256 sent);\n    error CTPublisher_MaxTotalSupplyLessThanMin(uint256 min, uint256 max);\n    error CTPublisher_NotInAllowList(address addr, address[] allowedAddresses);\n    error CTPublisher_PriceTooSmall(uint256 price, uint256 minimumPrice);\n    error CTPublisher_TotalSupplyTooBig(uint256 totalSupply, uint256 maximumTotalSupply);\n    error CTPublisher_TotalSupplyTooSmall(uint256 totalSupply, uint256 minimumTotalSupply);\n    error CTPublisher_UnauthorizedToPostInCategory();\n    error CTPublisher_ZeroTotalSupply();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice The divisor that describes the fee that should be taken.\n    /// @dev This is equal to 100 divided by the fee percent.\n    uint256 public constant override FEE_DIVISOR = 20;\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The controller that directs the projects being posted to.\n    IJBController public immutable override CONTROLLER;\n\n    /// @notice The ID of the project to which fees will be routed.\n    uint256 public immutable override FEE_PROJECT_ID;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The ID of the tier that an IPFS metadata has been saved to.\n    /// @custom:param hook The hook for which the tier ID applies.\n    /// @custom:param encodedIPFSUri The IPFS URI.\n    mapping(address hook => mapping(bytes32 encodedIPFSUri => uint256)) public override tierIdForEncodedIPFSUriOf;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice Stores addresses that are allowed to post onto a hook category.\n    /// @custom:param hook The hook for which this allowance applies.\n    /// @custom:param category The category for which the allowance applies.\n    /// @custom:param address The address to check an allowance for.\n    mapping(address hook => mapping(uint256 category => address[])) internal _allowedAddresses;\n\n    /// @notice Packed values that determine the allowance of posts.\n    /// @custom:param hook The hook for which this allowance applies.\n    /// @custom:param category The category for which the allowance applies\n    mapping(address hook => mapping(uint256 category => uint256)) internal _packedAllowanceFor;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param controller The controller that directs the projects being posted to.\n    /// @param permissions A contract storing permissions.\n    /// @param feeProjectId The ID of the project to which fees will be routed.\n    /// @param trustedForwarder The trusted forwarder for the ERC2771Context.\n    constructor(\n        IJBController controller,\n        IJBPermissions permissions,\n        uint256 feeProjectId,\n        address trustedForwarder\n    )\n        JBPermissioned(permissions)\n        ERC2771Context(trustedForwarder)\n    {\n        CONTROLLER = controller;\n        FEE_PROJECT_ID = feeProjectId;\n    }\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Get the tiers for the provided encoded IPFS URIs.\n    /// @param hook The hook from which to get tiers.\n    /// @param encodedIPFSUris The URIs to get tiers of.\n    /// @return tiers The tiers that correspond to the provided encoded IPFS URIs. If there's no tier yet, an empty tier\n    /// is returned.\n    function tiersFor(\n        address hook,\n        bytes32[] memory encodedIPFSUris\n    )\n        external\n        view\n        override\n        returns (JB721Tier[] memory tiers)\n    {\n        uint256 numberOfEncodedIPFSUris = encodedIPFSUris.length;\n\n        // Initialize the tier array being returned.\n        tiers = new JB721Tier[](numberOfEncodedIPFSUris);\n\n        // Get the tier for each provided encoded IPFS URI.\n        for (uint256 i; i < numberOfEncodedIPFSUris; i++) {\n            // Check if there's a tier ID stored for the encoded IPFS URI.\n            uint256 tierId = tierIdForEncodedIPFSUriOf[hook][encodedIPFSUris[i]];\n\n            // If there's a tier ID stored, resolve it.\n            if (tierId != 0) {\n                // slither-disable-next-line calls-loop\n                tiers[i] = IJB721TiersHook(hook).STORE().tierOf(hook, tierId, false);\n            }\n        }\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Post allowances for a particular category on a particular hook.\n    /// @param hook The hook contract for which this allowance applies.\n    /// @param category The category for which this allowance applies.\n    /// @return minimumPrice The minimum price that a poster must pay to record a new NFT.\n    /// @return minimumTotalSupply The minimum total number of available tokens that a minter must set to record a new\n    /// NFT.\n    /// @return maximumTotalSupply The max total supply of NFTs that can be made available when minting. Leave as 0 for\n    /// max.\n    /// @return allowedAddresses The addresses allowed to post. Returns empty if all addresses are allowed.\n    function allowanceFor(\n        address hook,\n        uint256 category\n    )\n        public\n        view\n        override\n        returns (\n            uint256 minimumPrice,\n            uint256 minimumTotalSupply,\n            uint256 maximumTotalSupply,\n            address[] memory allowedAddresses\n        )\n    {\n        // Get a reference to the packed values.\n        uint256 packed = _packedAllowanceFor[hook][category];\n\n        // minimum price in bits 0-103 (104 bits).\n        minimumPrice = uint256(uint104(packed));\n        // minimum supply in bits 104-135 (32 bits).\n        minimumTotalSupply = uint256(uint32(packed >> 104));\n        // minimum supply in bits 136-67 (32 bits).\n        maximumTotalSupply = uint256(uint32(packed >> 136));\n\n        allowedAddresses = _allowedAddresses[hook][category];\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @dev ERC-2771 specifies the context as being a single address (20 bytes).\n    function _contextSuffixLength() internal view virtual override(ERC2771Context, Context) returns (uint256) {\n        return super._contextSuffixLength();\n    }\n\n    /// @notice Check if an address is included in an allow list.\n    /// @param addrs The candidate address.\n    /// @param addresses An array of allowed addresses.\n    function _isAllowed(address addrs, address[] memory addresses) internal pure returns (bool) {\n        // Keep a reference to the number of address to check against.\n        uint256 numberOfAddresses = addresses.length;\n\n        // Check if the address is included\n        for (uint256 i; i < numberOfAddresses; i++) {\n            if (addrs == addresses[i]) return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Returns the calldata, prefered to use over `msg.data`\n    /// @return calldata the `msg.data` of this call\n    function _msgData() internal view override(ERC2771Context, Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    /// @notice Returns the sender, prefered to use over `msg.sender`\n    /// @return sender the sender address of this call.\n    function _msgSender() internal view override(ERC2771Context, Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Collection owners can set the allowed criteria for publishing a new NFT to their project.\n    /// @param allowedPosts An array of criteria for allowed posts.\n    function configurePostingCriteriaFor(CTAllowedPost[] memory allowedPosts) external override {\n        // Keep a reference to the number of post criteria.\n        uint256 numberOfAllowedPosts = allowedPosts.length;\n\n        // For each post criteria, save the specifications.\n        for (uint256 i; i < numberOfAllowedPosts; i++) {\n            // Set the post criteria being iterated on.\n            CTAllowedPost memory allowedPost = allowedPosts[i];\n\n            emit ConfigurePostingCriteria({hook: allowedPost.hook, allowedPost: allowedPost, caller: _msgSender()});\n\n            // Enforce permissions.\n            // slither-disable-next-line reentrancy-events,calls-loop\n            _requirePermissionFrom({\n                account: JBOwnable(allowedPost.hook).owner(),\n                projectId: IJB721TiersHook(allowedPost.hook).PROJECT_ID(),\n                permissionId: JBPermissionIds.ADJUST_721_TIERS\n            });\n\n            // Make sure there is a minimum supply.\n            if (allowedPost.minimumTotalSupply == 0) {\n                revert CTPublisher_ZeroTotalSupply();\n            }\n\n            // Make sure the minimum supply does not surpass the maximum supply.\n            if (allowedPost.minimumTotalSupply > allowedPost.maximumTotalSupply) {\n                revert CTPublisher_MaxTotalSupplyLessThanMin(\n                    allowedPost.minimumTotalSupply, allowedPost.maximumTotalSupply\n                );\n            }\n\n            uint256 packed;\n            // minimum price in bits 0-103 (104 bits).\n            packed |= uint256(allowedPost.minimumPrice);\n            // minimum total supply in bits 104-135 (32 bits).\n            packed |= uint256(allowedPost.minimumTotalSupply) << 104;\n            // maximum total supply in bits 136-167 (32 bits).\n            packed |= uint256(allowedPost.maximumTotalSupply) << 136;\n            // Store the packed value.\n            _packedAllowanceFor[allowedPost.hook][allowedPost.category] = packed;\n\n            // Store the allow list.\n            uint256 numberOfAddresses = allowedPost.allowedAddresses.length;\n            // Reset the addresses.\n            delete _allowedAddresses[allowedPost.hook][allowedPost.category];\n            // Add the number allowed addresses.\n            if (numberOfAddresses != 0) {\n                // Keep a reference to the storage of the allowed addresses.\n                for (uint256 j = 0; j < numberOfAddresses; j++) {\n                    _allowedAddresses[allowedPost.hook][allowedPost.category].push(allowedPost.allowedAddresses[j]);\n                }\n            }\n        }\n    }\n\n    /// @notice Publish an NFT to become mintable, and mint a first copy.\n    /// @dev A fee is taken into the appropriate treasury.\n    /// @param hook The hook to mint from.\n    /// @param posts An array of posts that should be published as NFTs to the specified project.\n    /// @param nftBeneficiary The beneficiary of the NFT mints.\n    /// @param feeBeneficiary The beneficiary of the fee project's token.\n    /// @param additionalPayMetadata Metadata bytes that should be included in the pay function's metadata. This\n    /// prepends the\n    /// payload needed for NFT creation.\n    /// @param feeMetadata The metadata to send alongside the fee payment.\n    function mintFrom(\n        IJB721TiersHook hook,\n        CTPost[] calldata posts,\n        address nftBeneficiary,\n        address feeBeneficiary,\n        bytes calldata additionalPayMetadata,\n        bytes calldata feeMetadata\n    )\n        external\n        payable\n        override\n    {\n        // Keep a reference to the amount being paid, which is msg.value minus the fee.\n        uint256 payValue = msg.value;\n\n        // Keep a reference to the mint metadata.\n        bytes memory mintMetadata;\n\n        // Keep a reference to the project's ID.\n        uint256 projectId = hook.PROJECT_ID();\n\n        {\n            // Setup the posts.\n            (JB721TierConfig[] memory tiersToAdd, uint256[] memory tierIdsToMint, uint256 totalPrice) =\n                _setupPosts(hook, posts);\n\n            if (projectId != FEE_PROJECT_ID) {\n                // Keep a reference to the fee that will be paid.\n                payValue -= totalPrice / FEE_DIVISOR;\n            }\n\n            // Make sure the amount sent to this function is at least the specified price of the tier plus the fee.\n            if (totalPrice > payValue) {\n                revert CTPublisher_InsufficientEthSent(totalPrice, msg.value);\n            }\n\n            // Add the new tiers.\n            // slither-disable-next-line reentrancy-events\n            hook.adjustTiers(tiersToAdd, new uint256[](0));\n\n            // Keep a reference to the metadata ID target.\n            address metadataIdTarget = hook.METADATA_ID_TARGET();\n\n            // Create the metadata for the payment to specify the tier IDs that should be minted. We create manually the\n            // original metadata, following\n            // the specifications from the JBMetadataResolver library.\n            mintMetadata = JBMetadataResolver.addToMetadata({\n                originalMetadata: additionalPayMetadata,\n                idToAdd: JBMetadataResolver.getId(\"pay\", metadataIdTarget),\n                dataToAdd: abi.encode(true, tierIdsToMint)\n            });\n\n            // Store the referal id in the first 32 bytes of the metadata (push to stack for immutable in assembly)\n            uint256 feeProjectId = FEE_PROJECT_ID;\n\n            assembly {\n                mstore(add(mintMetadata, 32), feeProjectId)\n            }\n        }\n\n        emit Mint({\n            projectId: projectId,\n            hook: hook,\n            nftBeneficiary: nftBeneficiary,\n            feeBeneficiary: feeBeneficiary,\n            posts: posts,\n            postValue: payValue,\n            txValue: msg.value,\n            caller: _msgSender()\n        });\n\n        {\n            // Get a reference to the project's current ETH payment terminal.\n            IJBTerminal projectTerminal = CONTROLLER.DIRECTORY().primaryTerminalOf(projectId, JBConstants.NATIVE_TOKEN);\n\n            // Make the payment.\n            // slither-disable-next-line unused-return\n            projectTerminal.pay{value: payValue}({\n                projectId: projectId,\n                token: JBConstants.NATIVE_TOKEN,\n                amount: payValue,\n                beneficiary: nftBeneficiary,\n                minReturnedTokens: 0,\n                memo: \"Minted from Croptop\",\n                metadata: mintMetadata\n            });\n        }\n\n        // Pay a fee if there are funds left.\n        if (address(this).balance != 0) {\n            // Get a reference to the fee project's current ETH payment terminal.\n            IJBTerminal feeTerminal = CONTROLLER.DIRECTORY().primaryTerminalOf(FEE_PROJECT_ID, JBConstants.NATIVE_TOKEN);\n\n            // Make the fee payment.\n            // slither-disable-next-line unused-return\n            feeTerminal.pay{value: address(this).balance}({\n                projectId: FEE_PROJECT_ID,\n                amount: address(this).balance,\n                token: JBConstants.NATIVE_TOKEN,\n                beneficiary: feeBeneficiary,\n                minReturnedTokens: 0,\n                memo: \"\",\n                metadata: feeMetadata\n            });\n        }\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Setup the posts.\n    /// @param hook The NFT hook on which the posts will apply.\n    /// @param posts An array of posts that should be published as NFTs to the specified project.\n    /// @return tiersToAdd The tiers that will be created to represent the posts.\n    /// @return tierIdsToMint The tier IDs of the posts that should be minted once published.\n    /// @return totalPrice The total price being paid.\n    function _setupPosts(\n        IJB721TiersHook hook,\n        CTPost[] memory posts\n    )\n        internal\n        returns (JB721TierConfig[] memory tiersToAdd, uint256[] memory tierIdsToMint, uint256 totalPrice)\n    {\n        // Set the max size of the tier data that will be added.\n        tiersToAdd = new JB721TierConfig[](posts.length);\n\n        // Set the size of the tier IDs of the posts that should be minted once published.\n        tierIdsToMint = new uint256[](posts.length);\n\n        // The tier ID that will be created, and the first one that should be minted from, is one more than the current\n        // max.\n        uint256 startingTierId = hook.STORE().maxTierIdOf(address(hook)) + 1;\n\n        // Keep a reference to the total number of tiers being added.\n        uint256 numberOfTiersBeingAdded;\n\n        // For each post, create tiers after validating to make sure they fulfill the allowance specified by the\n        // project's owner.\n        for (uint256 i; i < posts.length; i++) {\n            // Get the current post being iterated on.\n            CTPost memory post = posts[i];\n\n            // Make sure the post includes an encodedIPFSUri.\n            if (post.encodedIPFSUri == bytes32(\"\")) {\n                revert CTPublisher_EmptyEncodedIPFSUri();\n            }\n\n            // Scoped section to prevent stack too deep.\n            {\n                // Check if there's an ID of a tier already minted for this encodedIPFSUri.\n                uint256 tierId = tierIdForEncodedIPFSUriOf[address(hook)][post.encodedIPFSUri];\n\n                if (tierId != 0) tierIdsToMint[i] = tierId;\n            }\n\n            // If no tier already exists, post the tier.\n            if (tierIdsToMint[i] == 0) {\n                // Scoped error handling section to prevent Stack Too Deep.\n                {\n                    // Get references to the allowance.\n                    (\n                        uint256 minimumPrice,\n                        uint256 minimumTotalSupply,\n                        uint256 maximumTotalSupply,\n                        address[] memory addresses\n                    ) = allowanceFor(address(hook), post.category);\n\n                    // Make sure the category being posted to allows publishing.\n                    if (minimumTotalSupply == 0) {\n                        revert CTPublisher_UnauthorizedToPostInCategory();\n                    }\n\n                    // Make sure the price being paid for the post is at least the allowed minimum price.\n                    if (post.price < minimumPrice) {\n                        revert CTPublisher_PriceTooSmall(post.price, minimumPrice);\n                    }\n\n                    // Make sure the total supply being made available for the post is at least the allowed minimum\n                    // total supply.\n                    if (post.totalSupply < minimumTotalSupply) {\n                        revert CTPublisher_TotalSupplyTooSmall(post.totalSupply, minimumTotalSupply);\n                    }\n\n                    // Make sure the total supply being made available for the post is at most the allowed maximum total\n                    // supply.\n                    if (post.totalSupply > maximumTotalSupply) {\n                        revert CTPublisher_TotalSupplyTooBig(post.totalSupply, maximumTotalSupply);\n                    }\n\n                    // Make sure the address is allowed to post.\n                    if (addresses.length != 0 && !_isAllowed(_msgSender(), addresses)) {\n                        revert CTPublisher_NotInAllowList(_msgSender(), addresses);\n                    }\n                }\n\n                // Set the tier.\n                tiersToAdd[numberOfTiersBeingAdded] = JB721TierConfig({\n                    price: post.price,\n                    initialSupply: post.totalSupply,\n                    votingUnits: 0,\n                    reserveFrequency: 0,\n                    reserveBeneficiary: address(0),\n                    encodedIPFSUri: post.encodedIPFSUri,\n                    category: post.category,\n                    discountPercent: 0,\n                    allowOwnerMint: false,\n                    useReserveBeneficiaryAsDefault: false,\n                    transfersPausable: false,\n                    useVotingUnits: true,\n                    cannotBeRemoved: false,\n                    cannotIncreaseDiscountPercent: false\n                });\n\n                // Set the ID of the tier to mint.\n                tierIdsToMint[i] = startingTierId + numberOfTiersBeingAdded++;\n\n                // Save the encodedIPFSUri as minted.\n                tierIdForEncodedIPFSUriOf[address(hook)][post.encodedIPFSUri] = tierIdsToMint[i];\n            }\n\n            // Increment the total price.\n            totalPrice += post.price;\n        }\n\n        // Resize the array if there's a mismatch in length.\n        if (numberOfTiersBeingAdded != posts.length) {\n            assembly (\"memory-safe\") {\n                mstore(tiersToAdd, numberOfTiersBeingAdded)\n            }\n        }\n    }\n}\n"
			},
			"node_modules/@croptop/core/src/interfaces/ICTPublisher.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {JB721Tier} from \"@bananapus/721-hook/src/structs/JB721Tier.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\n\nimport {CTAllowedPost} from \"../structs/CTAllowedPost.sol\";\nimport {CTPost} from \"../structs/CTPost.sol\";\n\ninterface ICTPublisher {\n    event ConfigurePostingCriteria(address indexed hook, CTAllowedPost allowedPost, address caller);\n    event Mint(\n        uint256 indexed projectId,\n        IJB721TiersHook indexed hook,\n        address indexed nftBeneficiary,\n        address feeBeneficiary,\n        CTPost[] posts,\n        uint256 postValue,\n        uint256 txValue,\n        address caller\n    );\n\n    function FEE_DIVISOR() external view returns (uint256);\n\n    function CONTROLLER() external view returns (IJBController);\n\n    function FEE_PROJECT_ID() external view returns (uint256);\n\n    function tierIdForEncodedIPFSUriOf(address hook, bytes32 encodedIPFSUri) external view returns (uint256);\n\n    function allowanceFor(\n        address hook,\n        uint256 category\n    )\n        external\n        view\n        returns (\n            uint256 minimumPrice,\n            uint256 minimumTotalSupply,\n            uint256 maximumTotalSupply,\n            address[] memory allowedAddresses\n        );\n\n    function tiersFor(\n        address hook,\n        bytes32[] memory encodedIPFSUris\n    )\n        external\n        view\n        returns (JB721Tier[] memory tiers);\n\n    function configurePostingCriteriaFor(CTAllowedPost[] memory allowedPosts) external;\n\n    function mintFrom(\n        IJB721TiersHook hook,\n        CTPost[] memory posts,\n        address nftBeneficiary,\n        address feeBeneficiary,\n        bytes calldata additionalPayMetadata,\n        bytes calldata feeMetadata\n    )\n        external\n        payable;\n}\n"
			},
			"node_modules/@croptop/core/src/structs/CTAllowedPost.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Criteria for allowed posts.\n/// @custom:member hook The hook to which this allowance applies.\n/// @custom:member category A category that should allow posts.\n/// @custom:member minimumPrice The minimum price that a post to the specified category should cost.\n/// @custom:member minimumTotalSupply The minimum total supply of NFTs that can be made available when minting.\n/// @custom:member maxTotalSupply The max total supply of NFTs that can be made available when minting. Leave as 0 for\n/// max.\n/// @custom:member allowedAddresses A list of addresses that are allowed to post on the category through Croptop.\nstruct CTAllowedPost {\n    address hook;\n    uint24 category;\n    uint104 minimumPrice;\n    uint32 minimumTotalSupply;\n    uint32 maximumTotalSupply;\n    address[] allowedAddresses;\n}\n"
			},
			"node_modules/@croptop/core/src/structs/CTPost.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A post to be published.\n/// @custom:member encodedIPFSUri The encoded IPFS URI of the post that is being published.\n/// @custom:member totalSupply The number of NFTs that should be made available, including the 1 that will be minted\n/// alongside this transaction.\n/// @custom:member price The price being paid for buying the post that is being published.\n/// @custom:member category The category that the post should be published in.\nstruct CTPost {\n    bytes32 encodedIPFSUri;\n    uint32 totalSupply;\n    uint104 price;\n    uint24 category;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n *\n * WARNING: Avoid using this pattern in contracts that rely in a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Receiver} from \"./IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Address.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Strings.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
			},
			"node_modules/@prb/math/src/Common.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// Common.sol\n//\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value a uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value a uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev The unit number, which the decimal precision of the fixed-point types.\nuint256 constant UNIT = 1e18;\n\n/// @dev The unit number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\n/// bit in the binary representation of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // The following logic multiplies the result by $\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\n        //\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\n        // we know that `x & 0xFF` is also 1.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // In the code snippet below, two operations are executed simultaneously:\n        //\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\n        //\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\n        // integer part, $2^n$.\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\n///\n/// @dev See the note on \"msb\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each step in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// The Yul instructions used below are:\n///\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates x*ydenominator with 512-bit precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - The denominator must not be zero.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as a uint256.\n/// @param y The multiplier as a uint256.\n/// @param denominator The divisor as a uint256.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 512 by 256 division\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512-bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    unchecked {\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        uint256 flippedLpotdod;\n\n        assembly (\"memory-safe\") {\n            // Factor powers of two out of denominator.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * flippedLpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates x*y1e18 with 512-bit precision.\n///\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\n///\n/// Notes:\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\n/// - The result is rounded toward zero.\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\n///\n/// $$\n/// \\begin{cases}\n///     x * y = MAX\\_UINT256 * UNIT \\\\\n///     (x * y) \\% UNIT \\geq \\frac{UNIT}{2}\n/// \\end{cases}\n/// $$\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n        result :=\n            mul(\n                or(\n                    div(sub(prod0, remainder), UNIT_LPOTD),\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n                ),\n                UNIT_INVERSE\n            )\n    }\n}\n\n/// @notice Calculates x*ydenominator with 512-bit precision.\n///\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit in int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 xAbs;\n    uint256 yAbs;\n    uint256 dAbs;\n    unchecked {\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of x*ydenominator. The result must fit in int256.\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\n    if (resultAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // \"sgt\" is the \"signed greater than\" assembly instruction and \"sub(0,1)\" is -1 in two's complement.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allowance\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/IEIP712.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/IPermit2.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISignatureTransfer} from \"./ISignatureTransfer.sol\";\nimport {IAllowanceTransfer} from \"./IAllowanceTransfer.sol\";\n\n/// @notice Permit2 handles signature-based transfers in SignatureTransfer and allowance-based transfers in AllowanceTransfer.\n/// @dev Users must approve Permit2 before calling any of the transfer functions.\ninterface IPermit2 is ISignatureTransfer, IAllowanceTransfer {\n// IPermit2 unifies the two interfaces so users have maximal flexibility with their approval.\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/ISignatureTransfer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport {IUniswapV3PoolImmutables} from './pool/IUniswapV3PoolImmutables.sol';\nimport {IUniswapV3PoolState} from './pool/IUniswapV3PoolState.sol';\nimport {IUniswapV3PoolDerivedState} from './pool/IUniswapV3PoolDerivedState.sol';\nimport {IUniswapV3PoolActions} from './pool/IUniswapV3PoolActions.sol';\nimport {IUniswapV3PoolOwnerActions} from './pool/IUniswapV3PoolOwnerActions.sol';\nimport {IUniswapV3PoolErrors} from './pool/IUniswapV3PoolErrors.sol';\nimport {IUniswapV3PoolEvents} from './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolErrors,\n    IUniswapV3PoolEvents\n{\n\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolErrors.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Errors emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolErrors {\n    error LOK();\n    error TLU();\n    error TLM();\n    error TUM();\n    error AI();\n    error M0();\n    error M1();\n    error AS();\n    error IIA();\n    error L();\n    error F0();\n    error F1();\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// @return tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// @return observationIndex The index of the last oracle observation that was written,\n    /// @return observationCardinality The current maximum number of observations stored in the pool,\n    /// @return observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// @return feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    /// @return The liquidity at the current price of the pool\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper\n    /// @return liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// @return feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// @return feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// @return tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// @return secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// @return secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// @return initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return liquidity The amount of liquidity in the position,\n    /// @return feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// @return feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// @return tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// @return tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// @return tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// @return secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// @return initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
			},
			"src/REVLoans.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\nimport {IAllowanceTransfer} from \"@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol\";\nimport {IPermit2} from \"@uniswap/permit2/src/interfaces/IPermit2.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBPayoutTerminal} from \"@bananapus/core/src/interfaces/IJBPayoutTerminal.sol\";\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IJBTerminal} from \"@bananapus/core/src/interfaces/IJBTerminal.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\nimport {JBFees} from \"@bananapus/core/src/libraries/JBFees.sol\";\nimport {JBRedemptions} from \"@bananapus/core/src/libraries/JBRedemptions.sol\";\nimport {JBRulesetMetadataResolver} from \"@bananapus/core/src/libraries/JBRulesetMetadataResolver.sol\";\nimport {JBSurplus} from \"@bananapus/core/src/libraries/JBSurplus.sol\";\nimport {JBAccountingContext} from \"@bananapus/core/src/structs/JBAccountingContext.sol\";\nimport {JBRuleset} from \"@bananapus/core/src/structs/JBRuleset.sol\";\nimport {JBSingleAllowance} from \"@bananapus/core/src/structs/JBSingleAllowance.sol\";\n\nimport {IREVDeployer} from \"./interfaces/IREVDeployer.sol\";\nimport {IREVLoans} from \"./interfaces/IREVLoans.sol\";\nimport {REVLoan} from \"./structs/REVLoan.sol\";\nimport {REVLoanSource} from \"./structs/REVLoanSource.sol\";\n\n/// @notice A contract for borrowing from revnets.\n/// @dev Tokens used as collateral are burned, and reminted when the loan is paid off. This keeps the revnet's token\n/// structure orderly.\n/// @dev The borrowable amount is the same as the cash out amount.\n/// @dev An upfront fee is taken when a loan is created. 2.5% is charged by the underlying protocol, 2.5% is charged\n/// by the\n/// revnet issuing the loan, and a variable amount charged by the revnet that receives the fees. This variable amount is\n/// chosen by the borrower, the more paid upfront, the longer the prepaid duration. The loan can be repaid anytime\n/// within the prepaid duration without additional fees.\n/// After the prepaid duration, the loan will increasingly cost more to pay off. After 10 years, the loan collateral\n/// cannot be\n/// recouped.\n/// @dev The loaned amounts include the fees taken, meaning the amount paid back is the amount borrowed plus the fees.\ncontract REVLoans is ERC721, ERC2771Context, IREVLoans, ReentrancyGuard {\n    // A library that parses the packed ruleset metadata into a friendlier format.\n    using JBRulesetMetadataResolver for JBRuleset;\n\n    // A library that adds default safety checks to ERC20 functionality.\n    using SafeERC20 for IERC20;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error REVLoans_Unauthorized();\n    error REVLoans_AmountNotSpecified();\n    error REVLoans_CollateralExceedsLoan();\n    error REVLoans_InvalidPrepaidFeePercent();\n    error REVLoans_NotEnoughCollateral();\n    error REVLoans_PermitAllowanceNotEnough();\n    error REVLoans_NoMsgValueAllowed();\n    error REVLoans_LoanExpired();\n    error REVLoans_Overpayment();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @dev After the prepaid duration, the loan will cost more to pay off. After 10 years, the loan\n    /// collateral cannot be recouped. This means paying 50% of the loan amount upfront will pay for having access to\n    /// the remaining 50% for 10 years,\n    /// whereas paying 0% of the loan upfront will cost 100% of the loan amount to be paid off after 10 years. After 10\n    /// years with repayment, both loans cost 100% and are liquidated.\n    uint256 public constant override LOAN_LIQUIDATION_DURATION = 3650 days;\n\n    /// @dev The maximum amount of a loan that can be prepaid at the time of borrowing, in terms of JBConstants.MAX_FEE.\n    uint256 public constant override MAX_PREPAID_PERCENT = 500;\n\n    /// @dev A fee of 2.5% is charged by the underlying protocol.\n    uint256 public constant override REV_PREPAID_FEE = 5; // 0.5%\n\n    //*********************************************************************//\n    // -------------------- private constant properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice Just a kind reminder to our readers.\n    /// @dev Used in loan token ID generation.\n    uint256 private constant _ONE_TRILLION = 1_000_000_000_000;\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice The permit2 utility.\n    IPermit2 public immutable override PERMIT2;\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    /// @notice The ID of the REV revnet that will receive the fees.\n    uint256 public immutable override REV_ID;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice An indication if a revnet currently has outstanding loans from the specified terminal in the specified\n    /// token.\n    /// @custom:param revnetId The ID of the revnet issuing the loan.\n    /// @custom:param terminal The terminal that the loan is issued from.\n    /// @custom:param token The token being loaned.\n    mapping(uint256 revnetId => mapping(IJBPayoutTerminal terminal => mapping(address token => bool))) public override\n        isLoanSourceOf;\n\n    /// @notice The ID of the last revnet that has been successfully liquiditated after passing the duration.\n    /// @custom:param The ID of the revnet to get the last liquidated loan ID from.\n    mapping(uint256 revnetId => uint256) public override lastLoanIdLiquidatedFrom;\n\n    /// @notice The amount of loans that have been created.\n    /// @custom:param revnetId The ID of the revnet to get the number of loans from.\n    mapping(uint256 revnetId => uint256) public override numberOfLoansFor;\n\n    /// @notice The total amount loaned out by a revnet from a specified terminal in a specified token.\n    /// @custom:param revnetId The ID of the revnet issuing the loan.\n    /// @custom:param terminal The terminal that the loan is issued from.\n    /// @custom:param token The token being loaned.\n    mapping(uint256 revnetId => mapping(IJBPayoutTerminal terminal => mapping(address token => uint256)))\n        public\n        override totalBorrowedFrom;\n\n    /// @notice The total amount of collateral supporting a revnet's loans.\n    /// @custom:param revnetId The ID of the revnet issuing the loan.\n    mapping(uint256 revnetId => uint256) public override totalCollateralOf;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice The sources of each revnet's loan.\n    /// @custom:member revnetId The ID of the revnet issuing the loan.\n    mapping(uint256 revnetId => REVLoanSource[]) internal _loanSourcesOf;\n\n    /// @notice The loans.\n    /// @custom:member The ID of the loan.\n    mapping(uint256 loanId => REVLoan) internal _loanOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice The amount that can be borrowed from a revnet.\n    /// @param revnetId The ID of the revnet to check for borrowable assets from.\n    /// @param collateral The amount of collateral used to secure the loan.\n    /// @param decimals The decimals the resulting fixed point value will include.\n    /// @param currency The currency that the resulting amount should be in terms of.\n    /// @return borrowableAmount The amount that can be borrowed from the revnet.\n    function borrowableAmountFrom(\n        uint256 revnetId,\n        uint256 collateral,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256)\n    {\n        // Keep a reference to the revnet's owner.\n        IREVDeployer revnetOwner = IREVDeployer(PROJECTS.ownerOf(revnetId));\n\n        // Keep a reference to the revnet's controller.\n        IJBController controller = revnetOwner.CONTROLLER();\n\n        return _borrowableAmountFrom({\n            revnetId: revnetId,\n            collateral: collateral,\n            pendingAutomintTokens: revnetOwner.unrealizedAutoMintAmountOf(revnetId),\n            decimals: decimals,\n            currency: currency,\n            currentStage: controller.RULESETS().currentOf(revnetId),\n            terminals: controller.DIRECTORY().terminalsOf(revnetId),\n            prices: controller.PRICES(),\n            tokens: controller.TOKENS()\n        });\n    }\n\n    /// @notice Get a loan.\n    /// @custom:member The ID of the loan.\n    function loanOf(uint256 loanId) external view override returns (REVLoan memory) {\n        return _loanOf[loanId];\n    }\n\n    /// @notice The sources of each revnet's loan.\n    /// @custom:member revnetId The ID of the revnet issuing the loan.\n    function loanSourcesOf(uint256 revnetId) external view override returns (REVLoanSource[] memory) {\n        return _loanSourcesOf[revnetId];\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Determines the source fee amount for a loan being paid off a certain amount.\n    /// @param loan The loan having its source fee amount determined.\n    /// @param amount The amount being paid off.\n    /// @return sourceFeeAmount The source fee amount for the loan.\n    function determineSourceFeeAmount(REVLoan memory loan, uint256 amount) public view returns (uint256) {\n        return _determineSourceFeeAmount(loan, amount);\n    }\n\n    /// @notice The revnet ID for the loan with the provided loan ID.\n    /// @param loanId The loan ID of the loan to get the revent ID of.\n    /// @return The ID of the revnet.\n    function revnetIdOfLoanWith(uint256 loanId) public pure override returns (uint256) {\n        return loanId / _ONE_TRILLION;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Checks this contract's balance of a specific token.\n    /// @param token The address of the token to get this contract's balance of.\n    /// @return This contract's balance.\n    function _balanceOf(address token) internal view returns (uint256) {\n        // If the `token` is native, get the native token balance.\n        return token == JBConstants.NATIVE_TOKEN ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    /// @dev The amount that can be borrowed from a revnet given a certain amount of collateral.\n    /// @param revnetId The ID of the revnet to check for borrowable assets from.\n    /// @param collateral The amount of collateral that the loan will be collateralized with.\n    /// @param currentStage The current stage of the revnet.\n    /// @param pendingAutomintTokens The amount of tokens pending automint from the revnet.\n    /// @param decimals The decimals the resulting fixed point value will include.\n    /// @param currency The currency that the resulting amount should be in terms of.\n    /// @param terminals The terminals that the funds are being borrowed from.\n    /// @param prices A contract that stores prices for each project.\n    /// @return borrowableAmount The amount that can be borrowed from the revnet.\n    function _borrowableAmountFrom(\n        uint256 revnetId,\n        uint256 collateral,\n        uint256 pendingAutomintTokens,\n        uint256 decimals,\n        uint256 currency,\n        JBRuleset memory currentStage,\n        IJBTerminal[] memory terminals,\n        IJBPrices prices,\n        IJBTokens tokens\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        // Get the surplus of all the revnet's terminals in terms of the native currency.\n        uint256 totalSurplus = JBSurplus.currentSurplusOf({\n            projectId: revnetId,\n            terminals: terminals,\n            decimals: decimals,\n            currency: currency\n        });\n\n        // Get the total amount the revnet currently has loaned out, in terms of the native currency with 18\n        // decimals.\n        uint256 totalBorrowed =\n            _totalBorrowedFrom({revnetId: revnetId, decimals: decimals, currency: currency, prices: prices});\n\n        // Get the total amount of tokens in circulation.\n        uint256 totalSupply = tokens.totalSupplyOf(revnetId);\n\n        // Get a refeerence to the collateral being used to secure loans.\n        uint256 totalCollateral = totalCollateralOf[revnetId];\n\n        // Proportional.\n        return JBRedemptions.reclaimFrom({\n            surplus: totalSurplus + totalBorrowed,\n            tokensRedeemed: collateral,\n            totalSupply: totalSupply + totalCollateral + pendingAutomintTokens,\n            redemptionRate: currentStage.redemptionRate()\n        });\n    }\n\n    /// @dev `ERC-2771` specifies the context as being a single address (20 bytes).\n    function _contextSuffixLength() internal view override(ERC2771Context, Context) returns (uint256) {\n        return super._contextSuffixLength();\n    }\n\n    /// @notice Determines the source fee amount for a loan being paid off a certain amount.\n    /// @param loan The loan having its source fee amount determined.\n    /// @param amount The amount being paid off.\n    /// @return sourceFeeAmount The source fee amount for the loan.\n    function _determineSourceFeeAmount(\n        REVLoan memory loan,\n        uint256 amount\n    )\n        internal\n        view\n        returns (uint256 sourceFeeAmount)\n    {\n        // Keep a reference to the time since the loan was created.\n        uint256 timeSinceLoanCreated = block.timestamp - loan.createdAt;\n\n        // If the loan period has passed the prepaid time frame, take a fee.\n        if (timeSinceLoanCreated > loan.prepaidDuration) {\n            // If the loan period has passed the liqidation time frame, do not allow loan management.\n            if (timeSinceLoanCreated > LOAN_LIQUIDATION_DURATION) revert REVLoans_LoanExpired();\n\n            // Get a reference to the amount prepaid for the full loan.\n            uint256 prepaid = JBFees.feeAmountFrom({amount: loan.amount, feePercent: loan.prepaidFeePercent});\n\n            uint256 fullSourceFeeAmount = JBFees.feeAmountFrom({\n                amount: loan.amount - prepaid,\n                feePercent: mulDiv(timeSinceLoanCreated, JBConstants.MAX_FEE, LOAN_LIQUIDATION_DURATION)\n            });\n\n            // Get a reference to the amount that would have to be paid down to make the loan fully paid.\n            uint256 amountInFull = loan.amount + fullSourceFeeAmount;\n\n            // Calculate the source fee amount for the amount being paid off.\n            sourceFeeAmount = mulDiv(fullSourceFeeAmount, amount, amountInFull);\n        }\n    }\n\n    /// @notice Generate a ID for a loan given a revnet ID and a loan number within that revnet.\n    /// @param revnetId The ID of the revnet to generate a loan ID for.\n    /// @param loanNumber The loan number of the loan within the revnet.\n    /// @return The token ID of the 721.\n    function _generateLoanId(uint256 revnetId, uint256 loanNumber) internal pure returns (uint256) {\n        return (revnetId * _ONE_TRILLION) + loanNumber;\n    }\n\n    /// @notice The calldata. Preferred to use over `msg.data`.\n    /// @return calldata The `msg.data` of this call.\n    function _msgData() internal view override(ERC2771Context, Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    /// @notice The message's sender. Preferred to use over `msg.sender`.\n    /// @return sender The address which sent this call.\n    function _msgSender() internal view override(ERC2771Context, Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param projects A contract which mints ERC-721s that represent project ownership and transfers.\n    /// @param revId The ID of the REV revnet that will receive the fees.\n    /// @param permit2 A permit2 utility.\n    /// @param trustedForwarder A trusted forwarder of transactions to this contract.\n    constructor(\n        IJBProjects projects,\n        uint256 revId,\n        IPermit2 permit2,\n        address trustedForwarder\n    )\n        ERC721(\"REV Loans\", \"$REVLOAN\")\n        ERC2771Context(trustedForwarder)\n    {\n        PROJECTS = projects;\n        REV_ID = revId;\n        PERMIT2 = permit2;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Open a loan by borrowing from a revnet.\n    /// @param revnetId The ID of the revnet being borrowed from.\n    /// @param source The source of the loan being borrowed.\n    /// @param amount The amount being borrowed.\n    /// @param collateral The amount of tokens to use as collateral for the loan.\n    /// @param beneficiary The address that'll receive the borrowed funds and the tokens resulting from fee payments.\n    /// @param prepaidFeePercent The fee percent that will be charged upfront from the revnet being borrowed from.\n    /// Prepaying a fee is cheaper than paying later.\n    /// @return loanId The ID of the loan created from borrowing.\n    /// @return loan The loan created from borrowing.\n    function borrowFrom(\n        uint256 revnetId,\n        REVLoanSource calldata source,\n        uint256 amount,\n        uint256 collateral,\n        address payable beneficiary,\n        uint256 prepaidFeePercent\n    )\n        public\n        override\n        nonReentrant\n        returns (uint256 loanId, REVLoan memory)\n    {\n        // Make sure there is an amount being borrowed.\n        if (amount == 0) revert REVLoans_AmountNotSpecified();\n\n        // Make sure the prepaid fee percent is between 0 and 20%. Meaning an 16 year loan can be paid upfront with a\n        // payment of 50% of the borrowed assets, the cheapest possible rate.\n        if (prepaidFeePercent > MAX_PREPAID_PERCENT) revert REVLoans_InvalidPrepaidFeePercent();\n\n        // Get a reference to the loan ID.\n        loanId = _generateLoanId(revnetId, ++numberOfLoansFor[revnetId]);\n\n        // Mint the loan.\n        _mint({to: _msgSender(), tokenId: loanId});\n\n        // Get a reference to the loan being created.\n        REVLoan storage loan = _loanOf[loanId];\n\n        // Set the loan's values.\n        loan.source = source;\n        loan.createdAt = uint40(block.timestamp);\n        loan.prepaidFeePercent = uint16(prepaidFeePercent);\n        loan.prepaidDuration = uint32(mulDiv(prepaidFeePercent, LOAN_LIQUIDATION_DURATION, MAX_PREPAID_PERCENT));\n\n        // Get the amount of additional fee to take for the revnet issuing the loan.\n        uint256 sourceFeeAmount = JBFees.feeAmountFrom({amount: amount, feePercent: prepaidFeePercent});\n\n        // Borrow the amount.\n        _adjust({\n            loan: loan,\n            revnetId: revnetId,\n            newAmount: amount,\n            newCollateral: collateral,\n            sourceFeeAmount: sourceFeeAmount,\n            beneficiary: beneficiary\n        });\n\n        emit Borrow(loanId, revnetId, loan, source, amount, collateral, beneficiary, _msgSender());\n\n        return (loanId, loan);\n    }\n\n    /// @notice Cleans up any liquiditated loans.\n    /// @dev Since loans are created in incremental order, earlier IDs will always be liquidated before later ones.\n    /// @param revnetId The ID of the revnet to liquidate loans from.\n    /// @param count The amount of loans iterate over since the last liquidated loan.\n    function liquidateExpiredLoansFrom(uint256 revnetId, uint256 count) external override nonReentrant {\n        // Keep a reference to the loan ID being iterated on.\n        uint256 lastLoanIdLiquidated = lastLoanIdLiquidatedFrom[revnetId];\n\n        // Keep a reference to the latest liquidated loan ID.\n        uint256 newLastLoanIdLiquidated;\n\n        // Keep a reference to the revnet's owner.\n        IREVDeployer revnetOwner = IREVDeployer(PROJECTS.ownerOf(revnetId));\n\n        // Keep a reference to the revnet's controller.\n        IJBController controller = revnetOwner.CONTROLLER();\n\n        // Iterate over the desired number of loans to check for liquidation.\n        for (uint256 i; i < count; i++) {\n            // Get a reference to the next loan ID.\n            uint256 loanId = lastLoanIdLiquidated + i;\n\n            // Get a reference to the loan being iterated on.\n            REVLoan memory loan = _loanOf[loanId];\n\n            // Get a reference to the next loan.\n            loan = _loanOf[loanId];\n\n            // If the loan doesn't exist, there's nothing left to liquidate.\n            // slither-disable-next-line incorrect-equality\n            if (loan.createdAt == 0) {\n                break;\n            }\n\n            // Keep a reference to the loan's owner.\n            address owner = ownerOf(loanId);\n\n            // If the loan is already burned, continue.\n            if (owner == address(0)) {\n                newLastLoanIdLiquidated = loanId;\n                continue;\n            }\n\n            // If the loan has not yet passed its liquidation timeframe, no subsequent loans have either.\n            if (block.timestamp <= loan.createdAt + LOAN_LIQUIDATION_DURATION) {\n                break;\n            }\n\n            // If the loan has been paid back and there is still leftover collateral, return it to the owner.\n            // slither-disable-next-line incorrect-equality\n            if (loan.amount == 0 && loan.collateral > 0) {\n                // Return the collateral to the owner.\n                _returnCollateralFrom({\n                    revnetId: revnetId,\n                    amount: loan.collateral,\n                    beneficiary: payable(owner),\n                    controller: controller\n                });\n            }\n\n            // Decrement the amount loaned.\n            totalBorrowedFrom[revnetId][loan.source.terminal][loan.source.token] -= loan.amount;\n\n            // Decrement the total amount of collateral tokens supporting loans from this revnet.\n            totalCollateralOf[revnetId] -= loan.collateral;\n\n            // Burn the loan.\n            _burn(loanId);\n\n            // Increment the number of loans liquidated.\n            newLastLoanIdLiquidated = loanId;\n\n            emit Liquidate(loanId, revnetId, loan, _msgSender());\n        }\n\n        // Store the latest liquidated loan.\n        if (lastLoanIdLiquidated != newLastLoanIdLiquidated) {\n            lastLoanIdLiquidatedFrom[revnetId] = newLastLoanIdLiquidated;\n        }\n    }\n\n    /// @notice Refinances a loan by transferring extra collateral from an existing loan to a new loan.\n    /// @dev Useful if a loan's collateral has gone up in value since the loan was created.\n    /// @dev Refinancing a loan will burn the original and create two new loans.\n    /// @param loanId The ID of the loan to reallocate collateral from.\n    /// @param collateralToTransfer The amount of collateral to transfer from the original loan.\n    /// @param source The source of the loan to create.\n    /// @param amount The amount being borrowed.\n    /// @param collateralToAdd The amount of collateral to add to the loan.\n    /// @param beneficiary The address that'll receive the borrowed funds and the tokens resulting from fee payments.\n    /// @param prepaidFeePercent The fee percent that will be charged upfront from the revnet being borrowed from.\n    /// @return reallocatedLoanId The ID of the loan being reallocated.\n    /// @return newLoanId The ID of the new loan.\n    /// @return reallocatedLoan The loan being reallocated.\n    /// @return newLoan The new loan created from reallocating collateral.\n    function reallocateCollateralFromLoan(\n        uint256 loanId,\n        uint256 collateralToTransfer,\n        REVLoanSource calldata source,\n        uint256 amount,\n        uint256 collateralToAdd,\n        address payable beneficiary,\n        uint256 prepaidFeePercent\n    )\n        external\n        payable\n        override\n        returns (uint256 reallocatedLoanId, uint256 newLoanId, REVLoan memory reallocatedLoan, REVLoan memory newLoan)\n    {\n        // Make sure only the loan's owner can manage it.\n        if (_ownerOf(loanId) != _msgSender()) revert REVLoans_Unauthorized();\n\n        // Make sure there is an amount being borrowed.\n        if (amount == 0) revert REVLoans_AmountNotSpecified();\n\n        // Refinance the loan.\n        (reallocatedLoanId, reallocatedLoan) = _reallocateCollateralFromLoan({\n            loanId: loanId,\n            revnetId: revnetIdOfLoanWith(loanId),\n            collateralToRemove: collateralToTransfer\n        });\n\n        // Make a new loan with the leftover collateral from reallocating.\n        (newLoanId, newLoan) = borrowFrom({\n            revnetId: revnetIdOfLoanWith(reallocatedLoanId),\n            source: source,\n            amount: amount,\n            collateral: collateralToTransfer + collateralToAdd,\n            beneficiary: beneficiary,\n            prepaidFeePercent: prepaidFeePercent\n        });\n    }\n\n    /// @notice Allows the owner of a loan to pay it back or receive returned collateral no longer necessary to support\n    /// the loan.\n    /// @param loanId The ID of the loan being adjusted.\n    /// @param amount The amount being paid off.\n    /// @param collateralToReturn The amount of collateral to return being returned from the loan.\n    /// @param beneficiary The address receiving the returned collateral and any tokens resulting from paying fees.\n    /// @param allowance An allowance to faciliate permit2 interactions.\n    /// @return paidOffLoanId The ID of the loan after it's been paid off.\n    /// @return paidOffloan The loan after it's been paid off.\n    function repayLoan(\n        uint256 loanId,\n        uint256 amount,\n        uint256 collateralToReturn,\n        address payable beneficiary,\n        JBSingleAllowance calldata allowance\n    )\n        external\n        payable\n        override\n        nonReentrant\n        returns (uint256, REVLoan memory)\n    {\n        // Make sure only the loan's owner can manage it.\n        if (_ownerOf(loanId) != _msgSender()) revert REVLoans_Unauthorized();\n\n        // Keep a reference to the fee being iterated on.\n        REVLoan storage loan = _loanOf[loanId];\n\n        if (collateralToReturn > loan.collateral) revert REVLoans_CollateralExceedsLoan();\n\n        // Accept the funds that'll be used to pay off loans.\n        amount = _acceptFundsFor({token: loan.source.token, amount: amount, allowance: allowance});\n\n        return _repayLoan(loanId, loan, amount, collateralToReturn, beneficiary);\n    }\n\n    //*********************************************************************//\n    // --------------------- internal transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Adds collateral to a loan.\n    /// @param revnetId The ID of the revnet the loan is being added in.\n    /// @param amount The new amount of collateral being added to the loan.\n    /// @param controller The controller of the revnet.\n    function _addCollateralTo(uint256 revnetId, uint256 amount, IJBController controller) internal {\n        // Increment the total amount of collateral tokens.\n        totalCollateralOf[revnetId] += amount;\n\n        // Burn the tokens that are tracked as collateral.\n        controller.burnTokensOf({\n            holder: _msgSender(),\n            projectId: revnetId,\n            tokenCount: amount,\n            memo: \"Adding collateral to loan\"\n        });\n    }\n\n    /// @notice Add a new amount to the loan that is greater than the previous amount.\n    /// @param loan The loan being added to.\n    /// @param revnetId The ID of the revnet the loan is being added in.\n    /// @param amount The amount being added to the loan.\n    /// @param sourceFeeAmount The amount of the fee being taken from the revnet acting as the source of the loan.\n    /// @param feeTerminal The terminal that the fee will be paid to.\n    /// @param beneficiary The address receiving the returned collateral and any tokens resulting from paying fees.\n    function _addTo(\n        REVLoan memory loan,\n        uint256 revnetId,\n        uint256 amount,\n        uint256 sourceFeeAmount,\n        IJBTerminal feeTerminal,\n        address payable beneficiary\n    )\n        internal\n    {\n        // Register the source if this is the first time its being used for this revnet.\n        if (!isLoanSourceOf[revnetId][loan.source.terminal][loan.source.token]) {\n            isLoanSourceOf[revnetId][loan.source.terminal][loan.source.token] = true;\n            _loanSourcesOf[revnetId].push(REVLoanSource({token: loan.source.token, terminal: loan.source.terminal}));\n        }\n\n        // Increment the amount of the token borrowed from the revnet from the terminal.\n        totalBorrowedFrom[revnetId][loan.source.terminal][loan.source.token] += amount;\n\n        {\n            // Get a reference to the accounting context for the source.\n            JBAccountingContext memory accountingContext =\n                loan.source.terminal.accountingContextForTokenOf({projectId: revnetId, token: loan.source.token});\n\n            // Pull the amount to be loaned out of the revnet. This will incure the protocol fee.\n            // slither-disable-next-line unused-return\n            loan.source.terminal.useAllowanceOf({\n                projectId: revnetId,\n                token: loan.source.token,\n                amount: amount, //totalLoanAmount,\n                currency: accountingContext.currency,\n                minTokensPaidOut: 0, //totalLoanAmount,\n                beneficiary: payable(address(this)),\n                feeBeneficiary: beneficiary,\n                memo: \"Lending out to a borrower\"\n            });\n        }\n\n        // Get the amount of additional fee to take for REV.\n        uint256 revFeeAmount = JBFees.feeAmountFrom({amount: amount, feePercent: REV_PREPAID_FEE});\n\n        // The amount to pay as a fee.\n        uint256 payValue = loan.source.token == JBConstants.NATIVE_TOKEN ? revFeeAmount : 0;\n\n        // Pay the fee. Send the REV to the msg.sender.\n        // slither-disable-next-line arbitrary-send-eth,unused-return\n        try feeTerminal.pay{value: payValue}({\n            projectId: REV_ID,\n            token: loan.source.token,\n            amount: revFeeAmount,\n            beneficiary: beneficiary,\n            minReturnedTokens: 0,\n            memo: \"Fee from loan\",\n            metadata: bytes(abi.encodePacked(revnetId))\n        }) {} catch (bytes memory) {}\n\n        // Transfer the remaining balance to the borrower.\n        _transferFrom({\n            from: address(this),\n            to: beneficiary,\n            token: loan.source.token,\n            amount: _balanceOf(loan.source.token) - sourceFeeAmount\n        });\n    }\n\n    /// @notice Allows the owner of a loan to pay it back, add more, or receive returned collateral no longer necessary\n    /// to support the loan.\n    /// @param loan The loan being adjusted.\n    /// @param revnetId The ID of the revnet the loan is being adjusted in.\n    /// @param newAmount The new amount of the loan.\n    /// @param newCollateral The new amount of collateral backing the loan.\n    /// @param sourceFeeAmount The amount of the fee being taken from the revnet acting as the source of the loan.\n    /// @param beneficiary The address receiving the returned collateral and any tokens resulting from paying fees.\n    function _adjust(\n        REVLoan storage loan,\n        uint256 revnetId,\n        uint256 newAmount,\n        uint256 newCollateral,\n        uint256 sourceFeeAmount,\n        address payable beneficiary\n    )\n        internal\n    {\n        // Keep a reference to the revnet's owner.\n        IREVDeployer revnetOwner = IREVDeployer(PROJECTS.ownerOf(revnetId));\n\n        // Keep a reference to the revnet's controller.\n        IJBController controller = revnetOwner.CONTROLLER();\n\n        // Keep a reference to the revnet's directory.\n        IJBDirectory directory = controller.DIRECTORY();\n\n        {\n            // Get a reference to the accounting context for the source.\n            JBAccountingContext memory accountingContext =\n                loan.source.terminal.accountingContextForTokenOf({projectId: revnetId, token: loan.source.token});\n\n            // Keep a reference to the pending automint tokens.\n            uint256 pendingAutomintTokens = revnetOwner.unrealizedAutoMintAmountOf(revnetId);\n\n            // Keep a reference to the current stage.\n            JBRuleset memory currentStage = controller.RULESETS().currentOf(revnetId);\n\n            // Keep a reference to the revnet's terminals.\n            IJBTerminal[] memory terminals = directory.terminalsOf(revnetId);\n\n            // If the borrowed amount is increasing or the collateral is changing, check that the loan will still be\n            // properly collateralized.\n            if (\n                (newAmount > loan.amount || loan.collateral != newCollateral)\n                    && _borrowableAmountFrom({\n                        revnetId: revnetId,\n                        collateral: newCollateral,\n                        pendingAutomintTokens: pendingAutomintTokens,\n                        decimals: accountingContext.decimals,\n                        currency: accountingContext.currency,\n                        currentStage: currentStage,\n                        terminals: terminals,\n                        prices: controller.PRICES(),\n                        tokens: controller.TOKENS()\n                    }) < newAmount\n            ) revert REVLoans_NotEnoughCollateral();\n        }\n\n        // Add to the loan if needed...\n        if (newAmount > loan.amount) {\n            // Keep a reference to the fee terminal.\n            IJBTerminal feeTerminal = directory.primaryTerminalOf(REV_ID, loan.source.token);\n\n            // Add the new amount to the loan.\n            _addTo({\n                loan: loan,\n                revnetId: revnetId,\n                amount: newAmount - loan.amount,\n                sourceFeeAmount: sourceFeeAmount,\n                feeTerminal: feeTerminal,\n                beneficiary: beneficiary\n            });\n            // ... or pay off the loan if needed.\n        } else if (loan.amount > newAmount) {\n            _removeFrom({\n                loan: loan,\n                revnetId: revnetId,\n                amount: loan.amount - newAmount,\n                sourceFeeAmount: sourceFeeAmount\n            });\n        }\n\n        // Add collateral if needed...\n        if (newCollateral > loan.collateral) {\n            _addCollateralTo({revnetId: revnetId, amount: newCollateral - loan.collateral, controller: controller});\n            // ... or return collateral if needed.\n        } else if (loan.collateral > newCollateral) {\n            _returnCollateralFrom({\n                revnetId: revnetId,\n                amount: loan.collateral - newCollateral,\n                beneficiary: beneficiary,\n                controller: controller\n            });\n        }\n\n        // Get a reference to the amount remaining in this contract.\n        uint256 balance = _balanceOf(loan.source.token);\n\n        // The amount remaining in the contract should be the source fee.\n        if (balance > 0) {\n            // The amount to pay as a fee.\n            uint256 payValue = loan.source.token == JBConstants.NATIVE_TOKEN ? balance : 0;\n\n            // Pay the fee.\n            // slither-disable-next-line unused-return\n            try loan.source.terminal.pay{value: payValue}({\n                projectId: revnetId,\n                token: loan.source.token,\n                amount: balance,\n                beneficiary: beneficiary,\n                minReturnedTokens: 0,\n                memo: \"Fee from loan\",\n                metadata: bytes(abi.encodePacked(REV_ID))\n            }) {} catch (bytes memory) {}\n        }\n\n        // Store the loans updated values.\n        loan.amount = uint112(newAmount);\n        loan.collateral = uint112(newCollateral);\n    }\n\n    /// @notice Accepts an incoming token.\n    /// @param token The token being accepted.\n    /// @param amount The number of tokens being accepted.\n    /// @param allowance The permit2 context.\n    /// @return amount The number of tokens which have been accepted.\n    function _acceptFundsFor(\n        address token,\n        uint256 amount,\n        JBSingleAllowance memory allowance\n    )\n        internal\n        returns (uint256)\n    {\n        // If the token is the native token, override `amount` with `msg.value`.\n        if (token == JBConstants.NATIVE_TOKEN) return msg.value;\n\n        // If the token is not native, revert if there is a non-zero `msg.value`.\n        if (msg.value != 0) revert REVLoans_NoMsgValueAllowed();\n\n        // Check if the metadata contains permit data.\n        if (allowance.amount != 0) {\n            // Make sure the permit allowance is enough for this payment. If not we revert early.\n            if (allowance.amount < amount) {\n                revert REVLoans_PermitAllowanceNotEnough();\n            }\n\n            // Keep a reference to the permit rules.\n            IAllowanceTransfer.PermitSingle memory permitSingle = IAllowanceTransfer.PermitSingle({\n                details: IAllowanceTransfer.PermitDetails({\n                    token: token,\n                    amount: allowance.amount,\n                    expiration: allowance.expiration,\n                    nonce: allowance.nonce\n                }),\n                spender: address(this),\n                sigDeadline: allowance.sigDeadline\n            });\n\n            // Set the allowance to `spend` tokens for the user.\n            try PERMIT2.permit({owner: _msgSender(), permitSingle: permitSingle, signature: allowance.signature}) {}\n                catch (bytes memory) {}\n        }\n\n        // Get a reference to the balance before receiving tokens.\n        uint256 balanceBefore = _balanceOf(token);\n\n        // Transfer tokens to this terminal from the msg sender.\n        _transferFrom({from: _msgSender(), to: payable(address(this)), token: token, amount: amount});\n\n        // The amount should reflect the change in balance.\n        return _balanceOf(token) - balanceBefore;\n    }\n\n    /// @notice Pays down a loan.\n    /// @param loanId The ID of the loan being paid down.\n    /// @param loan The loan being paid down.\n    /// @param amount The amount being paid down from the loan.\n    /// @param collateralToReturn The amount of collateral being returned that the loan no longer requires.\n    /// @param beneficiary The address receiving the returned collateral and any tokens resulting from paying fees.\n    function _repayLoan(\n        uint256 loanId,\n        REVLoan storage loan,\n        uint256 amount,\n        uint256 collateralToReturn,\n        address payable beneficiary\n    )\n        internal\n        returns (uint256, REVLoan memory)\n    {\n        // Keep a reference to the fee that'll be taken.\n        uint256 sourceFeeAmount = _determineSourceFeeAmount(loan, amount);\n\n        // If the amount being paid is greater than the loan's amount, return extra to the payer.\n        // amount is msg.value if token == JBConstants.NATIVE_TOKEN\n        if (amount > loan.amount + sourceFeeAmount) {\n            _transferFrom({\n                from: address(this),\n                to: payable(_msgSender()),\n                token: loan.source.token,\n                amount: amount - sourceFeeAmount - loan.amount\n            });\n\n            // Set the amount as the amount that can be paid off.\n            amount = sourceFeeAmount + loan.amount;\n        }\n\n        // Burn the original loan.\n        _burn(loanId);\n\n        // Get a reference to the revnet ID.\n        uint256 revnetId = revnetIdOfLoanWith(loanId);\n\n        // If the loan will carry no more amount or collateral, store its changes directly.\n        // slither-disable-next-line incorrect-equality\n        if (amount - sourceFeeAmount == loan.amount && collateralToReturn == loan.collateral) {\n            // Borrow in.\n            _adjust({\n                loan: loan,\n                revnetId: revnetId,\n                newAmount: 0,\n                newCollateral: 0,\n                sourceFeeAmount: sourceFeeAmount,\n                beneficiary: beneficiary\n            });\n\n            emit RepayLoan(\n                loanId,\n                revnetId,\n                loanId,\n                loan,\n                loan,\n                amount,\n                sourceFeeAmount,\n                collateralToReturn,\n                beneficiary,\n                _msgSender()\n            );\n\n            return (loanId, loan);\n        } else {\n            // Make a new loan with the remaining amount and collateral.\n            // Get a reference to the replacement loan ID.\n            uint256 paidOffLoanId = _generateLoanId(revnetId, ++numberOfLoansFor[revnetId]);\n\n            // Mint the replacement loan.\n            _mint({to: _msgSender(), tokenId: paidOffLoanId});\n\n            // Get a reference to the loan being paid off.\n            REVLoan storage paidOffLoan = _loanOf[paidOffLoanId];\n\n            // Set the paid off loan's values the same as the original loan.\n            paidOffLoan = loan;\n\n            // Borrow in.\n            _adjust({\n                loan: paidOffLoan,\n                revnetId: revnetId,\n                newAmount: paidOffLoan.amount - (amount - sourceFeeAmount),\n                newCollateral: paidOffLoan.collateral - collateralToReturn,\n                sourceFeeAmount: sourceFeeAmount,\n                beneficiary: beneficiary\n            });\n\n            emit RepayLoan(\n                loanId,\n                revnetId,\n                paidOffLoanId,\n                loan,\n                paidOffLoan,\n                amount,\n                sourceFeeAmount,\n                collateralToReturn,\n                beneficiary,\n                _msgSender()\n            );\n\n            return (paidOffLoanId, paidOffLoan);\n        }\n    }\n\n    /// @notice Reallocates collateral from a loan by making a new loan based on the original, with reduced collateral.\n    /// @param loanId The ID of the loan to reallocate collateral from.\n    /// @param revnetId The ID of the revnet the loan is from.\n    /// @param collateralToRemove The amount of collateral to remove from the loan.\n    /// @return reallocatedLoanId The ID of the loan.\n    /// @return reallocatedLoan The reallocated loan.\n    function _reallocateCollateralFromLoan(\n        uint256 loanId,\n        uint256 revnetId,\n        uint256 collateralToRemove\n    )\n        internal\n        returns (uint256 reallocatedLoanId, REVLoan storage reallocatedLoan)\n    {\n        // Burn the original loan.\n        _burn(loanId);\n\n        // Keep a reference to loan having its collateral reduced.\n        REVLoan storage loan = _loanOf[loanId];\n\n        // Make sure there is enough collateral to transfer.\n        if (collateralToRemove > loan.collateral) revert REVLoans_NotEnoughCollateral();\n\n        // Get a reference to the replacement loan ID.\n        reallocatedLoanId = _generateLoanId(revnetId, ++numberOfLoansFor[revnetId]);\n\n        // Mint the replacement loan.\n        _mint({to: _msgSender(), tokenId: reallocatedLoanId});\n\n        // Get a reference to the loan being created.\n        reallocatedLoan = _loanOf[reallocatedLoanId];\n\n        // Set the reallocated loan's values the same as the original loan.\n        reallocatedLoan = loan;\n\n        // Reduce the collateral of the replacement loan.\n        _adjust({\n            loan: reallocatedLoan,\n            revnetId: revnetId,\n            newAmount: reallocatedLoan.amount,\n            newCollateral: reallocatedLoan.collateral - collateralToRemove,\n            sourceFeeAmount: 0,\n            beneficiary: payable(_msgSender()) // use the msgSender as the beneficiary, who will have the returned\n                // collateral tokens debited from\n                // their balance for the new loan.\n        });\n\n        emit ReallocateCollateral(\n            loanId, revnetId, reallocatedLoanId, reallocatedLoan, collateralToRemove, _msgSender()\n        );\n    }\n\n    /// @notice Pays off a loan.\n    /// @param loan The loan being paid off.\n    /// @param revnetId The ID of the revnet the loan is being paid off in.\n    /// @param amount The amount being paid off.\n    /// @param sourceFeeAmount The amount of the fee being taken from the revnet acting as the source of the loan.\n    function _removeFrom(REVLoan memory loan, uint256 revnetId, uint256 amount, uint256 sourceFeeAmount) internal {\n        // Decrement the total amount of a token being loaned out by the revnet from its terminal.\n        totalBorrowedFrom[revnetId][loan.source.terminal][loan.source.token] -= amount;\n\n        // The borrowed amount to return to the revnet.\n        uint256 payValue = loan.source.token == JBConstants.NATIVE_TOKEN ? amount : 0;\n\n        // Add the loaned amount back to the revnet.\n        try loan.source.terminal.addToBalanceOf{value: payValue}({\n            projectId: revnetId,\n            token: loan.source.token,\n            amount: _balanceOf(loan.source.token) - sourceFeeAmount,\n            shouldReturnHeldFees: false,\n            memo: \"Paying off loan\",\n            metadata: bytes(abi.encodePacked(REV_ID))\n        }) {} catch (bytes memory) {}\n    }\n\n    /// @notice Returns collateral from a loan.\n    /// @param revnetId The ID of the revnet the loan is being returned in.\n    /// @param amount The amount of collateral being returned from the loan.\n    /// @param beneficiary The address receiving the returned collateral.\n    /// @param controller The controller of the revnet.\n    function _returnCollateralFrom(\n        uint256 revnetId,\n        uint256 amount,\n        address payable beneficiary,\n        IJBController controller\n    )\n        internal\n    {\n        // Decrement the total amount of collateral tokens.\n        totalCollateralOf[revnetId] -= amount;\n\n        // Mint the collateral tokens back to the loan payer.\n        // slither-disable-next-line unused-return,calls-loop\n        controller.mintTokensOf({\n            projectId: revnetId,\n            tokenCount: amount,\n            beneficiary: beneficiary,\n            memo: \"Removing collateral from loan\",\n            useReservedPercent: false\n        });\n    }\n\n    /// @notice The total borrowed amount from a revnet.\n    /// @param revnetId The ID of the revnet to check for borrowed assets from.\n    /// @param decimals The decimals the resulting fixed point value will include.\n    /// @param currency The currency the resulting value will be in terms of.\n    /// @param prices A contract that stores prices for each project.\n    /// @return borrowedAmount The total amount borrowed.\n    function _totalBorrowedFrom(\n        uint256 revnetId,\n        uint256 decimals,\n        uint256 currency,\n        IJBPrices prices\n    )\n        internal\n        view\n        returns (uint256 borrowedAmount)\n    {\n        // Keep a reference to all sources being used to loaned out from this revnet.\n        REVLoanSource[] memory sources = _loanSourcesOf[revnetId];\n\n        // Keep a reference to the number of sources being loaned out.\n        uint256 numberOfSources = sources.length;\n\n        // Keep a reference to the source being iterated on.\n        REVLoanSource memory source;\n\n        // Iterate over all sources being used to loaned out.\n        for (uint256 i = 0; i < numberOfSources; i++) {\n            // Get a reference to the token being iterated on.\n            source = sources[i];\n\n            // Get a reference to the accounting context for the source.\n            JBAccountingContext memory accountingContext =\n                source.terminal.accountingContextForTokenOf({projectId: revnetId, token: source.token});\n\n            // Normalize the price to the provided currency and decimals.\n            uint256 pricePerUnit = accountingContext.currency == currency\n                ? 10 ** decimals\n                : prices.pricePerUnitOf({\n                    projectId: revnetId,\n                    pricingCurrency: accountingContext.currency,\n                    unitCurrency: currency,\n                    decimals: decimals\n                });\n\n            // Get a reference to the amount of tokens loaned out.\n            uint256 tokensLoaned = totalBorrowedFrom[revnetId][source.terminal][source.token];\n\n            borrowedAmount += mulDiv(tokensLoaned, 10 ** decimals, pricePerUnit);\n        }\n    }\n\n    /// @notice Transfers tokens.\n    /// @param from The address to transfer tokens from.\n    /// @param to The address to transfer tokens to.\n    /// @param token The address of the token being transfered.\n    /// @param amount The amount of tokens to transfer, as a fixed point number with the same number of decimals as the\n    /// token.\n    function _transferFrom(address from, address payable to, address token, uint256 amount) internal virtual {\n        if (from == address(this)) {\n            // If the token is native token, assume the `sendValue` standard.\n            if (token == JBConstants.NATIVE_TOKEN) return Address.sendValue(to, amount);\n\n            // If the transfer is from this contract, use `safeTransfer`.\n            return IERC20(token).safeTransfer(to, amount);\n        }\n\n        // If there's sufficient approval, transfer normally.\n        if (IERC20(token).allowance(address(from), address(this)) >= amount) {\n            return IERC20(token).safeTransferFrom(from, to, amount);\n        }\n\n        // Otherwise, attempt to use the `permit2` method.\n        PERMIT2.transferFrom(from, to, uint160(amount), token);\n    }\n\n    fallback() external payable {}\n    receive() external payable {}\n}\n"
			},
			"src/interfaces/IREVDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {IJB721TiersHookDeployer} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHookDeployer.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IJBRulesetDataHook} from \"@bananapus/core/src/interfaces/IJBRulesetDataHook.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {JBRulesetConfig} from \"@bananapus/core/src/structs/JBRulesetConfig.sol\";\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {IJBSuckerRegistry} from \"@bananapus/suckers/src/interfaces/IJBSuckerRegistry.sol\";\nimport {CTPublisher} from \"@croptop/core/src/CTPublisher.sol\";\n\nimport {REVBuybackHookConfig} from \"../structs/REVBuybackHookConfig.sol\";\nimport {REVConfig} from \"../structs/REVConfig.sol\";\nimport {REVCroptopAllowedPost} from \"../structs/REVCroptopAllowedPost.sol\";\nimport {REVDeploy721TiersHookConfig} from \"../structs/REVDeploy721TiersHookConfig.sol\";\nimport {REVSuckerDeploymentConfig} from \"../structs/REVSuckerDeploymentConfig.sol\";\n\ninterface IREVDeployer {\n    event ReplaceSplitOperator(uint256 indexed revnetId, address indexed newSplitOperator, address caller);\n    event DeploySuckers(\n        uint256 indexed revnetId,\n        address indexed operator,\n        bytes32 indexed salt,\n        bytes encodedConfiguration,\n        REVSuckerDeploymentConfig suckerDeploymentConfiguration,\n        address caller\n    );\n\n    event DeployRevnet(\n        uint256 indexed revnetId,\n        REVConfig configuration,\n        JBTerminalConfig[] terminalConfigurations,\n        REVBuybackHookConfig buybackHookConfiguration,\n        REVSuckerDeploymentConfig suckerDeploymentConfiguration,\n        JBRulesetConfig[] rulesetConfigurations,\n        bytes encodedConfiguration,\n        address caller\n    );\n\n    event SetCashOutDelay(uint256 indexed revnetId, uint256 cashOutDelay, address caller);\n\n    event Mint(\n        uint256 indexed revnetId, uint256 indexed stageId, address indexed beneficiary, uint256 count, address caller\n    );\n\n    event StoreAutoMintAmount(\n        uint256 indexed revnetId, uint256 indexed stageId, address indexed beneficiary, uint256 count, address caller\n    );\n\n    event SetAdditionalOperator(uint256 revnetId, address additionalOperator, uint256[] permissionIds, address caller);\n\n    function CASH_OUT_DELAY() external view returns (uint256);\n    function CONTROLLER() external view returns (IJBController);\n    function DIRECTORY() external view returns (IJBDirectory);\n    function PROJECTS() external view returns (IJBProjects);\n    function PERMISSIONS() external view returns (IJBPermissions);\n    function FEE() external view returns (uint256);\n    function SUCKER_REGISTRY() external view returns (IJBSuckerRegistry);\n    function FEE_REVNET_ID() external view returns (uint256);\n    function PUBLISHER() external view returns (CTPublisher);\n    function HOOK_DEPLOYER() external view returns (IJB721TiersHookDeployer);\n\n    function buybackHookOf(uint256 revnetId) external view returns (IJBRulesetDataHook);\n    function tiered721HookOf(uint256 revnetId) external view returns (IJB721TiersHook);\n    function cashOutDelayOf(uint256 revnetId) external view returns (uint256);\n    function unrealizedAutoMintAmountOf(uint256 revnetId) external view returns (uint256);\n    function loansOf(uint256 revnetId) external view returns (address);\n    function isSplitOperatorOf(uint256 revnetId, address addr) external view returns (bool);\n\n    function deployFor(\n        uint256 revnetId,\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration\n    )\n        external\n        returns (uint256);\n\n    function deployWith721sFor(\n        uint256 revnetId,\n        REVConfig calldata configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration,\n        REVDeploy721TiersHookConfig memory tiered721HookConfiguration,\n        REVCroptopAllowedPost[] memory allowedPosts\n    )\n        external\n        returns (uint256, IJB721TiersHook hook);\n\n    function setSplitOperatorOf(uint256 revnetId, address newSplitOperator) external;\n    function autoMintFor(uint256 revnetId, uint256 stageId, address beneficiary) external;\n    function deploySuckersFor(\n        uint256 revnetId,\n        bytes calldata encodedConfiguration,\n        REVSuckerDeploymentConfig calldata suckerDeploymentConfiguration\n    )\n        external\n        returns (address[] memory suckers);\n\n    function amountToAutoMint(uint256 revnetId, uint256 stageId, address beneficiary) external view returns (uint256);\n}\n"
			},
			"src/interfaces/IREVLoans.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IAllowanceTransfer} from \"@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol\";\nimport {IPermit2} from \"@uniswap/permit2/src/interfaces/IPermit2.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBPayoutTerminal} from \"@bananapus/core/src/interfaces/IJBPayoutTerminal.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {JBAccountingContext} from \"@bananapus/core/src/structs/JBAccountingContext.sol\";\nimport {JBSingleAllowance} from \"@bananapus/core/src/structs/JBSingleAllowance.sol\";\n\nimport {REVLoan} from \"./../structs/REVLoan.sol\";\nimport {REVLoanSource} from \"./../structs/REVLoanSource.sol\";\n\ninterface IREVLoans {\n    event Borrow(\n        uint256 indexed loanId,\n        uint256 indexed revnetId,\n        REVLoan loan,\n        REVLoanSource source,\n        uint256 amount,\n        uint256 collateral,\n        address payable beneficiary,\n        address caller\n    );\n    event Liquidate(uint256 indexed loanId, uint256 indexed revnetId, REVLoan loan, address caller);\n    event RepayLoan(\n        uint256 indexed loanId,\n        uint256 indexed revnetId,\n        uint256 indexed paidOffLoanId,\n        REVLoan loan,\n        REVLoan paidOffLoan,\n        uint256 amount,\n        uint256 sourceFeeAmount,\n        uint256 collateralToReturn,\n        address payable beneficiary,\n        address caller\n    );\n    event ReallocateCollateral(\n        uint256 indexed loanId,\n        uint256 indexed reallocatedLoanId,\n        uint256 indexed revnetId,\n        REVLoan reallocatedLoan,\n        uint256 removedCollateral,\n        address caller\n    );\n\n    function LOAN_LIQUIDATION_DURATION() external view returns (uint256);\n    function MAX_PREPAID_PERCENT() external view returns (uint256);\n    function PERMIT2() external view returns (IPermit2);\n    function PROJECTS() external view returns (IJBProjects);\n    function REV_ID() external view returns (uint256);\n    function REV_PREPAID_FEE() external view returns (uint256);\n\n    function borrowableAmountFrom(\n        uint256 revnetId,\n        uint256 collateral,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n    function determineSourceFeeAmount(\n        REVLoan memory loan,\n        uint256 amount\n    )\n        external\n        view\n        returns (uint256 sourceFeeAmount);\n    function isLoanSourceOf(uint256 revnetId, IJBPayoutTerminal terminal, address token) external view returns (bool);\n    function lastLoanIdLiquidatedFrom(uint256 revnetId) external view returns (uint256);\n    function loanOf(uint256 loanId) external view returns (REVLoan memory);\n    function loanSourcesOf(uint256 revnetId) external view returns (REVLoanSource[] memory);\n    function numberOfLoansFor(uint256 revnetId) external view returns (uint256);\n    function revnetIdOfLoanWith(uint256 loanId) external view returns (uint256);\n    function totalBorrowedFrom(\n        uint256 revnetId,\n        IJBPayoutTerminal terminal,\n        address token\n    )\n        external\n        view\n        returns (uint256);\n    function totalCollateralOf(uint256 revnetId) external view returns (uint256);\n\n    function borrowFrom(\n        uint256 revnetId,\n        REVLoanSource calldata source,\n        uint256 amount,\n        uint256 collateral,\n        address payable beneficiary,\n        uint256 prepaidFeePercent\n    )\n        external\n        returns (uint256 loanId, REVLoan memory loan);\n    function liquidateExpiredLoansFrom(uint256 revnetId, uint256 count) external;\n    function repayLoan(\n        uint256 loanId,\n        uint256 newAmount,\n        uint256 newCollateral,\n        address payable beneficiary,\n        JBSingleAllowance calldata allowance\n    )\n        external\n        payable\n        returns (uint256 paidOffLoanId, REVLoan memory loan);\n    function reallocateCollateralFromLoan(\n        uint256 loanId,\n        uint256 collateralToTransfer,\n        REVLoanSource calldata source,\n        uint256 amount,\n        uint256 collateralToAdd,\n        address payable beneficiary,\n        uint256 prepaidFeePercent\n    )\n        external\n        payable\n        returns (uint256 reallocatedLoanId, uint256 newLoanId, REVLoan memory reallocatedLoan, REVLoan memory newLoan);\n}\n"
			},
			"src/structs/REVAutoMint.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member chainId The ID of the chain on which the mint should be honored.\n/// @custom:member count The number of tokens that should be minted.\n/// @custom:member beneficiary The address that will receive the minted tokens.\nstruct REVAutoMint {\n    uint32 chainId;\n    uint104 count;\n    address beneficiary;\n}\n"
			},
			"src/structs/REVBuybackHookConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBBuybackHook} from \"@bananapus/buyback-hook/src/interfaces/IJBBuybackHook.sol\";\n\nimport {REVBuybackPoolConfig} from \"./REVBuybackPoolConfig.sol\";\n\n/// @custom:member hook The buyback hook to use.\n/// @custom:member poolConfigurations The pools to setup on the given buyback contract.\nstruct REVBuybackHookConfig {\n    IJBBuybackHook hook;\n    REVBuybackPoolConfig[] poolConfigurations;\n}\n"
			},
			"src/structs/REVBuybackPoolConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token to setup a pool for.\n/// @custom:member poolFee The fee of the pool in which swaps occur when seeking the best price for a new participant.\n/// This incentivizes liquidity providers. Out of 1_000_000. A common value is 1%, or 10_000. Other passible values are\n/// 0.3% and 0.1%.\n/// @custom:member twapWindow The time window to take into account when quoting a price based on TWAP.\n/// @custom:member twapSlippageTolerance The pricetolerance to accept when quoting a price based on TWAP.\nstruct REVBuybackPoolConfig {\n    address token;\n    uint24 fee;\n    uint32 twapWindow;\n    uint32 twapSlippageTolerance;\n}\n"
			},
			"src/structs/REVConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IREVLoans} from \"../interfaces/IREVLoans.sol\";\nimport {REVDescription} from \"./REVDescription.sol\";\nimport {REVLoanSource} from \"./REVLoanSource.sol\";\nimport {REVStageConfig} from \"./REVStageConfig.sol\";\n\n/// @custom:member description The description of the revnet.\n/// @custom:member baseCurrency The currency that the issuance is based on.\n/// @custom:member premintTokenAmount The number of tokens that should be preminted to the initial operator.\n/// @custom:member premintChainId The ID of the chain on which the premint should be honored.\n/// @custom:member premintStage The stage during which the premint should be honored.\n/// @custom:member splitOperator The address that will receive the token premint and initial production split,\n/// and who\n/// is\n/// allowed to change who the operator is. Only the operator can replace itself after deployment.\n/// @custom:member stageConfigurations The periods of changing constraints.\n/// @custom:member loanSources The sources for loans.\n/// @custom:member loans The loans contract, which can mint the revnet's tokens and use the revnet's balance.\n/// @custom:member allowCrosschainSuckerExtension A flag indicating if the revnet should later be able be extended to\n/// new chains\n/// after deployment.\nstruct REVConfig {\n    REVDescription description;\n    uint32 baseCurrency;\n    address splitOperator;\n    REVStageConfig[] stageConfigurations;\n    REVLoanSource[] loanSources;\n    address loans;\n    bool allowCrosschainSuckerExtension;\n}\n"
			},
			"src/structs/REVCroptopAllowedPost.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Criteria for allowed posts.\n/// @custom:member category A category that should allow posts.\n/// @custom:member minimumPrice The minimum price that a post to the specified category should cost.\n/// @custom:member minimumTotalSupply The minimum total supply of NFTs that can be made available when minting.\n/// @custom:member maxTotalSupply The max total supply of NFTs that can be made available when minting. Leave as 0 for\n/// max.\n/// @custom:member allowedAddresses A list of addresses that are allowed to post on the category through Croptop.\nstruct REVCroptopAllowedPost {\n    uint24 category;\n    uint104 minimumPrice;\n    uint32 minimumTotalSupply;\n    uint32 maximumTotalSupply;\n    address[] allowedAddresses;\n}\n"
			},
			"src/structs/REVDeploy721TiersHookConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBDeploy721TiersHookConfig} from \"@bananapus/721-hook/src/structs/JBDeploy721TiersHookConfig.sol\";\n\n/// @custom:member baseline721HookConfiguration The baseline config.\n/// @custom:member splitOperatorCanAdjustTiers A flag indicating if the revnet's split operator can add tiers and remove\n/// tiers if\n/// the tier is allowed to be removed\n/// @custom:member splitOperatorCanUpdateMetadata A flag indicating if the revnet's split operator can update the 721's\n/// metadata.\n/// @custom:member splitOperatorCanMint A flag indicating if the revnet's split operator can mint 721's from tiers that\n/// allow it.\n/// @custom:member splitOperatorCanIncreaseDiscountPercent A flag indicating if the revnet's split operator can increase the\n/// discount of a tier.\nstruct REVDeploy721TiersHookConfig {\n    JBDeploy721TiersHookConfig baseline721HookConfiguration;\n    bool splitOperatorCanAdjustTiers;\n    bool splitOperatorCanUpdateMetadata;\n    bool splitOperatorCanMint;\n    bool splitOperatorCanIncreaseDiscountPercent;\n}\n"
			},
			"src/structs/REVDescription.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member name The name of the ERC-20 token being create for the revnet.\n/// @custom:member ticker The ticker of the ERC-20 token being created for the revnet.\n/// @custom:member uri The metadata URI containing revnet's info.\n/// @custom:member salt Revnets deployed across chains by the same address with the same salt will have the same\n/// address.\nstruct REVDescription {\n    string name;\n    string ticker;\n    string uri;\n    bytes32 salt;\n}\n"
			},
			"src/structs/REVLoan.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {REVLoanSource} from \"./REVLoanSource.sol\";\n\n/// @custom:member borrowedAmount The amount that is being borrowed.\n/// @custom:member collateralTokenCount The number of collateral tokens currently accounted for.\n/// @custom:member createdAt The timestamp when the loan was created.\n/// @custom:member prepaidFeePercent The percentage of the loan's fees that were prepaid.\n/// @custom:member prepaidDuration The duration that the loan was prepaid for.\n/// @custom:member source The source of the loan.\nstruct REVLoan {\n    uint112 amount;\n    uint112 collateral;\n    uint40 createdAt;\n    uint16 prepaidFeePercent;\n    uint32 prepaidDuration;\n    REVLoanSource source;\n}\n"
			},
			"src/structs/REVLoanSource.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPayoutTerminal} from \"@bananapus/core/src/interfaces/IJBPayoutTerminal.sol\";\n\n/// @custom:member token The token that is being loaned.\n/// @custom:member terminal The terminal that the loan is being made from.\nstruct REVLoanSource {\n    address token;\n    IJBPayoutTerminal terminal;\n}\n"
			},
			"src/structs/REVStageConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {REVAutoMint} from \"./REVAutoMint.sol\";\n\n/// @custom:member startsAtOrAfter The timestamp to start a stage at the given rate at or after.\n/// @custom:member autoMints The configurations of mints during this stage.\n/// @custom:member splitPercent The percentage of newly issued tokens that should be split with the operator, out\n/// of\n/// 10_000 (JBConstants.MAX_RESERVED_PERCENT).\n/// @custom:member initialIssuance The number of revnet tokens that one unit of the revnet's base currency will buy, as\n/// a fixed point number\n/// with 18 decimals.\n/// @custom:member issuanceDecayFrequency The number of seconds between applied issuance increases. This\n/// should be at least 24 hours.\n/// @custom:member issuanceDecayPercent The percent that issuance should decrease over time. This percentage is out\n/// of 1_000_000_000 (JBConstants.MAX_DECAY_PERCENT). 0% corresponds to no issuance increase.\n/// @custom:member cashOutTaxRate The factor determining how much each token can cash out from the revnet once\n/// redeemed. This rate is out of 10_000 (JBConstants.MAX_REDEMPTION_RATE). 0% corresponds to no tax when cashing out.\n/// @custom:member extraMetadata Extra info to attach set into this stage that may affect hooks.\nstruct REVStageConfig {\n    uint40 startsAtOrAfter;\n    REVAutoMint[] autoMints;\n    uint16 splitPercent;\n    uint112 initialIssuance;\n    uint32 issuanceDecayFrequency;\n    uint32 issuanceDecayPercent;\n    uint16 cashOutTaxRate;\n    uint16 extraMetadata;\n}\n"
			},
			"src/structs/REVSuckerDeploymentConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSuckerDeployerConfig} from \"@bananapus/suckers/src/structs/JBSuckerDeployerConfig.sol\";\n\n/// @custom:member deployerConfigurations The information for how to suck tokens to other chains.\n/// @custom:member salt The salt to use for creating suckers so that they use the same address across chains.\nstruct REVSuckerDeploymentConfig {\n    JBSuckerDeployerConfig[] deployerConfigurations;\n    bytes32 salt;\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBSplitGroupIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Group IDs that categorize splits.\nlibrary JBSplitGroupIds {\n    uint256 public constant RESERVED_TOKENS = 1;\n}\n"
			},
			"src/REVDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {IJB721TiersHookDeployer} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHookDeployer.sol\";\nimport {IJBBuybackHook} from \"@bananapus/buyback-hook/src/interfaces/IJBBuybackHook.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBPayHook} from \"@bananapus/core/src/interfaces/IJBPayHook.sol\";\nimport {IJBPermissioned} from \"@bananapus/core/src/interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IJBRedeemHook} from \"@bananapus/core/src/interfaces/IJBRedeemHook.sol\";\nimport {IJBRulesetApprovalHook} from \"@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol\";\nimport {IJBRulesetDataHook} from \"@bananapus/core/src/interfaces/IJBRulesetDataHook.sol\";\nimport {IJBSplitHook} from \"@bananapus/core/src/interfaces/IJBSplitHook.sol\";\nimport {IJBTerminal} from \"@bananapus/core/src/interfaces/IJBTerminal.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\nimport {JBRedemptions} from \"@bananapus/core/src/libraries/JBRedemptions.sol\";\nimport {JBSplitGroupIds} from \"@bananapus/core/src/libraries/JBSplitGroupIds.sol\";\nimport {JBAfterRedeemRecordedContext} from \"@bananapus/core/src/structs/JBAfterRedeemRecordedContext.sol\";\nimport {JBBeforePayRecordedContext} from \"@bananapus/core/src/structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeRedeemRecordedContext} from \"@bananapus/core/src/structs/JBBeforeRedeemRecordedContext.sol\";\nimport {JBCurrencyAmount} from \"@bananapus/core/src/structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"@bananapus/core/src/structs/JBFundAccessLimitGroup.sol\";\nimport {JBPermissionsData} from \"@bananapus/core/src/structs/JBPermissionsData.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {JBRulesetConfig} from \"@bananapus/core/src/structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"@bananapus/core/src/structs/JBRulesetMetadata.sol\";\nimport {JBSplit} from \"@bananapus/core/src/structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"@bananapus/core/src/structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {JBRedeemHookSpecification} from \"@bananapus/core/src/structs/JBRedeemHookSpecification.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {IJBSuckerRegistry} from \"@bananapus/suckers/src/interfaces/IJBSuckerRegistry.sol\";\nimport {CTPublisher} from \"@croptop/core/src/CTPublisher.sol\";\nimport {CTAllowedPost} from \"@croptop/core/src/structs/CTAllowedPost.sol\";\n\nimport {IREVDeployer} from \"./interfaces/IREVDeployer.sol\";\nimport {REVAutoMint} from \"./structs/REVAutoMint.sol\";\nimport {REVBuybackHookConfig} from \"./structs/REVBuybackHookConfig.sol\";\nimport {REVBuybackPoolConfig} from \"./structs/REVBuybackPoolConfig.sol\";\nimport {REVConfig} from \"./structs/REVConfig.sol\";\nimport {REVCroptopAllowedPost} from \"./structs/REVCroptopAllowedPost.sol\";\nimport {REVDeploy721TiersHookConfig} from \"./structs/REVDeploy721TiersHookConfig.sol\";\nimport {REVLoanSource} from \"./structs/REVLoanSource.sol\";\nimport {REVStageConfig} from \"./structs/REVStageConfig.sol\";\nimport {REVSuckerDeploymentConfig} from \"./structs/REVSuckerDeploymentConfig.sol\";\n\n/// @notice `REVDeployer` deploys, manages, and operates Revnets.\n/// @dev Revnets are unowned Juicebox projects which operate autonomously after deployment.\ncontract REVDeployer is IREVDeployer, IJBRulesetDataHook, IJBRedeemHook, IERC721Receiver {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error REVDeployer_CashOutDelayNotFinished();\n    error REVDeployer_CashOutsCantBeTurnedOffCompletely();\n    error REVDeployer_StageNotStarted();\n    error REVDeployer_StagesRequired();\n    error REVDeployer_StageTimesMustIncrease();\n    error REVDeployer_Unauthorized();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice The number of seconds until a revnet's participants can cash out, starting from the time when that\n    /// revnet is deployed to a new network.\n    /// - Only applies to existing revnets which are deploying onto a new network.\n    /// - To prevent liquidity/arbitrage issues which might arise when an existing revnet adds a brand-new treasury.\n    /// @dev 30 days, in seconds.\n    uint256 public constant override CASH_OUT_DELAY = 2_592_000;\n\n    /// @notice The cashout fee (as a fraction out of `JBConstants.MAX_FEE`).\n    /// Cashout fees are paid to the revnet with the `FEE_REVNET_ID`.\n    /// @dev Fees are charged on cashouts if the cashout tax rate is greater than 0%.\n    /// @dev When suckers withdraw funds, they do not pay cashout fees.\n    uint256 public constant override FEE = 25; // 2.5%\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice The controller used to create and manage Juicebox projects for revnets.\n    IJBController public immutable override CONTROLLER;\n\n    /// @notice The directory of terminals and controllers for Juicebox projects (and revnets).\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The Juicebox project ID of the revnet that receives cashout fees.\n    uint256 public immutable override FEE_REVNET_ID;\n\n    /// @notice Deploys tiered ERC-721 hooks for revnets.\n    IJB721TiersHookDeployer public immutable override HOOK_DEPLOYER;\n\n    /// @notice Stores Juicebox project (and revnet) access permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    /// @notice Mints ERC-721s that represent Juicebox project (and revnet) ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    /// @notice Manages the publishing of ERC-721 posts to revnet's tiered ERC-721 hooks.\n    CTPublisher public immutable override PUBLISHER;\n\n    /// @notice Deploys and tracks suckers for revnets.\n    IJBSuckerRegistry public immutable override SUCKER_REGISTRY;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The number of revnet tokens which can be \"auto-minted\" (minted without payments)\n    /// for a specific beneficiary during a stage. Think of this as a per-stage premint.\n    /// @dev These tokens can be minted with `autoMintFor()`.\n    /// @custom:param revnetId The ID of the revnet to get the auto-mint amount for.\n    /// @custom:param stageId The ID of the stage to get the auto-mint amount for.\n    /// @custom:param beneficiary The beneficiary of the auto-mint.\n    mapping(uint256 revnetId => mapping(uint256 stageId => mapping(address beneficiary => uint256))) public override\n        amountToAutoMint;\n\n    /// @notice Each revnet's buyback data hook. These return buyback hook data.\n    /// @dev Buyback hooks are a combined data hook/pay hook.\n    /// @custom:param revnetId The ID of the revnet to get the buyback data hook for.\n    mapping(uint256 revnetId => IJBRulesetDataHook buybackHook) public override buybackHookOf;\n\n    /// @notice The timestamp of when cashouts will become available to a specific revnet's participants.\n    /// @dev Only applies to existing revnets which are deploying onto a new network.\n    /// @custom:param revnetId The ID of the revnet to get the cashout delay for.\n    mapping(uint256 revnetId => uint256 cashOutDelay) public override cashOutDelayOf;\n\n    /// @notice Each revnet's loan contract.\n    /// @dev Revnets can offer loans to their participants, collateralized by their tokens.\n    /// Participants can borrow up to the current cashout value of their tokens.\n    /// @custom:param revnetId The ID of the revnet to get the loan contract of.\n    mapping(uint256 revnetId => address) public override loansOf;\n\n    /// @notice Each revnet's tiered ERC-721 hook.\n    /// @custom:param revnetId The ID of the revnet to get the tiered ERC-721 hook for.\n    // slither-disable-next-line uninitialized-state\n    mapping(uint256 revnetId => IJB721TiersHook tiered721Hook) public override tiered721HookOf;\n\n    /// @notice The amount of auto-mint tokens which have not been minted yet, including future stages, for each revnet.\n    /// @dev These tokens can be realized (minted) with `autoMintFor()`.\n    /// @custom:param revnetId The ID of the revnet to get the unrealized auto-mint amount for.\n    mapping(uint256 revnetId => uint256) public override unrealizedAutoMintAmountOf;\n\n    //*********************************************************************//\n    // ------------------- internal stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice A list of `JBPermissonIds` indices to grant to the split operator of a specific revnet.\n    /// @dev These should be set in the revnet's deployment process.\n    /// @custom:param revnetId The ID of the revnet to get the extra operator permissions for.\n    // slither-disable-next-line uninitialized-state\n    mapping(uint256 revnetId => uint256[]) internal _extraOperatorPermissions;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Before a revnet processes an incoming payment, determine the weight and pay hooks to use.\n    /// @dev This function is part of `IJBRulesetDataHook`, and gets called before the revnet processes a payment.\n    /// @param context Standard Juicebox payment context. See `JBBeforePayRecordedContext`.\n    /// @return weight The weight which revnet tokens are minted relative to. This can be used to customize how many\n    /// tokens get minted by a payment.\n    /// @return hookSpecifications Amounts (out of what's being paid in) to be sent to pay hooks instead of being paid\n    /// into the revnet. Useful for automatically routing funds from a treasury as payments come in.\n    function beforePayRecordedWith(JBBeforePayRecordedContext calldata context)\n        external\n        view\n        override\n        returns (uint256 weight, JBPayHookSpecification[] memory hookSpecifications)\n    {\n        // Keep a reference to the specifications provided by the buyback data hook.\n        JBPayHookSpecification[] memory buybackHookSpecifications;\n\n        // Keep a reference to the revnet's buyback data hook.\n        IJBRulesetDataHook buybackHook = buybackHookOf[context.projectId];\n\n        // Read the weight and specifications from the buyback data hook.\n        // If there's no buyback data hook, use the default weight.\n        if (buybackHook != IJBRulesetDataHook(address(0))) {\n            (weight, buybackHookSpecifications) = buybackHook.beforePayRecordedWith(context);\n        } else {\n            weight = context.weight;\n        }\n\n        // Is there a buyback hook specification?\n        bool usesBuybackHook = buybackHookSpecifications.length != 0;\n\n        // Keep a reference to the revnet's tiered ERC-721 hook.\n        IJB721TiersHook tiered721Hook = tiered721HookOf[context.projectId];\n\n        // Is there a tiered ERC-721 hook?\n        bool usesTiered721Hook = address(tiered721Hook) != address(0);\n\n        // Initialize the returned specification array with enough room to include the specifications we're using.\n        hookSpecifications = new JBPayHookSpecification[]((usesTiered721Hook ? 1 : 0) + (usesBuybackHook ? 1 : 0));\n\n        // If we have a tiered ERC-721 hook, add it to the array.\n        if (usesTiered721Hook) {\n            hookSpecifications[0] =\n                JBPayHookSpecification({hook: IJBPayHook(address(tiered721Hook)), amount: 0, metadata: bytes(\"\")});\n        }\n\n        // If we have a buyback hook specification, add it to the end of the array.\n        if (usesBuybackHook) hookSpecifications[1] = buybackHookSpecifications[0];\n    }\n\n    /// @notice Determine how a redemption from a revnet should be processed.\n    /// @dev This function is part of `IJBRulesetDataHook`, and gets called before the revnet processes a redemption.\n    /// @dev If a sucker is redeeming, no taxes or fees are imposed.\n    /// @param context Standard Juicebox redemption context. See `JBBeforeRedeemRecordedContext`.\n    /// @return redemptionRate The redemption rate, which influences the amount of terminal tokens which get reclaimed.\n    /// @return redeemCount The number of revnet tokens that are redeemed.\n    /// @return totalSupply The total revnet token supply.\n    /// @return hookSpecifications The amount of funds and the data to send to redeem hooks (this contract).\n    function beforeRedeemRecordedWith(JBBeforeRedeemRecordedContext calldata context)\n        external\n        view\n        override\n        returns (\n            uint256 redemptionRate,\n            uint256 redeemCount,\n            uint256 totalSupply,\n            JBRedeemHookSpecification[] memory hookSpecifications\n        )\n    {\n        // If the redeemer is a sucker, return the full redemption amount without taxes or fees.\n        if (_isSuckerOf({revnetId: context.projectId, addr: context.holder})) {\n            return (JBConstants.MAX_REDEMPTION_RATE, context.redeemCount, context.totalSupply, hookSpecifications);\n        }\n\n        // Enforce the cashout delay.\n        if (cashOutDelayOf[context.projectId] > block.timestamp) {\n            revert REVDeployer_CashOutDelayNotFinished();\n        }\n\n        // Get the terminal that will receive the cashout fee.\n        IJBTerminal feeTerminal = DIRECTORY.primaryTerminalOf(FEE_REVNET_ID, context.surplus.token);\n\n        // If there's no cashout tax (100% redemption rate), or if there's no fee terminal, do not charge a fee.\n        if (context.redemptionRate == JBConstants.MAX_REDEMPTION_RATE || address(feeTerminal) == address(0)) {\n            return (context.redemptionRate, context.redeemCount, context.totalSupply, hookSpecifications);\n        }\n\n        // Get a reference to the number of tokens being used to pay the fee (out of the total being redeemed).\n        uint256 feeRedeemCount = mulDiv(context.redeemCount, FEE, JBConstants.MAX_FEE);\n\n        // Assemble a redeem hook specification to invoke `afterRedeemRecordedWith()` with, to process the fee.\n        hookSpecifications = new JBRedeemHookSpecification[](1);\n        hookSpecifications[0] = JBRedeemHookSpecification({\n            hook: IJBRedeemHook(address(this)),\n            amount: JBRedemptions.reclaimFrom({\n                surplus: context.surplus.value,\n                tokensRedeemed: feeRedeemCount,\n                totalSupply: context.totalSupply,\n                redemptionRate: context.redemptionRate\n            }),\n            metadata: abi.encode(feeTerminal)\n        });\n\n        // Return the redemption rate and the number of revnet tokens to redeem, minus the tokens being used to pay the\n        // fee.\n        return (context.redemptionRate, context.redeemCount - feeRedeemCount, context.totalSupply, hookSpecifications);\n    }\n\n    /// @notice A flag indicating whether an address has permission to mint a revnet's tokens on-demand.\n    /// @dev Required by the `IJBRulesetDataHook` interface.\n    /// @param revnetId The ID of the revnet to check permissions for.\n    /// @param addr The address to check the mint permission of.\n    /// @return flag A flag indicating whether the address has permission to mint the revnet's tokens on-demand.\n    function hasMintPermissionFor(uint256 revnetId, address addr) external view override returns (bool) {\n        // The buyback hook, loans contract, and suckers are allowed to mint the revnet's tokens.\n        return addr == address(buybackHookOf[revnetId]) || addr == loansOf[revnetId]\n            || _isSuckerOf({revnetId: revnetId, addr: addr});\n    }\n\n    /// @dev Make sure this contract can only receive project NFTs from `JBProjects`.\n    function onERC721Received(address, address, uint256, bytes calldata) external view returns (bytes4) {\n        // Make sure the 721 received is from the `JBProjects` contract.\n        if (msg.sender != address(PROJECTS)) revert();\n\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice A flag indicating whether an address is a revnet's split operator.\n    /// @param revnetId The ID of the revnet.\n    /// @param addr The address to check.\n    /// @return flag A flag indicating whether the address is the revnet's split operator.\n    function isSplitOperatorOf(uint256 revnetId, address addr) public view override returns (bool) {\n        return PERMISSIONS.hasPermissions({\n            operator: addr,\n            account: address(this),\n            projectId: revnetId,\n            permissionIds: _splitOperatorPermissionIndexesOf(revnetId),\n            includeRoot: false,\n            includeWildcardProjectId: false\n        });\n    }\n\n    /// @notice Indicates if this contract adheres to the specified interface.\n    /// @dev See `IERC165.supportsInterface`.\n    /// @return A flag indicating if the provided interface ID is supported.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IREVDeployer).interfaceId || interfaceId == type(IJBRulesetDataHook).interfaceId\n            || interfaceId == type(IJBRedeemHook).interfaceId || interfaceId == type(IERC721Receiver).interfaceId;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice If the specified address is not the revnet's current split operator, revert.\n    /// @param revnetId The ID of the revnet to check split operator status for.\n    /// @param operator The address being checked.\n    function _checkIfIsSplitOperatorOf(uint256 revnetId, address operator) internal view {\n        if (!isSplitOperatorOf(revnetId, operator)) revert REVDeployer_Unauthorized();\n    }\n\n    /// @notice Encodes an auto-mint.\n    /// @param autoMint The auto-mint to encode.\n    /// @return encodedAutoMint The encoded auto-mint.\n    function _encodedAutoMint(REVAutoMint memory autoMint) private pure returns (bytes memory) {\n        return abi.encode(autoMint.chainId, autoMint.beneficiary, autoMint.count);\n    }\n\n    /// @notice Encodes a revnet stage. This is used for sucker deployment salts.\n    /// @param stageConfiguration The stage's configuration.\n    /// @param stageNumber The stage's number/ID.\n    /// @return encodedConfiguration The encoded stage.\n    function _encodedStageConfig(\n        REVStageConfig memory stageConfiguration,\n        uint256 stageNumber\n    )\n        internal\n        view\n        returns (bytes memory encodedConfiguration)\n    {\n        // Encode the stage.\n        encodedConfiguration = abi.encode(\n            // If no start time is provided for the first stage, use the current block's timestamp.\n            // In the future, revnets deployed on other networks can match this revnet's encoded stage by specifying the\n            // same start time.\n            (stageNumber == 0 && stageConfiguration.startsAtOrAfter == 0)\n                ? block.timestamp\n                : stageConfiguration.startsAtOrAfter,\n            stageConfiguration.splitPercent,\n            stageConfiguration.initialIssuance,\n            stageConfiguration.issuanceDecayFrequency,\n            stageConfiguration.issuanceDecayPercent,\n            stageConfiguration.cashOutTaxRate\n        );\n\n        // Get a reference to the stage's auto-mints.\n        uint256 numberOfAutoMints = stageConfiguration.autoMints.length;\n\n        // Add each auto-mint to the byte-encoded representation.\n        for (uint256 i; i < numberOfAutoMints; i++) {\n            encodedConfiguration = abi.encode(encodedConfiguration, _encodedAutoMint(stageConfiguration.autoMints[i]));\n        }\n    }\n\n    /// @notice A flag indicating whether an address is a revnet's sucker.\n    /// @param revnetId The ID of the revnet to check sucker status for.\n    /// @param addr The address being checked.\n    /// @return isSucker A flag indicating whether the address is one of the revnet's suckers.\n    function _isSuckerOf(uint256 revnetId, address addr) internal view returns (bool) {\n        return SUCKER_REGISTRY.isSuckerOf(revnetId, addr);\n    }\n\n    /// @notice Initialize a fund access limit group for the loan contract to use.\n    /// @dev Returns an unlimited surplus allowance for each token which can be loaned out.\n    /// @param configuration The revnet's configuration.\n    /// @return fundAccessLimitGroups The fund access limit groups for the loans.\n    function _makeLoanFundAccessLimits(REVConfig memory configuration)\n        internal\n        pure\n        returns (JBFundAccessLimitGroup[] memory fundAccessLimitGroups)\n    {\n        // Keep a reference to the number of loan access groups there are.\n        uint256 numberOfLoanSources = configuration.loanSources.length;\n\n        // Keep a reference to the loan source to iterate on.\n        // Loans are sourced from a token accepted by one of the revnet's terminals.\n        REVLoanSource memory loanSource;\n\n        // Set up an unlimited allowance for the loan contract to use.\n        JBCurrencyAmount[] memory loanAllowances = new JBCurrencyAmount[](1);\n        loanAllowances[0] = JBCurrencyAmount({currency: configuration.baseCurrency, amount: type(uint224).max});\n\n        // Initialize the fund access limit groups.\n        fundAccessLimitGroups = new JBFundAccessLimitGroup[](numberOfLoanSources);\n\n        // Set up the fund access limits for the loans.\n        for (uint256 i; i < numberOfLoanSources; i++) {\n            // Set the loan source being iterated on.\n            loanSource = configuration.loanSources[i];\n\n            // Set up the fund access limits for the loans.\n            fundAccessLimitGroups[i] = JBFundAccessLimitGroup({\n                terminal: address(loanSource.terminal),\n                token: loanSource.token,\n                payoutLimits: new JBCurrencyAmount[](0),\n                surplusAllowances: loanAllowances\n            });\n        }\n    }\n\n    /// @notice Creates a reserved token split group that goes entirely to the specified split operator.\n    /// @dev The operator can add other beneficiaries to the split group later, if they wish.\n    /// @param splitOperator The address to send the entire split amount to.\n    /// @return splitGroups The split group, entirely assigned to the operator.\n    function _makeOperatorSplitGroupWith(address splitOperator)\n        internal\n        pure\n        returns (JBSplitGroup[] memory splitGroups)\n    {\n        // Create a split group that assigns all of the splits to the operator.\n        JBSplit[] memory splits = new JBSplit[](1);\n        splits[0] = JBSplit({\n            preferAddToBalance: false,\n            percent: JBConstants.SPLITS_TOTAL_PERCENT,\n            projectId: 0,\n            beneficiary: payable(splitOperator),\n            lockedUntil: 0,\n            hook: IJBSplitHook(address(0))\n        });\n\n        // Package the reserved token splits.\n        splitGroups = new JBSplitGroup[](1);\n        splitGroups[0] = JBSplitGroup({groupId: JBSplitGroupIds.RESERVED_TOKENS, splits: splits});\n    }\n\n    /// @notice Convert a revnet's stages into a series of Juicebox project rulesets.\n    /// @param configuration The configuration containing the revnet's stages.\n    /// @return rulesetConfigurations A list of ruleset configurations defined by the stages.\n    /// @return encodedConfiguration A byte-encoded representation of the revnet's configuration. Used for sucker\n    /// deployment salts.\n    function _makeRulesetConfigurations(REVConfig memory configuration)\n        internal\n        view\n        returns (JBRulesetConfig[] memory rulesetConfigurations, bytes memory encodedConfiguration)\n    {\n        // Keep a reference to the number of stages to queue as rulesets.\n        uint256 numberOfStages = configuration.stageConfigurations.length;\n\n        // If there are no stages, revert.\n        if (numberOfStages == 0) revert REVDeployer_StagesRequired();\n\n        // Initialize the array of rulesets.\n        rulesetConfigurations = new JBRulesetConfig[](numberOfStages);\n\n        // Add the base configuration to the byte-encoded configuration.\n        encodedConfiguration = abi.encode(\n            configuration.baseCurrency,\n            configuration.loans,\n            configuration.allowCrosschainSuckerExtension,\n            configuration.description.name,\n            configuration.description.ticker,\n            configuration.description.salt\n        );\n\n        // Keep a reference to the revnet stage being iterated on.\n        REVStageConfig memory stageConfiguration;\n\n        // Initialize fund access limit groups for the loan contract to use.\n        JBFundAccessLimitGroup[] memory fundAccessLimitGroups = _makeLoanFundAccessLimits(configuration);\n\n        // Keep a reference to the previous ruleset's start time.\n        uint256 previousStartTime;\n\n        // Iterate through each stage to set up its ruleset.\n        for (uint256 i; i < numberOfStages; i++) {\n            // Set the stage being iterated on.\n            stageConfiguration = configuration.stageConfigurations[i];\n\n            // If the stage's start time is not after the previous stage's start time, revert.\n            if (stageConfiguration.startsAtOrAfter <= previousStartTime) {\n                revert REVDeployer_StageTimesMustIncrease();\n            }\n\n            // Make sure the revnet doesn't prevent cashouts all together.\n            if (stageConfiguration.cashOutTaxRate >= JBConstants.MAX_REDEMPTION_RATE) {\n                revert REVDeployer_CashOutsCantBeTurnedOffCompletely();\n            }\n\n            // Set up the ruleset's metadata.\n            JBRulesetMetadata memory metadata;\n            metadata.reservedPercent = stageConfiguration.splitPercent;\n            metadata.redemptionRate = JBConstants.MAX_REDEMPTION_RATE - stageConfiguration.cashOutTaxRate;\n            metadata.baseCurrency = configuration.baseCurrency;\n            metadata.allowOwnerMinting = true; // Allow this contract to auto-mint tokens as the revnet's owner.\n            metadata.useDataHookForPay = true; // Call this contract's `beforePayRecordedWith()` callback on payments.\n            metadata.allowCrosschainSuckerExtension = configuration.allowCrosschainSuckerExtension;\n            metadata.dataHook = address(this); // This contract is the data hook.\n            metadata.metadata = stageConfiguration.extraMetadata;\n\n            // Set up the ruleset.\n            rulesetConfigurations[i] = JBRulesetConfig({\n                mustStartAtOrAfter: stageConfiguration.startsAtOrAfter,\n                duration: stageConfiguration.issuanceDecayFrequency,\n                weight: stageConfiguration.initialIssuance,\n                decayPercent: stageConfiguration.issuanceDecayPercent,\n                approvalHook: IJBRulesetApprovalHook(address(0)),\n                metadata: metadata,\n                splitGroups: new JBSplitGroup[](0),\n                fundAccessLimitGroups: fundAccessLimitGroups\n            });\n\n            // Add the stage's properties to the byte-encoded configuration.\n            encodedConfiguration = abi.encode(\n                encodedConfiguration, _encodedStageConfig({stageConfiguration: stageConfiguration, stageNumber: i})\n            );\n\n            // Store the ruleset's start time for the next iteration.\n            previousStartTime = stageConfiguration.startsAtOrAfter;\n        }\n    }\n\n    /// @notice Returns the permissions that the split operator should be granted for a revnet.\n    /// @param revnetId The ID of the revnet to get split operator permissions for.\n    /// @return allOperatorPermissions The permissions that the split operator should be granted for the revnet,\n    /// including both default and custom permissions.\n    function _splitOperatorPermissionIndexesOf(uint256 revnetId)\n        internal\n        view\n        returns (uint256[] memory allOperatorPermissions)\n    {\n        // Keep a reference to the custom split operator permissions.\n        uint256[] memory customSplitOperatorPermissionIndexes = _extraOperatorPermissions[revnetId];\n\n        // Keep a reference to the number of custom permissions.\n        uint256 numberOfCustomPermissionIndexes = customSplitOperatorPermissionIndexes.length;\n\n        // Make the array that merges the default and custom operator permissions.\n        allOperatorPermissions = new uint256[](3 + numberOfCustomPermissionIndexes);\n        allOperatorPermissions[0] = JBPermissionIds.SET_SPLIT_GROUPS;\n        allOperatorPermissions[1] = JBPermissionIds.SET_BUYBACK_POOL;\n        allOperatorPermissions[2] = JBPermissionIds.SET_PROJECT_URI;\n\n        // Copy the custom permissions into the array.\n        for (uint256 i; i < numberOfCustomPermissionIndexes; i++) {\n            allOperatorPermissions[3 + i] = customSplitOperatorPermissionIndexes[i];\n        }\n    }\n\n    /// @notice Converts a `uint256` array to a `uint8` array.\n    /// @param array The array to convert.\n    /// @return result The converted array.\n    function _uint256ArrayToUint8Array(uint256[] memory array) internal pure returns (uint8[] memory result) {\n        result = new uint8[](array.length);\n        for (uint256 i; i < array.length; i++) {\n            result[i] = uint8(array[i]);\n        }\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param controller The controller to use for launching and operating the Juicebox projects which will be revnets.\n    /// @param suckerRegistry The registry to use for deploying and tracking each revnet's suckers.\n    /// @param feeRevnetId The Juicebox project ID of the revnet that will receive fees.\n    /// @param hookDeployer The deployer to use for revnet's tiered ERC-721 hooks.\n    /// @param publisher The croptop publisher revnets can use to publish ERC-721 posts to their tiered ERC-721 hooks.\n    constructor(\n        IJBController controller,\n        IJBSuckerRegistry suckerRegistry,\n        uint256 feeRevnetId,\n        IJB721TiersHookDeployer hookDeployer,\n        CTPublisher publisher\n    ) {\n        CONTROLLER = controller;\n        DIRECTORY = controller.DIRECTORY();\n        PROJECTS = controller.PROJECTS();\n        PERMISSIONS = IJBPermissioned(address(CONTROLLER)).PERMISSIONS();\n        SUCKER_REGISTRY = suckerRegistry;\n        FEE_REVNET_ID = feeRevnetId;\n        HOOK_DEPLOYER = hookDeployer;\n        PUBLISHER = publisher;\n\n        // Give the sucker registry permission to map tokens for all revnets.\n        _setPermission({operator: address(SUCKER_REGISTRY), revnetId: 0, permissionId: JBPermissionIds.MAP_SUCKER_TOKEN});\n    }\n\n    //*********************************************************************//\n    // --------------------- external transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Processes the cashout fee from a redemption.\n    /// @param context Redemption context passed in by the terminal.\n    function afterRedeemRecordedWith(JBAfterRedeemRecordedContext memory context) external payable {\n        // Only the revnet's payment terminals can access this function.\n        if (!DIRECTORY.isTerminalOf(context.projectId, IJBTerminal(msg.sender))) {\n            revert REVDeployer_Unauthorized();\n        }\n\n        // Parse the metadata forwarded from the data hook to get the fee terminal.\n        // See `beforeRedeemRecordedWith()`.\n        (IJBTerminal feeTerminal) = abi.decode(context.hookMetadata, (IJBTerminal));\n\n        // Determine how much to pay in `msg.value` (in the native currency).\n        uint256 payValue = context.forwardedAmount.token == JBConstants.NATIVE_TOKEN ? context.forwardedAmount.value : 0;\n\n        // Pay the fee.\n        // slither-disable-next-line arbitrary-send-eth,unused-return\n        try feeTerminal.pay{value: payValue}({\n            projectId: FEE_REVNET_ID,\n            token: context.forwardedAmount.token,\n            amount: context.forwardedAmount.value,\n            beneficiary: context.holder,\n            minReturnedTokens: 0,\n            memo: \"\",\n            metadata: bytes(abi.encodePacked(context.projectId))\n        }) {} catch (bytes memory) {\n            // If the fee can't be processed, return the funds to the project.\n            // slither-disable-next-line arbitrary-send-eth\n            IJBTerminal(msg.sender).addToBalanceOf{value: payValue}({\n                projectId: context.projectId,\n                token: context.forwardedAmount.token,\n                amount: context.forwardedAmount.value,\n                shouldReturnHeldFees: false,\n                memo: \"\",\n                metadata: bytes(abi.encodePacked(FEE_REVNET_ID))\n            });\n        }\n    }\n\n    /// @notice Auto-mint a revnet's tokens from a stage for a beneficiary.\n    /// @param revnetId The ID of the revnet to auto-mint tokens from.\n    /// @param stageId The ID of the stage auto-mint tokens are available from.\n    /// @param beneficiary The address to auto-mint tokens to.\n    function autoMintFor(uint256 revnetId, uint256 stageId, address beneficiary) external override {\n        // Make sure the stage has started.\n        if (CONTROLLER.RULESETS().getRulesetOf(revnetId, stageId).start > block.timestamp) {\n            revert REVDeployer_StageNotStarted();\n        }\n\n        // Get a reference to the number of tokens to auto-mint.\n        uint256 count = amountToAutoMint[revnetId][stageId][beneficiary];\n\n        // If there's nothing to auto-mint, return.\n        if (count == 0) return;\n\n        // Reset the auto-mint amount.\n        amountToAutoMint[revnetId][stageId][beneficiary] = 0;\n\n        // Decrease the amount of unrealized auto-mint tokens.\n        unrealizedAutoMintAmountOf[revnetId] -= count;\n\n        emit Mint(revnetId, stageId, beneficiary, count, msg.sender);\n\n        // Mint the tokens.\n        _mintTokensOf({revnetId: revnetId, tokenCount: count, beneficiary: beneficiary});\n    }\n\n    /// @notice Launch a revnet, or convert an existing Juicebox project into a revnet.\n    /// @param revnetId The ID of the Juicebox project to turn into a revnet. Send 0 to deploy a new revnet.\n    /// @param configuration Core revnet configuration. See `REVConfig`.\n    /// @param terminalConfigurations The terminals to set up for the revnet. Used for payments and redemptions.\n    /// @param buybackHookConfiguration The buyback hook and pools to set up for the revnet.\n    /// The buyback hook buys tokens from a Uniswap pool if minting new tokens would be more expensive.\n    /// @param suckerDeploymentConfiguration The suckers to set up for the revnet. Suckers facilitate cross-chain\n    /// token transfers between peer revnets on different networks.\n    /// @return revnetId The ID of the newly created revnet.\n    function deployFor(\n        uint256 revnetId,\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration\n    )\n        external\n        override\n        returns (uint256)\n    {\n        // Deploy the revnet.\n        return _launchRevnetFor({\n            revnetId: revnetId,\n            configuration: configuration,\n            terminalConfigurations: terminalConfigurations,\n            buybackHookConfiguration: buybackHookConfiguration,\n            suckerDeploymentConfiguration: suckerDeploymentConfiguration\n        });\n    }\n\n    /// @notice Deploy new suckers for an existing revnet.\n    /// @dev Only the revnet's split operator can deploy new suckers.\n    /// @param revnetId The ID of the revnet to deploy suckers for.\n    /// @param encodedConfiguration A byte-encoded representation of the revnet's configuration.\n    /// See `_makeRulesetConfigurations()` for encoding details. Clients can read the encoded configuration\n    /// from the `DeployRevnet` event emitted by this contract.\n    /// @param suckerDeploymentConfiguration The suckers to set up for the revnet.\n    function deploySuckersFor(\n        uint256 revnetId,\n        bytes memory encodedConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration\n    )\n        external\n        override\n        returns (address[] memory suckers)\n    {\n        // Make sure the caller is the revnet's split operator.\n        _checkIfIsSplitOperatorOf({revnetId: revnetId, operator: msg.sender});\n\n        // Deploy the suckers.\n        suckers = _deploySuckersFor({\n            revnetId: revnetId,\n            operator: msg.sender,\n            encodedConfiguration: encodedConfiguration,\n            suckerDeploymentConfiguration: suckerDeploymentConfiguration\n        });\n    }\n\n    /// @notice Launch a revnet which sells tiered ERC-721s and (optionally) allows croptop posts to its ERC-721 tiers.\n    /// @param revnetId The ID of the Juicebox project to turn into a revnet. Send 0 to deploy a new revnet.\n    /// @param configuration Core revnet configuration. See `REVConfig`.\n    /// @param terminalConfigurations The terminals to set up for the revnet. Used for payments and redemptions.\n    /// @param buybackHookConfiguration The buyback hook and pools to set up for the revnet.\n    /// The buyback hook buys tokens from a Uniswap pool if minting new tokens would be more expensive.\n    /// @param suckerDeploymentConfiguration The suckers to set up for the revnet. Suckers facilitate cross-chain\n    /// token transfers between peer revnets on different networks.\n    /// @param tiered721HookConfiguration How to set up the tiered ERC-721 hook for the revnet.\n    /// @param allowedPosts Restrictions on which croptop posts are allowed on the revnet's ERC-721 tiers.\n    /// @return revnetId The ID of the newly created revnet.\n    /// @return hook The address of the tiered ERC-721 hook that was deployed for the revnet.\n    function deployWith721sFor(\n        uint256 revnetId,\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration,\n        REVDeploy721TiersHookConfig memory tiered721HookConfiguration,\n        REVCroptopAllowedPost[] memory allowedPosts\n    )\n        external\n        override\n        returns (uint256, IJB721TiersHook hook)\n    {\n        // Deploy the revnet with the specified tiered ERC-721 hook and croptop posting criteria.\n        (revnetId, hook) = _launch721RevnetFor({\n            revnetId: revnetId,\n            configuration: configuration,\n            terminalConfigurations: terminalConfigurations,\n            buybackHookConfiguration: buybackHookConfiguration,\n            suckerDeploymentConfiguration: suckerDeploymentConfiguration,\n            tiered721HookConfiguration: tiered721HookConfiguration,\n            allowedPosts: allowedPosts\n        });\n\n        return (revnetId, hook);\n    }\n\n    /// @notice Change a revnet's split operator.\n    /// @dev Only a revnet's current split operator can set a new split operator.\n    /// @param revnetId The ID of the revnet to set the split operator of.\n    /// @param newSplitOperator The new split operator's address.\n    function setSplitOperatorOf(uint256 revnetId, address newSplitOperator) external override {\n        // Enforce permissions.\n        _checkIfIsSplitOperatorOf({revnetId: revnetId, operator: msg.sender});\n\n        emit ReplaceSplitOperator(revnetId, newSplitOperator, msg.sender);\n\n        // Remove operator permissions from the old split operator.\n        _setPermissionsFor({\n            account: address(this),\n            operator: msg.sender,\n            revnetId: uint56(revnetId),\n            permissionIds: new uint8[](0)\n        });\n\n        // Set the new split operator.\n        _setSplitOperatorOf({revnetId: revnetId, operator: newSplitOperator});\n    }\n\n    //*********************************************************************//\n    // --------------------- internal transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Configure croptop posting.\n    /// @param hook The hook that will be posted to.\n    /// @param allowedPosts The type of posts that the revent should allow.\n    /// @return flag A flag indicating if posts were configured. Returns false if there were no posts to set up.\n    function _configurePostingCriteriaFor(\n        address hook,\n        REVCroptopAllowedPost[] memory allowedPosts\n    )\n        internal\n        returns (bool)\n    {\n        // Keep a reference to the number of allowed posts.\n        uint256 numberOfAllowedPosts = allowedPosts.length;\n\n        // If there are no posts to allow, return.\n        if (numberOfAllowedPosts == 0) return false;\n\n        // Keep a reference to the formatted allowed posts.\n        CTAllowedPost[] memory formattedAllowedPosts = new CTAllowedPost[](numberOfAllowedPosts);\n\n        // Keep a reference to the post being iterated on.\n        REVCroptopAllowedPost memory post;\n\n        // Iterate through each post to add it to the formatted list.\n        for (uint256 i; i < numberOfAllowedPosts; i++) {\n            // Set the post being iterated on.\n            post = allowedPosts[i];\n\n            // Set the formatted post.\n            formattedAllowedPosts[i] = CTAllowedPost({\n                hook: hook,\n                category: post.category,\n                minimumPrice: post.minimumPrice,\n                minimumTotalSupply: post.minimumTotalSupply,\n                maximumTotalSupply: post.maximumTotalSupply,\n                allowedAddresses: post.allowedAddresses\n            });\n        }\n\n        // Set up the allowed posts in the publisher.\n        PUBLISHER.configurePostingCriteriaFor({allowedPosts: formattedAllowedPosts});\n\n        return true;\n    }\n\n    /// @notice Deploy suckers for a revnet.\n    /// @param revnetId The ID of the revnet to deploy suckers for.\n    /// @param operator The address of the operator that can add new suckers in the future.\n    /// @param encodedConfiguration A byte-encoded representation of the revnet's configuration.\n    /// See `_makeRulesetConfigurations()` for encoding details. Clients can read the encoded configuration\n    /// from the `DeployRevnet` event emitted by this contract.\n    /// @param suckerDeploymentConfiguration The suckers to set up for the revnet.\n    function _deploySuckersFor(\n        uint256 revnetId,\n        address operator,\n        bytes memory encodedConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration\n    )\n        internal\n        returns (address[] memory suckers)\n    {\n        // Compose the salt.\n        bytes32 salt = keccak256(abi.encode(operator, encodedConfiguration, suckerDeploymentConfiguration.salt));\n\n        emit DeploySuckers(revnetId, operator, salt, encodedConfiguration, suckerDeploymentConfiguration, msg.sender);\n\n        // Deploy the suckers.\n        // slither-disable-next-line unused-return\n        suckers = SUCKER_REGISTRY.deploySuckersFor({\n            projectId: revnetId,\n            salt: salt,\n            configurations: suckerDeploymentConfiguration.deployerConfigurations\n        });\n    }\n\n    /// @notice Launch a revnet which sells tiered ERC-721s and (optionally) allows croptop posts to its ERC-721 tiers.\n    /// @param revnetId The ID of the Juicebox project to turn into a revnet. Send 0 to deploy a new revnet.\n    /// @param configuration Core revnet configuration. See `REVConfig`.\n    /// @param terminalConfigurations The terminals to set up for the revnet. Used for payments and redemptions.\n    /// @param buybackHookConfiguration The buyback hook and pools to set up for the revnet.\n    /// The buyback hook buys tokens from a Uniswap pool if minting new tokens would be more expensive.\n    /// @param suckerDeploymentConfiguration The suckers to set up for the revnet. Suckers facilitate cross-chain\n    /// token transfers between peer revnets on different networks.\n    /// @param tiered721HookConfiguration How to set up the tiered ERC-721 hook for the revnet.\n    /// @param allowedPosts Restrictions on which croptop posts are allowed on the revnet's ERC-721 tiers.\n    /// @return revnetId The ID of the newly created revnet.\n    /// @return hook The address of the tiered ERC-721 hook that was deployed for the revnet.\n    function _launch721RevnetFor(\n        uint256 revnetId,\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration,\n        REVDeploy721TiersHookConfig memory tiered721HookConfiguration,\n        REVCroptopAllowedPost[] memory allowedPosts\n    )\n        internal\n        returns (uint256, IJB721TiersHook hook)\n    {\n        // Keep a reference to the revnet ID which was passed in.\n        uint256 originalRevnetId = revnetId;\n\n        // If the caller is deploying a new revnet, calculate its ID\n        // (which will be 1 greater than the current count).\n        if (originalRevnetId == 0) revnetId = PROJECTS.count() + 1;\n\n        // Deploy the tiered ERC-721 hook contract.\n        // slither-disable-next-line reentrancy-benign\n        hook = HOOK_DEPLOYER.deployHookFor(revnetId, tiered721HookConfiguration.baseline721HookConfiguration);\n\n        // Store the tiered ERC-721 hook.\n        tiered721HookOf[revnetId] = hook;\n\n        // If specified, give the split operator permission to add and remove tiers.\n        if (tiered721HookConfiguration.splitOperatorCanAdjustTiers) {\n            _extraOperatorPermissions[revnetId].push(JBPermissionIds.ADJUST_721_TIERS);\n        }\n\n        // If specified, give the split operator permission to set ERC-721 tier metadata.\n        if (tiered721HookConfiguration.splitOperatorCanUpdateMetadata) {\n            _extraOperatorPermissions[revnetId].push(JBPermissionIds.SET_721_METADATA);\n        }\n\n        // If specified, give the split operator permission to mint ERC-721s (without a payment)\n        // from tiers with `allowOwnerMint` set to true.\n        if (tiered721HookConfiguration.splitOperatorCanMint) {\n            _extraOperatorPermissions[revnetId].push(JBPermissionIds.MINT_721);\n        }\n\n        // If specified, give the split operator permission to increase the discount of a tier.\n        if (tiered721HookConfiguration.splitOperatorCanIncreaseDiscountPercent) {\n            _extraOperatorPermissions[revnetId].push(JBPermissionIds.SET_721_DISCOUNT_PERCENT);\n        }\n\n        // Set up croptop posting criteria as specified.\n        if (_configurePostingCriteriaFor({hook: address(hook), allowedPosts: allowedPosts})) {\n            // Give the croptop publisher permission to post new ERC-721 tiers on this contract's behalf.\n            _setPermission({\n                operator: address(PUBLISHER),\n                revnetId: revnetId,\n                permissionId: JBPermissionIds.ADJUST_721_TIERS\n            });\n        }\n\n        _launchRevnetFor({\n            revnetId: originalRevnetId,\n            configuration: configuration,\n            terminalConfigurations: terminalConfigurations,\n            buybackHookConfiguration: buybackHookConfiguration,\n            suckerDeploymentConfiguration: suckerDeploymentConfiguration\n        });\n\n        return (revnetId, hook);\n    }\n\n    /// @notice Launch a revnet, or convert an existing Juicebox project into a revnet.\n    /// @param revnetId The ID of the Juicebox project to turn into a revnet. Send 0 to deploy a new revnet.\n    /// @param configuration Core revnet configuration. See `REVConfig`.\n    /// @param terminalConfigurations The terminals to set up for the revnet. Used for payments and redemptions.\n    /// @param buybackHookConfiguration The buyback hook and pools to set up for the revnet.\n    /// The buyback hook buys tokens from a Uniswap pool if minting new tokens would be more expensive.\n    /// @param suckerDeploymentConfiguration The suckers to set up for the revnet. Suckers facilitate cross-chain\n    /// token transfers between peer revnets on different networks.\n    /// @return revnetId The ID of the newly created revnet.\n    function _launchRevnetFor(\n        uint256 revnetId,\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration\n    )\n        internal\n        returns (uint256)\n    {\n        // Normalize and encode the configurations.\n        (JBRulesetConfig[] memory rulesetConfigurations, bytes memory encodedConfiguration) =\n            _makeRulesetConfigurations(configuration);\n\n        if (revnetId == 0) {\n            // If we're deploying a new revnet, launch a Juicebox project for it.\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            revnetId = CONTROLLER.launchProjectFor({\n                owner: address(this),\n                projectUri: configuration.description.uri,\n                rulesetConfigurations: rulesetConfigurations,\n                terminalConfigurations: terminalConfigurations,\n                memo: \"\"\n            });\n        } else {\n            // If we're converting an existing Juicebox project into a revnet,\n            // transfer the `JBProjects` NFT to this deployer.\n            IERC721(PROJECTS).safeTransferFrom(PROJECTS.ownerOf(revnetId), address(this), revnetId);\n\n            // Launch the revnet rulesets for the pre-existing project.\n            // slither-disable-next-line unused-return\n            CONTROLLER.launchRulesetsFor({\n                projectId: revnetId,\n                rulesetConfigurations: rulesetConfigurations,\n                terminalConfigurations: terminalConfigurations,\n                memo: \"\"\n            });\n        }\n\n        // Store the cashout delay of the revnet if its stages are already in progress.\n        // This prevents cashout liquidity/arbitrage issues for existing revnets which\n        // are deploying to a new chain.\n        _setCashOutDelayIfNeeded(revnetId, configuration.stageConfigurations[0]);\n\n        // Deploy the revnet's ERC-20 token.\n        // slither-disable-next-line unused-return\n        CONTROLLER.deployERC20For({\n            projectId: revnetId,\n            name: configuration.description.name,\n            symbol: configuration.description.ticker,\n            salt: configuration.description.salt\n        });\n\n        // If specified, set up the buyback hook.\n        if (buybackHookConfiguration.hook != IJBBuybackHook(address(0))) {\n            _setupBuybackHookOf(revnetId, buybackHookConfiguration);\n        }\n\n        // If specified, set up the loan contract.\n        if (configuration.loans != address(0)) {\n            _setPermission({\n                operator: address(configuration.loans),\n                revnetId: revnetId,\n                permissionId: JBPermissionIds.USE_ALLOWANCE\n            });\n            loansOf[revnetId] = configuration.loans;\n        }\n\n        // Set up the reserved token split group under the default ruleset (0).\n        // This split group sends the revnet's reserved tokens to the split operator,\n        // who can allocate splits to other recipients later on.\n        CONTROLLER.setSplitGroupsOf({\n            projectId: revnetId,\n            rulesetId: 0,\n            splitGroups: _makeOperatorSplitGroupWith(configuration.splitOperator)\n        });\n\n        // Store the auto-mint amounts.\n        _storeAutomintAmounts(revnetId, configuration);\n\n        // Give the split operator their permissions.\n        _setSplitOperatorOf({revnetId: revnetId, operator: configuration.splitOperator});\n\n        // Deploy the suckers (if applicable).\n        if (suckerDeploymentConfiguration.salt != bytes32(0)) {\n            _deploySuckersFor({\n                revnetId: revnetId,\n                operator: configuration.splitOperator,\n                encodedConfiguration: encodedConfiguration,\n                suckerDeploymentConfiguration: suckerDeploymentConfiguration\n            });\n        }\n\n        emit DeployRevnet(\n            revnetId,\n            configuration,\n            terminalConfigurations,\n            buybackHookConfiguration,\n            suckerDeploymentConfiguration,\n            rulesetConfigurations,\n            encodedConfiguration,\n            msg.sender\n        );\n\n        return revnetId;\n    }\n\n    /// @notice Mints a revnet's tokens.\n    /// @param revnetId The ID of the revnet to mint tokens for.\n    /// @param tokenCount The number of tokens to mint.\n    /// @param beneficiary The address to send the tokens to.\n    function _mintTokensOf(uint256 revnetId, uint256 tokenCount, address beneficiary) internal {\n        // slither-disable-next-line unused-return\n        CONTROLLER.mintTokensOf({\n            projectId: revnetId,\n            tokenCount: tokenCount,\n            beneficiary: beneficiary,\n            memo: \"\",\n            useReservedPercent: false\n        });\n    }\n\n    /// @notice Sets the cash out delay if the revnet's stages are already in progress.\n    /// @dev This prevents cashout liquidity/arbitrage issues for existing revnets which\n    /// are deploying to a new chain.\n    /// @param revnetId The ID of the revnet to set the cash out delay for.\n    /// @param firstStageConfig The revnet's first stage.\n    function _setCashOutDelayIfNeeded(uint256 revnetId, REVStageConfig memory firstStageConfig) internal {\n        // If this is the first revnet being deployed (with a `startsAtOrAfter` of 0),\n        // or if the first stage hasn't started yet, we don't need to set a cashout delay.\n        if (firstStageConfig.startsAtOrAfter == 0 || firstStageConfig.startsAtOrAfter >= block.timestamp) return;\n\n        // Calculate the timestamp at which the cashout delay ends.\n        uint256 cashOutDelay = block.timestamp + CASH_OUT_DELAY;\n\n        // Store the cashout delay.\n        cashOutDelayOf[revnetId] = cashOutDelay;\n\n        emit SetCashOutDelay(revnetId, cashOutDelay, msg.sender);\n    }\n\n    /// @notice Grants a permission to an address (an \"operator\").\n    /// @param operator The address to give the permission to.\n    /// @param revnetId The ID of the revnet to scope the permission for.\n    /// @param permissionId The ID of the permission to set. See `JBPermissionIds`.\n    function _setPermission(address operator, uint256 revnetId, uint8 permissionId) internal {\n        uint8[] memory permissionsIds = new uint8[](1);\n        permissionsIds[0] = permissionId;\n\n        // Give the operator the permission.\n        _setPermissionsFor({\n            account: address(this),\n            operator: operator,\n            revnetId: revnetId,\n            permissionIds: permissionsIds\n        });\n    }\n\n    /// @notice Grants a permission to an address (an \"operator\").\n    /// @param account The account granting the permission.\n    /// @param operator The address to give the permission to.\n    /// @param revnetId The ID of the revnet to scope the permission for.\n    /// @param permissionIds An array of permission IDs to set. See `JBPermissionIds`.\n    function _setPermissionsFor(\n        address account,\n        address operator,\n        uint256 revnetId,\n        uint8[] memory permissionIds\n    )\n        internal\n    {\n        // Set up the permission data.\n        JBPermissionsData memory permissionData =\n            JBPermissionsData({operator: operator, projectId: uint56(revnetId), permissionIds: permissionIds});\n\n        // Set the permissions.\n        PERMISSIONS.setPermissionsFor({account: account, permissionsData: permissionData});\n    }\n\n    /// @notice Give a split operator their permissions.\n    /// @dev Only a revnet's current split operator can set a new split operator, by calling `setSplitOperatorOf()`.\n    /// @param revnetId The ID of the revnet to set the split operator of.\n    /// @param operator The new split operator's address.\n    function _setSplitOperatorOf(uint256 revnetId, address operator) internal {\n        _setPermissionsFor({\n            account: address(this),\n            operator: operator,\n            revnetId: uint56(revnetId),\n            permissionIds: _uint256ArrayToUint8Array(_splitOperatorPermissionIndexesOf(revnetId))\n        });\n    }\n\n    /// @notice Sets up a buyback hook and pools for a revnet.\n    /// @param revnetId The ID of the revnet to set up the buyback hook for.\n    /// @param buybackHookConfiguration The address of the hook and a list of pools to use for buybacks.\n    function _setupBuybackHookOf(uint256 revnetId, REVBuybackHookConfig memory buybackHookConfiguration) internal {\n        // Get a reference to the number of pools being set up.\n        uint256 numberOfPoolsToSetup = buybackHookConfiguration.poolConfigurations.length;\n\n        // Keep a reference to the pool being iterated on.\n        REVBuybackPoolConfig memory poolConfig;\n\n        // Store the buyback hook.\n        buybackHookOf[revnetId] = buybackHookConfiguration.hook;\n\n        for (uint256 i; i < numberOfPoolsToSetup; i++) {\n            // Set the pool being iterated on.\n            poolConfig = buybackHookConfiguration.poolConfigurations[i];\n\n            // Register the pool within the buyback contract.\n            // slither-disable-next-line unused-return\n            buybackHookConfiguration.hook.setPoolFor({\n                projectId: revnetId,\n                fee: poolConfig.fee,\n                twapWindow: poolConfig.twapWindow,\n                twapSlippageTolerance: poolConfig.twapSlippageTolerance,\n                terminalToken: poolConfig.token\n            });\n        }\n    }\n\n    /// @notice Stores the auto-mint amounts for each of a revnet's stages.\n    /// @param revnetId The ID of the revnet to store the auto-mint amounts for.\n    /// @param configuration The revnet's configuration. See `REVConfig`.\n    function _storeAutomintAmounts(uint256 revnetId, REVConfig memory configuration) internal {\n        // Keep a reference to the number of stages the revnet has.\n        uint256 numberOfStages = configuration.stageConfigurations.length;\n\n        // Keep a reference to the stage configuration being iterated on.\n        REVStageConfig memory stageConfiguration;\n\n        // Keep a reference to the total amount of tokens which can be auto-minted.\n        uint256 totalUnrealizedAutoMintAmount;\n\n        // Loop through each stage to store its auto-mint amounts.\n        for (uint256 i; i < numberOfStages; i++) {\n            // Set the stage configuration being iterated on.\n            stageConfiguration = configuration.stageConfigurations[i];\n\n            // Keep a reference to the number of mints to store.\n            uint256 numberOfMints = stageConfiguration.autoMints.length;\n\n            // Keep a reference to the mint config being iterated on.\n            REVAutoMint memory mintConfig;\n\n            // Loop through each mint to store its amount.\n            for (uint256 j; j < numberOfMints; j++) {\n                // Set the mint config being iterated on.\n                mintConfig = stageConfiguration.autoMints[j];\n\n                // If the mint config is for another chain, skip it.\n                if (mintConfig.chainId != block.chainid) continue;\n\n                // If the auto-mint is for the first stage, or a stage which has already started,\n                // mint the tokens right away.\n                if (i == 0 || stageConfiguration.startsAtOrAfter <= block.timestamp) {\n                    emit Mint(revnetId, block.timestamp + i, mintConfig.beneficiary, mintConfig.count, msg.sender);\n\n                    // slither-disable-next-line reentrancy-events,reentrancy-no-eth,reentrancy-benign\n                    _mintTokensOf({\n                        revnetId: revnetId,\n                        tokenCount: mintConfig.count,\n                        beneficiary: mintConfig.beneficiary\n                    });\n                }\n                // Otherwise, store the amount of tokens that can be auto-minted on this chain during this stage.\n                else {\n                    emit StoreAutoMintAmount(\n                        revnetId, block.timestamp + i, mintConfig.beneficiary, mintConfig.count, msg.sender\n                    );\n\n                    // The first stage ID is stored at this block's timestamp,\n                    // and further stage IDs have incrementally increasing IDs\n                    // slither-disable-next-line reentrancy-events\n                    amountToAutoMint[revnetId][block.timestamp + i][mintConfig.beneficiary] += mintConfig.count;\n\n                    // Add to the total unrealized auto-mint amount.\n                    totalUnrealizedAutoMintAmount += mintConfig.count;\n                }\n            }\n        }\n\n        // Store the unrealized auto-mint amount.\n        unrealizedAutoMintAmountOf[revnetId] = totalUnrealizedAutoMintAmount;\n    }\n}\n"
			}
		}
	}
}