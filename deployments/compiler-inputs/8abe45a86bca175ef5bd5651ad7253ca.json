{
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23+commit.f704f362",
	"id": "8abe45a86bca175ef5bd5651ad7253ca",
	"input": {
		"language": "Solidity",
		"settings": {
			"viaIR": false,
			"optimizer": {
				"runs": 100000000,
				"enabled": true
			},
			"metadata": {
				"useLiteralContent": false,
				"bytecodeHash": "ipfs",
				"appendCBOR": true
			},
			"outputSelection": {
				"*": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				}
			},
			"evmVersion": "paris",
			"libraries": {},
			"remappings": [
				"@sphinx-labs/contracts/=node_modules/@sphinx-labs/contracts/contracts/foundry/",
				"@arbitrum/=node_modules/@arbitrum/",
				"@bananapus/=node_modules/@bananapus/",
				"@chainlink/=node_modules/@chainlink/",
				"@croptop/=node_modules/@croptop/",
				"@eth-optimism/=node_modules/@eth-optimism/",
				"@exhausted-pigeon/=node_modules/@exhausted-pigeon/",
				"@gnosis.pm/=node_modules/@gnosis.pm/",
				"@offchainlabs/=node_modules/@offchainlabs/",
				"@openzeppelin/=node_modules/@openzeppelin/",
				"@prb/=node_modules/@prb/",
				"@uniswap/=node_modules/@uniswap/",
				"base64-sol/=node_modules/base64-sol/",
				"ds-test/=lib/forge-std/lib/ds-test/src/",
				"forge-std/=lib/forge-std/src/",
				"hardhat/=node_modules/hardhat/",
				"solmate/=node_modules/solmate/",
				"sphinx-forge-std/=node_modules/sphinx-forge-std/",
				"sphinx-solmate/=node_modules/sphinx-solmate/",
				"sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"
			]
		},
		"sources": {
			"node_modules/@bananapus/buyback-hook/src/interfaces/IJBBuybackHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPayHook} from \"@bananapus/core/src/interfaces/IJBPayHook.sol\";\nimport {IJBRulesetDataHook} from \"@bananapus/core/src/interfaces/IJBRulesetDataHook.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IUniswapV3SwapCallback} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\nimport {IWETH9} from \"./external/IWETH9.sol\";\n\ninterface IJBBuybackHook is IJBPayHook, IJBRulesetDataHook, IUniswapV3SwapCallback {\n    event Swap(uint256 indexed projectId, uint256 amountIn, IUniswapV3Pool pool, uint256 amountOut, address caller);\n    event Mint(uint256 indexed projectId, uint256 amountIn, uint256 tokenCount, address caller);\n    event TwapWindowChanged(uint256 indexed projectId, uint256 oldSecondsAgo, uint256 newSecondsAgo, address caller);\n    event TwapSlippageToleranceChanged(\n        uint256 indexed projectId, uint256 oldTwapTolerance, uint256 newTwapTolerance, address caller\n    );\n    event PoolAdded(uint256 indexed projectId, address indexed terminalToken, address newPool, address caller);\n\n    function TWAP_SLIPPAGE_DENOMINATOR() external view returns (uint256);\n\n    function MIN_TWAP_SLIPPAGE_TOLERANCE() external view returns (uint256);\n\n    function MAX_TWAP_SLIPPAGE_TOLERANCE() external view returns (uint256);\n\n    function MIN_TWAP_WINDOW() external view returns (uint256);\n\n    function MAX_TWAP_WINDOW() external view returns (uint256);\n\n    function UNISWAP_V3_FACTORY() external view returns (address);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n\n    function CONTROLLER() external view returns (IJBController);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function WETH() external view returns (IWETH9);\n\n    function poolOf(uint256 projectId, address terminalToken) external view returns (IUniswapV3Pool pool);\n\n    function twapWindowOf(uint256 projectId) external view returns (uint32 window);\n\n    function twapSlippageToleranceOf(uint256 projectId) external view returns (uint256 slippageTolerance);\n\n    function projectTokenOf(uint256 projectId) external view returns (address projectTokenOf);\n\n    function setPoolFor(\n        uint256 projectId,\n        uint24 fee,\n        uint32 twapWindow,\n        uint256 twapSlippageTolerance,\n        address terminalToken\n    )\n        external\n        returns (IUniswapV3Pool newPool);\n\n    function setTwapWindowOf(uint256 projectId, uint32 newWindow) external;\n\n    function setTwapSlippageToleranceOf(uint256 projectId, uint256 newSlippageTolerance) external;\n}\n"
			},
			"node_modules/@bananapus/buyback-hook/src/interfaces/external/IWETH9.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBControlled.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\n\ninterface IJBControlled {\n    function DIRECTORY() external view returns (IJBDirectory);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBMigratable} from \"./IJBMigratable.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string metadata, string memo, address caller);\n\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address beneficiary,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        address caller\n    );\n\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed group,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedRate,\n        address caller\n    );\n\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 amount, bytes reason, address caller\n    );\n\n    event MigrateController(uint256 indexed projectId, IJBMigratable to, address caller);\n\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n\n    event SetMetadata(uint256 indexed projectId, string metadata, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n\n    function RULESETS() external view returns (IJBRulesets);\n\n    function TOKENS() external view returns (IJBTokens);\n\n    function SPLITS() external view returns (IJBSplits);\n\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedRate\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n\n    function sendReservedTokensToSplitsOf(uint256 projectId, string memory memo) external returns (uint256);\n\n    function migrateController(uint256 projectId, IJBMigratable to) external;\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n\n    function setTokenFor(uint256 _projectId, IJBToken _token) external;\n\n    function claimTokensFor(address holder, uint256 projectId, uint256 amount, address beneficiary) external;\n\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 amount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IJBTerminal} from \"./terminal/IJBTerminal.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBDirectory {\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed flag, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\n\ninterface IJBFundAccessLimits is IERC165 {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId, uint256 indexed projectId, JBFundAccessLimitGroup limits, address caller\n    );\n\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessConstaints\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBMigratable.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IJBMigratable is IERC165 {\n    function receiveMigrationFrom(IERC165 from, uint256 projectId) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint256[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata metadata) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n\n    function setTokenUriResolver(IJBTokenUriResolver newResolver) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRedeemHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {JBAfterRedeemRecordedContext} from \"./../structs/JBAfterRedeemRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `redeemTokensOf(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBRedeemHook is IERC165 {\n    /// @notice This function is called by the terminal's `redeemTokensOf(...)` function after the redemption has been\n    /// recorded in the terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterRedeemRecordedContext` struct.\n    function afterRedeemRecordedWith(JBAfterRedeemRecordedContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 start\n    )\n        external\n        view\n        returns (JBApprovalStatus);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesetDataHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\nimport {JBBeforePayRecordedContext} from \"./../structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeRedeemRecordedContext} from \"./../structs/JBBeforeRedeemRecordedContext.sol\";\nimport {JBRedeemHookSpecification} from \"./../structs/JBRedeemHookSpecification.sol\";\n\n/// @notice Data hooks can extend a terminal's core pay/redeem functionality by overriding the weight or memo. They can\n/// also specify pay/redeem hooks for the terminal to fulfill, or allow addresses to mint a project's tokens on-demand.\n/// @dev If a project's ruleset has `useDataHookForPay` or `useDataHookForRedeem` enabled, its `dataHook` is called by\n/// the terminal upon payments/redemptions (respectively).\ninterface IJBRulesetDataHook is IERC165 {\n    /// @notice A flag indicating whether an address has permission to mint a project's tokens on-demand.\n    /// @dev A project's data hook can allow any address to mint its tokens.\n    /// @param projectId The ID of the project whose token can be minted.\n    /// @param addr The address to check the token minting permission of.\n    /// @return flag A flag indicating whether the address has permission to mint the project's tokens on-demand.\n    function hasMintPermissionFor(uint256 projectId, address addr) external view returns (bool flag);\n\n    /// @notice The data calculated before a payment is recorded in the terminal store. This data is provided to the\n    /// terminal's `pay(...)` transaction.\n    /// @param context The context passed to this data hook by the `pay(...)` function as a `JBBeforePayRecordedContext`\n    /// struct.\n    /// @return weight The new `weight` to use, overriding the ruleset's `weight`.\n    /// @return hookSpecifications The amount and data to send to pay hooks instead of adding to the terminal's balance.\n    function beforePayRecordedWith(JBBeforePayRecordedContext calldata context)\n        external\n        view\n        returns (uint256 weight, JBPayHookSpecification[] memory hookSpecifications);\n\n    /// @notice The data calculated before a redemption is recorded in the terminal store. This data is provided to the\n    /// terminal's `redeemTokensOf(...)` transaction.\n    /// @param context The context passed to this data hook by the `redeemTokensOf(...)` function as a\n    /// `JBBeforeRedeemRecordedContext` struct.\n    /// @return redemptionRate The rate determining the amount that should be reclaimable for a given surplus and token\n    /// supply.\n    /// @return redeemCount The amount of tokens that should be considered redeemed.\n    /// @return totalSupply The total amount of tokens that are considered to be existing.\n    /// @return hookSpecifications The amount and data to send to redeem hooks instead of returning to the beneficiary.\n    function beforeRedeemRecordedWith(JBBeforeRedeemRecordedContext calldata context)\n        external\n        view\n        returns (\n            uint256 redemptionRate,\n            uint256 redeemCount,\n            uint256 totalSupply,\n            JBRedeemHookSpecification[] memory hookSpecifications\n        );\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBControlled} from \"./IJBControlled.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets is IJBControlled {\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayRate,\n        IJBRulesetApprovalHook hook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    event RulesetInitialized(uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId);\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n\n    function upcomingRulesetOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayRate,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBControlled} from \"./IJBControlled.sol\";\n\ninterface IJBSplits is IJBControlled {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed group, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 group) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function mint(address account, uint256 amount) external;\n\n    function burn(address account, uint256 amount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBControlled} from \"./IJBControlled.sol\";\n\ninterface IJBTokens is IJBControlled {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 amount, bool tokensWereClaimed, address caller\n    );\n\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 amount,\n        uint256 initialCreditBalance,\n        uint256 initialTokenBalance,\n        address caller\n    );\n\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 initialCreditBalance,\n        uint256 amount,\n        address beneficiary,\n        address caller\n    );\n\n    event SetToken(uint256 indexed projectId, IJBToken indexed newToken, address caller);\n\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 amount, address caller\n    );\n\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n\n    function projectIdOf(IJBToken token) external view returns (uint256);\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n\n    function burnFrom(address holder, uint256 projectId, uint256 amount) external;\n\n    function mintFor(address holder, uint256 projectId, uint256 amount) external;\n\n    function claimTokensFor(address holder, uint256 projectId, uint256 amount, address beneficiary) external;\n\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 amount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/terminal/IJBTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAccountingContext} from \"../../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../../structs/JBAfterPayRecordedContext.sol\";\n\nimport {IJBPayHook} from \"../../interfaces/IJBPayHook.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 unlockedFees, string memo, bytes metadata, address caller\n    );\n\n    event SetAccountingContext(\n        uint256 indexed projectId, address indexed token, JBAccountingContext context, address caller\n    );\n\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n\n    function currentSurplusOf(uint256 projectId, uint256 decimals, uint256 currency) external view returns (uint256);\n\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n\n    function addAccountingContextsFor(uint256 projectId, address[] calldata tokens) external;\n\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBConstants.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint256 public constant MAX_RESERVED_RATE = 10_000;\n    uint256 public constant MAX_REDEMPTION_RATE = 10_000;\n    uint256 public constant MAX_DECAY_RATE = 1_000_000_000;\n    uint256 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint256 public constant MAX_FEE = 1000;\n    uint256 public constant MAX_FEE_DISCOUNT = 1_000_000_000;\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBSplitGroupIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary JBSplitGroupIds {\n    uint256 public constant RESERVED_TOKENS = 1;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member projectTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 projectTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAfterRedeemRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member holder The holder of the tokens being redeemed.\n/// @custom:member projectId The ID of the project being redeemed from.\n/// @custom:member rulesetId The ID of the ruleset the redemption is being made during.\n/// @custom:member redeemCount The number of project tokens being redeemed.\n/// @custom:member redemptionRate The current ruleset's redemption rate.\n/// @custom:member reclaimedAmount The token amount being reclaimed from the project's terminal balance. Includes the\n/// token being\n/// reclaimed, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the redeem hook. Includes the token\n/// being forwarded, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member beneficiary The address the reclaimed amount will be sent to.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the redeem hook.\n/// @custom:member redeemerMetadata Extra data specified by the redeemer, which is sent to the redeem hook.\nstruct JBAfterRedeemRecordedContext {\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 redeemCount;\n    JBTokenAmount reclaimedAmount;\n    JBTokenAmount forwardedAmount;\n    uint256 redemptionRate;\n    address payable beneficiary;\n    bytes hookMetadata;\n    bytes redeemerMetadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBBeforePayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon payment.\n/// @custom:member terminal The terminal that is facilitating the payment.\n/// @custom:member payer The address that the payment originated from.\n/// @custom:member amount The payment's token amount, including the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member beneficiary The specified address that should be the beneficiary of anything that this payment\n/// yields.\n/// @custom:member weight The weight of the ruleset during which the payment is being made.\n/// @custom:member reservedRate The reserved rate of the ruleset the payment is being made during.\n/// @custom:member metadata Extra data specified by the payer.\nstruct JBBeforePayRecordedContext {\n    address terminal;\n    address payer;\n    JBTokenAmount amount;\n    uint256 projectId;\n    uint256 rulesetId;\n    address beneficiary;\n    uint256 weight;\n    uint256 reservedRate;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBBeforeRedeemRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon redemption.\n/// @custom:member terminal The terminal that is facilitating the redemption.\n/// @custom:member holder The holder of the tokens being redeemed.\n/// @custom:member projectId The ID of the project whose tokens are being redeemed.\n/// @custom:member rulesetId The ID of the ruleset the redemption is being made during.\n/// @custom:member redeemCount The number of tokens being redeemed, as a fixed point number with 18 decimals.\n/// @custom:member totalSupply The total token supply being used for the calculation, as a fixed point number with 18\n/// decimals.\n/// @custom:member surplus The surplus amount used for the calculation, as a fixed point number with 18 decimals.\n/// Includes the token of the surplus, the surplus value, the number of decimals\n/// included, and the currency of the surplus.\n/// @custom:member useTotalSurplus If surplus across all of a project's terminals is being used when making redemptions.\n/// @custom:member redemptionRate The redemption rate of the ruleset the redemption is being made during.\n/// @custom:member metadata Extra data provided by the redeemer.\nstruct JBBeforeRedeemRecordedContext {\n    address terminal;\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 redeemCount;\n    uint256 totalSupply;\n    JBTokenAmount surplus;\n    bool useTotalSurplus;\n    uint256 redemptionRate;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency's index in `JBCurrencyIds`.\nstruct JBCurrencyAmount {\n    uint256 amount;\n    uint256 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBPayHookSpecification.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A pay hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The pay hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass the hook.\nstruct JBPayHookSpecification {\n    IJBPayHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint256 projectId;\n    uint256[] permissionIds;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRedeemHookSpecification.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRedeemHook} from \"../interfaces/IJBRedeemHook.sol\";\n\n/// @notice A redeem hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The redeem hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass to the hook.\nstruct JBRedeemHookSpecification {\n    IJBRedeemHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `decayRate`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member decayRate The percentage by which to reduce the `weight` each time a new ruleset starts. `weight` is\n/// a percentage out of `JBConstants.MAX_DECAY_RATE`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `decayRate` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint256 cycleNumber;\n    uint256 id;\n    uint256 basedOnId;\n    uint256 start;\n    uint256 duration;\n    uint256 weight;\n    uint256 decayRate;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active  any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a decayed `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member decayRate A percent by how much the `weight` of the subsequent ruleset should be reduced, if the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_DECAY_RATE`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint256 mustStartAtOrAfter;\n    uint256 duration;\n    uint256 weight;\n    uint256 decayRate;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedRate The reserved rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_RATE`.\n/// @custom:member redemptionRate The redemption rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_REDEMPTION_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowControllerMigration A flag indicating if migrating controllers should be allowed during this\n/// ruleset.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForRedemptions A flag indicating if redemptions should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the redemption is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForRedeem A flag indicating if the data hook should be used for redeem transactions during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, up to uint8 in size.\nstruct JBRulesetMetadata {\n    uint256 reservedRate;\n    uint256 redemptionRate;\n    uint256 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowControllerMigration;\n    bool allowSetController;\n    bool holdFees;\n    bool useTotalSurplusForRedemptions;\n    bool useDataHookForPay;\n    bool useDataHookForRedeem;\n    address dataHook;\n    uint256 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    bool preferAddToBalance;\n    uint256 percent;\n    uint256 projectId;\n    address payable beneficiary;\n    uint256 lockedUntil;\n    IJBSplitHook hook;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBTerminal} from \"./../interfaces/terminal/IJBTerminal.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member acceptedTokens The tokens to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    address[] tokensToAccept;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The expected currency of the value.\nstruct JBTokenAmount {\n    address token;\n    uint256 value;\n    uint256 decimals;\n    uint256 currency;\n}\n"
			},
			"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
				"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem.\nlibrary JBPermissionIds {\n    // nana-core\n    uint256 internal constant ROOT = 1;\n    uint256 internal constant QUEUE_RULESETS = 2;\n    uint256 internal constant REDEEM_TOKENS = 3;\n    uint256 internal constant MIGRATE_CONTROLLER = 4;\n    uint256 internal constant MIGRATE_TERMINAL = 5;\n    uint256 internal constant PROCESS_FEES = 6;\n    uint256 internal constant SET_PROJECT_METADATA = 7;\n    uint256 internal constant ISSUE_TOKEN = 8;\n    uint256 internal constant SET_TOKEN = 9;\n    uint256 internal constant MINT_TOKENS = 10;\n    uint256 internal constant BURN_TOKENS = 11;\n    uint256 internal constant CLAIM_TOKENS = 12;\n    uint256 internal constant TRANSFER_TOKENS = 13;\n    uint256 internal constant SET_CONTROLLER = 14;\n    uint256 internal constant SET_TERMINALS = 15;\n    uint256 internal constant SET_PRIMARY_TERMINAL = 16;\n    uint256 internal constant USE_ALLOWANCE = 17;\n    uint256 internal constant SET_SPLITS = 18;\n    uint256 internal constant ADD_PRICE_FEED = 19;\n    uint256 internal constant SET_ACCOUNTING_CONTEXT = 20;\n    // nana-project-handles\n    uint256 internal constant SET_ENS_NAME_FOR = 21;\n    // nana-721-hook\n    uint256 internal constant ADJUST_721_TIERS = 22;\n    uint256 internal constant UPDATE_721_METADATA = 23;\n    uint256 internal constant MINT_721 = 24;\n    // nana-buyback-hook\n    uint256 internal constant SET_BUYBACK_POOL_PARAMS = 25;\n    uint256 internal constant CHANGE_BUYBACK_POOL = 26;\n    // nana-swap-terminal\n    uint256 internal constant MODIFY_DEFAULT_SWAP_TERMINAL_POOL = 27;\n    uint256 internal constant MODIFY_SWAP_TERMINAL_TWAP_PARAMS = 28;\n    // nana-suckers\n    uint256 internal constant MAP_SUCKER_TOKEN = 29;\n    uint256 internal constant DEPLOY_SUCKERS = 30;\n}\n"
			},
			"node_modules/@bananapus/suckers/src/interfaces/IBPSucker.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BPTokenMapping} from \"../structs/BPTokenMapping.sol\";\n\ninterface IBPSucker {\n    function PEER() external view returns (address);\n\n    function peerChainID() external view returns (uint256 chainId);\n\n    function isMapped(address token) external view returns (bool);\n\n    function prepare(uint256 projectTokenAmount, address beneficiary, uint256 minTokensReclaimed, address token)\n        external;\n\n    function mapToken(BPTokenMapping calldata map) external;\n\n    function mapTokens(BPTokenMapping[] calldata maps) external;\n\n    event NewInboxTreeRoot(address indexed token, uint64 nonce, bytes32 root);\n\n    event RootToRemote(bytes32 indexed root, address indexed terminalToken, uint256 index, uint64 nonce);\n\n    event InsertToOutboxTree(\n        address indexed beneficiary,\n        address indexed terminalToken,\n        bytes32 hashed,\n        uint256 index,\n        bytes32 root,\n        uint256 projectTokenAmount,\n        uint256 terminalTokenAmount\n    );\n}\n"
			},
			"node_modules/@bananapus/suckers/src/interfaces/IBPSuckerDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBPSucker} from \"./IBPSucker.sol\";\n\ninterface IBPSuckerDeployer {\n    function createForSender(uint256 localProjectId, bytes32 salt) external returns (IBPSucker sucker);\n}\n"
			},
			"node_modules/@bananapus/suckers/src/interfaces/IBPSuckerRegistry.sol": {
				"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.21;\n\nimport {BPSuckerDeployerConfig} from \"../structs/BPSuckerDeployerConfig.sol\";\n\ninterface IBPSuckerRegistry {\n    function isSuckerOf(uint256 projectId, address suckerAddress) external view returns (bool);\n    function suckersOf(uint256 projectId) external view returns (address[] memory);\n    function suckerDeployerIsAllowed(address deployer) external view returns (bool);\n\n    function allowSuckerDeployer(address deployer) external;\n    function deploySuckersFor(uint256 projectId, bytes32 salt, BPSuckerDeployerConfig[] memory configurations)\n        external\n        returns (address[] memory suckers);\n}\n"
			},
			"node_modules/@bananapus/suckers/src/structs/BPSuckerDeployerConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBPSuckerDeployer} from \"../interfaces/IBPSuckerDeployer.sol\";\nimport {BPTokenMapping} from \"./BPTokenMapping.sol\";\n\nstruct BPSuckerDeployerConfig {\n    IBPSuckerDeployer deployer;\n    BPTokenMapping[] mappings;\n}\n"
			},
			"node_modules/@bananapus/suckers/src/structs/BPTokenMapping.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct BPTokenMapping {\n    address localToken;\n    uint32 minGas;\n    address remoteToken;\n    uint256 minBridgeAmount;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport {IUniswapV3PoolImmutables} from './pool/IUniswapV3PoolImmutables.sol';\nimport {IUniswapV3PoolState} from './pool/IUniswapV3PoolState.sol';\nimport {IUniswapV3PoolDerivedState} from './pool/IUniswapV3PoolDerivedState.sol';\nimport {IUniswapV3PoolActions} from './pool/IUniswapV3PoolActions.sol';\nimport {IUniswapV3PoolOwnerActions} from './pool/IUniswapV3PoolOwnerActions.sol';\nimport {IUniswapV3PoolErrors} from './pool/IUniswapV3PoolErrors.sol';\nimport {IUniswapV3PoolEvents} from './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolErrors,\n    IUniswapV3PoolEvents\n{\n\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolErrors.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Errors emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolErrors {\n    error LOK();\n    error TLU();\n    error TLM();\n    error TUM();\n    error AI();\n    error M0();\n    error M1();\n    error AS();\n    error IIA();\n    error L();\n    error F0();\n    error F1();\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
			},
			"node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// @return tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// @return observationIndex The index of the last oracle observation that was written,\n    /// @return observationCardinality The current maximum number of observations stored in the pool,\n    /// @return observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// @return feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    /// @return The liquidity at the current price of the pool\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper\n    /// @return liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// @return feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// @return feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// @return tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// @return secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// @return secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// @return initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return liquidity The amount of liquidity in the position,\n    /// @return feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// @return feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// @return tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// @return tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// @return tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// @return secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// @return initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
			},
			"src/REVBasicDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBRulesetApprovalHook} from \"@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol\";\nimport {IJBPermissioned} from \"@bananapus/core/src/interfaces/IJBPermissioned.sol\";\nimport {IJBSplitHook} from \"@bananapus/core/src/interfaces/IJBSplitHook.sol\";\nimport {IJBToken} from \"@bananapus/core/src/interfaces/IJBToken.sol\";\nimport {IJBPayHook} from \"@bananapus/core/src/interfaces/IJBPayHook.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\nimport {JBSplitGroupIds} from \"@bananapus/core/src/libraries/JBSplitGroupIds.sol\";\nimport {JBRulesetMetadata} from \"@bananapus/core/src/structs/JBRulesetMetadata.sol\";\nimport {JBRulesetConfig} from \"@bananapus/core/src/structs/JBRulesetConfig.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {JBSplitGroup} from \"@bananapus/core/src/structs/JBSplitGroup.sol\";\nimport {JBSplit} from \"@bananapus/core/src/structs/JBSplit.sol\";\nimport {JBPermissionsData} from \"@bananapus/core/src/structs/JBPermissionsData.sol\";\nimport {JBBeforeRedeemRecordedContext} from \"@bananapus/core/src/structs/JBBeforeRedeemRecordedContext.sol\";\nimport {JBBeforePayRecordedContext} from \"@bananapus/core/src/structs/JBBeforePayRecordedContext.sol\";\nimport {IJBRulesetDataHook} from \"@bananapus/core/src/interfaces/IJBRulesetDataHook.sol\";\nimport {JBRedeemHookSpecification} from \"@bananapus/core/src/structs/JBRedeemHookSpecification.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {IJBBuybackHook} from \"@bananapus/buyback-hook/src/interfaces/IJBBuybackHook.sol\";\nimport {BPTokenMapping} from \"@bananapus/suckers/src/structs/BPTokenMapping.sol\";\nimport {IBPSucker} from \"@bananapus/suckers/src/interfaces/IBPSucker.sol\";\nimport {IBPSuckerRegistry} from \"@bananapus/suckers/src/interfaces/IBPSuckerRegistry.sol\";\n\nimport {IREVBasicDeployer} from \"./interfaces/IREVBasicDeployer.sol\";\nimport {REVConfig} from \"./structs/REVConfig.sol\";\nimport {REVStageConfig} from \"./structs/REVStageConfig.sol\";\nimport {REVBuybackHookConfig} from \"./structs/REVBuybackHookConfig.sol\";\nimport {REVBuybackPoolConfig} from \"./structs/REVBuybackPoolConfig.sol\";\nimport {REVSuckerDeploymentConfig} from \"./structs/REVSuckerDeploymentConfig.sol\";\n\n/// @notice A contract that facilitates deploying a basic Revnet.\ncontract REVBasicDeployer is ERC165, IREVBasicDeployer, IJBRulesetDataHook, IERC721Receiver {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error REVBasicDeployer_Unauthorized();\n    error REVBasicDeployer_ExitDelayInEffect();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice The amount of time from a sucker being deployed to when it can facilitate exits.\n    /// @dev 90 days.\n    uint256 public constant EXIT_DELAY = 7_776_000;\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice The controller that networks are made from.\n    IJBController public immutable override CONTROLLER;\n\n    /// @notice The registry that deploys and tracks each project's suckers.\n    IBPSuckerRegistry public immutable override SUCKER_REGISTRY;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The data hook that returns the correct values for the buyback hook of each network.\n    /// @custom:param revnetId The ID of the revnet to which the buyback contract applies.\n    mapping(uint256 revnetId => IJBRulesetDataHook buybackHook) public override buybackHookOf;\n\n    /// @notice The time at which exits from a revnet become allowed.\n    /// @custom:param revnetId The ID of the revnet to which the delay applies.\n    mapping(uint256 revnetId => uint256 exitDelay) public override exitDelayOf;\n\n    //*********************************************************************//\n    // ------------------- internal stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The permissions that the provided operator should be granted. This is set once in the constructor\n    /// to contain only the SET_SPLITS operation.\n    /// @dev This should only be set in the constructor.\n    uint256[] internal _SPLIT_OPERATOR_PERMISSIONS_INDEXES;\n\n    /// @notice The pay hooks to include during payments to networks.\n    /// @custom:param revnetId The ID of the revnet to which the extensions apply.\n    mapping(uint256 revnetId => JBPayHookSpecification[] payHooks) internal _payHookSpecificationsOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice The pay hooks to include during payments to networks.\n    /// @param revnetId The ID of the revnet to which the extensions apply.\n    /// @return payHookSpecifications The pay hooks.\n    function payHookSpecificationsOf(uint256 revnetId)\n        external\n        view\n        override\n        returns (JBPayHookSpecification[] memory)\n    {\n        return _payHookSpecificationsOf[revnetId];\n    }\n\n    /// @notice This function gets called when the revnet receives a payment.\n    /// @dev Part of IJBFundingCycleDataSource.\n    /// @dev This implementation just sets this contract up to receive a `didPay` call.\n    /// @param context The Juicebox standard network payment context. See\n    /// @return weight The weight that network tokens should get minted relative to. This is useful for optionally\n    /// customizing how many tokens are issued per payment.\n    /// @return hookSpecifications Amount to be sent to pay hooks instead of adding to local balance. Useful for\n    /// auto-routing funds from a treasury as payment come in.\n    function beforePayRecordedWith(JBBeforePayRecordedContext calldata context)\n        external\n        view\n        virtual\n        override\n        returns (uint256 weight, JBPayHookSpecification[] memory hookSpecifications)\n    {\n        // Keep a reference to the hooks that the buyback hook data hook provides.\n        JBPayHookSpecification[] memory buybackHookSpecifications;\n\n        // Keep a reference to the buyback hook.\n        IJBRulesetDataHook buybackHook = buybackHookOf[context.projectId];\n\n        // // Set the values to be those returned by the buyback hook's data source.\n        if (buybackHook != IJBRulesetDataHook(address(0))) {\n            (weight, buybackHookSpecifications) = buybackHook.beforePayRecordedWith(context);\n        }\n\n        // Check if a buyback hook is used.\n        bool usesBuybackHook = buybackHookSpecifications.length != 0;\n\n        // Cache any other pay hooks to use.\n        JBPayHookSpecification[] memory storedPayHookSpecifications = _payHookSpecificationsOf[context.projectId];\n\n        // Keep a reference to the number of pay hooks.\n        uint256 numberOfStoredPayHookSpecifications = storedPayHookSpecifications.length;\n\n        // Each hook specification must run, plus the buyback hook if provided.\n        hookSpecifications =\n            new JBPayHookSpecification[](numberOfStoredPayHookSpecifications + (usesBuybackHook ? 1 : 0));\n\n        // Add the other expected pay hooks.\n        for (uint256 i; i < numberOfStoredPayHookSpecifications; i++) {\n            hookSpecifications[i] = storedPayHookSpecifications[i];\n        }\n\n        // Add the buyback hook as the last element.\n        if (usesBuybackHook) hookSpecifications[numberOfStoredPayHookSpecifications] = buybackHookSpecifications[0];\n    }\n\n    /// @notice This function is never called, it needs to be included to adhere to the interface.\n    function beforeRedeemRecordedWith(JBBeforeRedeemRecordedContext calldata context)\n        external\n        view\n        virtual\n        override\n        returns (uint256, uint256, uint256, JBRedeemHookSpecification[] memory specifications)\n    {\n        // If the holder is a sucker, do not impose a tax.\n        if (SUCKER_REGISTRY.isSuckerOf({projectId: context.projectId, suckerAddress: context.holder})) {\n            return (JBConstants.MAX_REDEMPTION_RATE, context.redeemCount, context.totalSupply, specifications);\n        }\n\n        // If there's an exit delay, do not allow exits until the delay has passed.\n        if (exitDelayOf[context.projectId] > block.timestamp) {\n            revert REVBasicDeployer_ExitDelayInEffect();\n        }\n\n        return (context.redemptionRate, context.redeemCount, context.totalSupply, specifications);\n    }\n\n    /// @notice Required by the IJBRulesetDataHook interfaces.\n    /// @param revnetId The ID of the revnet to check permissions for.\n    /// @param addr The address to check if has permissions.\n    /// @return flag The flag indicating if the address has permissions to mint on the revnet's behalf.\n    function hasMintPermissionFor(uint256 revnetId, address addr) external view override returns (bool) {\n        // The buyback hook is allowed to mint on the project's behalf.\n        if (addr == address(buybackHookOf[revnetId])) return true;\n\n        // Get a reference to the revnet's suckers.\n        address[] memory suckers = SUCKER_REGISTRY.suckersOf(revnetId);\n\n        // Keep a reference to the number of suckers there are.\n        uint256 numberOfSuckers = suckers.length;\n\n        // The suckers are allowed to mint on the project's behalf.\n        for (uint256 i; i < numberOfSuckers; i++) {\n            if (addr == suckers[i]) return true;\n        }\n\n        // No other contract has minting permissions.\n        return false;\n    }\n\n    /// @dev Make sure only mints can be received.\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4)\n    {\n        data;\n        tokenId;\n        operator;\n\n        // Make sure the 721 received is the JBProjects contract.\n        if (msg.sender != address(CONTROLLER.PROJECTS())) revert();\n        // Make sure the 721 is being received as a mint.\n        if (from != address(0)) revert();\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Indicates if this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId The ID of the interface to check for adherence to.\n    /// @return A flag indicating if the provided interface ID is supported.\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IJBRulesetDataHook).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param controller The controller that revnets are made from.\n    /// @param suckerRegistry The registry that deploys and tracks each project's suckers.\n    constructor(IJBController controller, IBPSuckerRegistry suckerRegistry) {\n        CONTROLLER = controller;\n        SUCKER_REGISTRY = suckerRegistry;\n        _SPLIT_OPERATOR_PERMISSIONS_INDEXES.push(JBPermissionIds.SET_SPLITS);\n        _SPLIT_OPERATOR_PERMISSIONS_INDEXES.push(JBPermissionIds.SET_BUYBACK_POOL_PARAMS);\n        _SPLIT_OPERATOR_PERMISSIONS_INDEXES.push(JBPermissionIds.SET_PROJECT_METADATA);\n    }\n\n    //*********************************************************************//\n    // --------------------- external transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice A revnet's operator can replace itself.\n    /// @param revnetId The ID of the revnet having its operator replaced.\n    /// @param newSplitOperator The address of the new split operator.\n    function replaceSplitOperatorOf(uint256 revnetId, address newSplitOperator) external {\n        /// Make sure the message sender is the current split operator.\n        if (\n            !IJBPermissioned(address(CONTROLLER.SPLITS())).PERMISSIONS().hasPermissions({\n                operator: msg.sender,\n                account: address(this),\n                projectId: revnetId,\n                permissionIds: _SPLIT_OPERATOR_PERMISSIONS_INDEXES\n            })\n        ) revert REVBasicDeployer_Unauthorized();\n\n        // Remove operator permission from the old split operator.\n        IJBPermissioned(address(CONTROLLER.SPLITS())).PERMISSIONS().setPermissionsFor({\n            account: address(this),\n            permissionsData: JBPermissionsData({operator: msg.sender, projectId: revnetId, permissionIds: new uint256[](0)})\n        });\n\n        // Give the new split operator permission to change the recipients of the operator's split.\n        IJBPermissioned(address(CONTROLLER.SPLITS())).PERMISSIONS().setPermissionsFor({\n            account: address(this),\n            permissionsData: JBPermissionsData({\n                operator: newSplitOperator,\n                projectId: revnetId,\n                permissionIds: _SPLIT_OPERATOR_PERMISSIONS_INDEXES\n            })\n        });\n\n        emit ReplaceSplitOperator(revnetId, newSplitOperator, msg.sender);\n    }\n\n    /// @notice Allows a revnet's split operator to deploy new suckers to the revnet after it's deployed.\n    /// @param revnetId The ID of the revnet having new suckers deployed.\n    /// @param encodedConfiguration A bytes representation of the revnet's configuration.\n    /// @param suckerDeploymentConfiguration The specifics about the suckers being deployed.\n    function deploySuckersFor(\n        uint256 revnetId,\n        bytes memory encodedConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration\n    )\n        public\n        override\n    {\n        /// Make sure the message sender is the current split operator.\n        if (\n            !IJBPermissioned(address(CONTROLLER.SPLITS())).PERMISSIONS().hasPermissions({\n                operator: msg.sender,\n                account: address(this),\n                projectId: revnetId,\n                permissionIds: _SPLIT_OPERATOR_PERMISSIONS_INDEXES\n            })\n        ) revert REVBasicDeployer_Unauthorized();\n\n        // Compose the salt.\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, encodedConfiguration, suckerDeploymentConfiguration.salt));\n\n        // Deploy the suckers.\n        SUCKER_REGISTRY.deploySuckersFor({\n            projectId: revnetId,\n            salt: salt,\n            configurations: suckerDeploymentConfiguration.deployerConfigurations\n        });\n\n        emit DeploySuckers(revnetId, salt, encodedConfiguration, suckerDeploymentConfiguration, msg.sender);\n    }\n\n    //*********************************************************************//\n    // ---------------------- public transactions ------------------------ //\n    //*********************************************************************//\n\n    /// @notice Deploy a basic revnet.\n    /// @param configuration The data needed to deploy a basic revnet.\n    /// @param terminalConfigurations The terminals that the network uses to accept payments through.\n    /// @param buybackHookConfiguration Data used for setting up the buyback hook to use when determining the best price\n    /// for new participants.\n    /// @param suckerDeploymentConfiguration Information about how this revnet relates to other's across chains.\n    /// @return revnetId The ID of the newly created revnet.\n    function deployRevnetWith(\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration\n    )\n        public\n        override\n        returns (uint256 revnetId)\n    {\n        // Deploy main revnet.\n        revnetId = _deployRevnetWith({\n            configuration: configuration,\n            terminalConfigurations: terminalConfigurations,\n            buybackHookConfiguration: buybackHookConfiguration,\n            dataHook: IJBBuybackHook(address(this)),\n            extraHookMetadata: 0,\n            suckerDeploymentConfiguration: suckerDeploymentConfiguration\n        });\n    }\n\n    //*********************************************************************//\n    // --------------------- itnernal transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Deploys a revnet with the specified hook information.\n    /// @param configuration The data needed to deploy a basic revnet.\n    /// @param terminalConfigurations The terminals that the network uses to accept payments through.\n    /// @param buybackHookConfiguration Data used for setting up the buyback hook to use when determining the best price\n    /// for new participants.\n    /// @param dataHook The address of the data hook.\n    /// @param extraHookMetadata Extra info to send to the hook.\n    /// @param suckerDeploymentConfiguration Information about how this revnet relates to other's across chains.\n    /// @return revnetId The ID of the newly created revnet.\n    function _deployRevnetWith(\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        IJBBuybackHook dataHook,\n        uint256 extraHookMetadata,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration\n    )\n        internal\n        virtual\n        returns (uint256 revnetId)\n    {\n        (JBRulesetConfig[] memory rulesetConfigurations, bytes memory encodedConfiguration, bool isInProgress) =\n            _makeRulesetConfigurations(configuration, address(dataHook), extraHookMetadata);\n\n        // Deploy a juicebox for the revnet.\n        revnetId = CONTROLLER.launchProjectFor({\n            owner: address(this),\n            projectUri: configuration.description.uri,\n            rulesetConfigurations: rulesetConfigurations,\n            terminalConfigurations: terminalConfigurations,\n            memo: string.concat(\"$\", configuration.description.ticker, \" revnet deployed\")\n        });\n\n        // Store the exit delay of the revnet if it is in progess or if premint isn't on this chain. This prevents exits\n        // from the revnet until the delay\n        // is up.\n        if (isInProgress || configuration.premintChainId != block.chainid) {\n            exitDelayOf[revnetId] = block.timestamp + EXIT_DELAY;\n        }\n\n        // Issue the network's ERC-20 token.\n        CONTROLLER.deployERC20For({\n            projectId: revnetId,\n            name: configuration.description.name,\n            symbol: configuration.description.ticker,\n            salt: configuration.description.salt\n        });\n\n        // Setup the buyback hook if needed.\n        if (buybackHookConfiguration.hook != IJBBuybackHook(address(0))) {\n            _setupBuybackHookOf(revnetId, buybackHookConfiguration);\n        }\n\n        // Set the operator splits at the default ruleset of 0.\n        CONTROLLER.setSplitGroupsOf({\n            projectId: revnetId,\n            rulesetId: 0,\n            splitGroups: _makeOperatorSplitGroupWith(configuration.initialSplitOperator)\n        });\n\n        // Give the operator its permissions.\n        IJBPermissioned(address(CONTROLLER)).PERMISSIONS().setPermissionsFor({\n            account: address(this),\n            permissionsData: JBPermissionsData({\n                operator: configuration.initialSplitOperator,\n                projectId: revnetId,\n                permissionIds: _SPLIT_OPERATOR_PERMISSIONS_INDEXES\n            })\n        });\n\n        // Premint tokens to the split operator if needed.\n        if (configuration.premintTokenAmount > 0 && configuration.premintChainId == block.chainid) {\n            CONTROLLER.mintTokensOf({\n                projectId: revnetId,\n                tokenCount: configuration.premintTokenAmount,\n                beneficiary: configuration.initialSplitOperator,\n                memo: string.concat(\"$\", configuration.description.ticker, \" preminted\"),\n                useReservedRate: false\n            });\n        }\n\n        // Give the sucker registry permission to map tokens.\n        uint256[] memory registryPermissions = new uint256[](1);\n        registryPermissions[0] = JBPermissionIds.MAP_SUCKER_TOKEN;\n\n        // Give the operator permission to change the recipients of the operator's split.\n        IJBPermissioned(address(CONTROLLER)).PERMISSIONS().setPermissionsFor({\n            account: address(this),\n            permissionsData: JBPermissionsData({\n                operator: address(SUCKER_REGISTRY),\n                projectId: revnetId,\n                permissionIds: registryPermissions\n            })\n        });\n\n        // Deploy the suckers if needed.\n        if (suckerDeploymentConfiguration.salt != bytes32(0)) {\n            SUCKER_REGISTRY.deploySuckersFor({\n                projectId: revnetId,\n                salt: keccak256(abi.encodePacked(msg.sender, encodedConfiguration, suckerDeploymentConfiguration.salt)),\n                configurations: suckerDeploymentConfiguration.deployerConfigurations\n            });\n        }\n\n        emit DeployRevnet(\n            revnetId,\n            configuration,\n            terminalConfigurations,\n            buybackHookConfiguration,\n            suckerDeploymentConfiguration,\n            rulesetConfigurations,\n            encodedConfiguration,\n            isInProgress,\n            msg.sender\n        );\n    }\n\n    /// @notice Schedules the initial ruleset for the revnet, and queues all subsequent rulesets that define the stages.\n    /// @notice configuration The data that defines the revnet's characteristics.\n    /// @notice dataHook The address of the data hook.\n    /// @notice extraMetadata Extra info to send to the hook.\n    /// @return rulesetConfigurations The ruleset configurations that define the revnet's stages.\n    /// @return encodedConfiguration The encoded configuration of the revnet.\n    /// @return isInProgress Whether the revnet is in progress or not.\n    function _makeRulesetConfigurations(\n        REVConfig memory configuration,\n        address dataHook,\n        uint256 extraMetadata\n    )\n        internal\n        view\n        virtual\n        returns (JBRulesetConfig[] memory rulesetConfigurations, bytes memory encodedConfiguration, bool isInProgress)\n    {\n        // Keep a reference to the number of stages to schedule.\n        uint256 numberOfStages = configuration.stageConfigurations.length;\n\n        // Each stage is modeled as a ruleset reconfiguration.\n        rulesetConfigurations = new JBRulesetConfig[](numberOfStages);\n\n        // Store the base currency in the encoding.\n        encodedConfiguration = _encodedConfig(configuration);\n\n        // Keep a reference to teh stage configuration being iterated on.\n        REVStageConfig memory stageConfiguration;\n\n        // Loop through each stage to set up its ruleset configuration.\n        for (uint256 i; i < numberOfStages; i++) {\n            // Set the stage configuration being iterated on.\n            stageConfiguration = configuration.stageConfigurations[i];\n\n            rulesetConfigurations[i].mustStartAtOrAfter = stageConfiguration.startsAtOrAfter;\n            rulesetConfigurations[i].duration = stageConfiguration.priceCeilingIncreaseFrequency;\n            // Set the initial issuance for the first ruleset, otherwise pass 0 to inherit from the previous\n            // ruleset.\n            rulesetConfigurations[i].weight = stageConfiguration.initialIssuanceRate;\n            rulesetConfigurations[i].decayRate = stageConfiguration.priceCeilingIncreasePercentage;\n            rulesetConfigurations[i].approvalHook = IJBRulesetApprovalHook(address(0));\n            rulesetConfigurations[i].metadata = JBRulesetMetadata({\n                reservedRate: stageConfiguration.splitRate,\n                redemptionRate: JBConstants.MAX_REDEMPTION_RATE - stageConfiguration.priceFloorTaxIntensity,\n                baseCurrency: configuration.baseCurrency,\n                pausePay: false,\n                pauseCreditTransfers: false,\n                allowOwnerMinting: true, // Allow this contract to premint tokens as the network owner.\n                allowTerminalMigration: false,\n                allowSetTerminals: false,\n                allowControllerMigration: false,\n                allowSetController: false,\n                holdFees: false,\n                useTotalSurplusForRedemptions: false,\n                useDataHookForPay: true, // Use the buyback hook data source.\n                useDataHookForRedeem: false,\n                dataHook: dataHook,\n                metadata: extraMetadata\n            });\n\n            // If the first stage has a start time in the past, mark the revnet as being in progress.\n            if (\n                i == 0 && stageConfiguration.startsAtOrAfter != 0\n                    && stageConfiguration.startsAtOrAfter < block.timestamp\n            ) {\n                isInProgress = true;\n            }\n\n            // Append the encoded stage properties.\n            encodedConfiguration = abi.encodePacked(\n                encodedConfiguration, _encodedStageConfig({stageConfiguration: stageConfiguration, stageNumber: i})\n            );\n        }\n    }\n\n    /// @notice Creates a group of splits that goes entirely to the provided split operator.\n\n    /// @param splitOperator The address to send the entire split amount to.\n    /// @return splitGroups The split groups representing operator's split.\n    function _makeOperatorSplitGroupWith(address splitOperator)\n        internal\n        pure\n        returns (JBSplitGroup[] memory splitGroups)\n    {\n        // Package the reserved token splits.\n        splitGroups = new JBSplitGroup[](1);\n\n        // Make the splits.\n\n        // Make a new splits specifying where the reserved tokens will be sent.\n        JBSplit[] memory splits = new JBSplit[](1);\n\n        // Send the operator all of the splits. They'll be able to change this later whenever they wish.\n        splits[0] = JBSplit({\n            preferAddToBalance: false,\n            percent: JBConstants.SPLITS_TOTAL_PERCENT,\n            projectId: 0,\n            beneficiary: payable(splitOperator),\n            lockedUntil: 0,\n            hook: IJBSplitHook(address(0))\n        });\n\n        // Set the item in the splits group.\n        splitGroups[0] = JBSplitGroup({groupId: JBSplitGroupIds.RESERVED_TOKENS, splits: splits});\n    }\n\n    /// @notice Sets up a buyback hook.\n    /// @param revnetId The ID of the revnet to which the buybacks should apply.\n    /// @param buybackHookConfiguration Data used to setup pools that'll be used to buyback tokens from if an optimal\n    /// price\n    /// is presented.\n    function _setupBuybackHookOf(uint256 revnetId, REVBuybackHookConfig memory buybackHookConfiguration) internal {\n        // Get a reference to the number of pools that need setting up.\n        uint256 numberOfPoolsToSetup = buybackHookConfiguration.poolConfigurations.length;\n\n        // Keep a reference to the pool being iterated on.\n        REVBuybackPoolConfig memory poolConfig;\n\n        for (uint256 i; i < numberOfPoolsToSetup; i++) {\n            // Get a reference to the pool being iterated on.\n            poolConfig = buybackHookConfiguration.poolConfigurations[i];\n\n            // Set the pool for the buyback contract.\n            buybackHookConfiguration.hook.setPoolFor({\n                projectId: revnetId,\n                fee: poolConfig.fee,\n                twapWindow: poolConfig.twapWindow,\n                twapSlippageTolerance: poolConfig.twapSlippageTolerance,\n                terminalToken: poolConfig.token\n            });\n        }\n\n        // Store the hook.\n        buybackHookOf[revnetId] = buybackHookConfiguration.hook;\n    }\n\n    /// @notice Encodes a configuration into a hash.\n    /// @notice configuration The data that defines the revnet's characteristics.\n    /// @return encodedConfiguration The encoded config.\n    function _encodedConfig(REVConfig memory configuration) internal pure returns (bytes memory) {\n        return abi.encode(\n            configuration.baseCurrency,\n            configuration.premintChainId,\n            configuration.description.name,\n            configuration.description.ticker,\n            configuration.description.salt\n        );\n    }\n\n    /// @notice Encodes a stage configuration into a hash.\n    /// @notice stageConfiguration The data that defines a revnet's stage characteristics.\n    /// @notice stageNumber The number of the stage being encoded.\n    /// @return encodedConfiguration The encoded config.\n    function _encodedStageConfig(\n        REVStageConfig memory stageConfiguration,\n        uint256 stageNumber\n    )\n        internal\n        view\n        returns (bytes memory)\n    {\n        return abi.encode(\n            // If no start time is provided for the first stage, use the current block timestamp.\n            (stageNumber == 0 && stageConfiguration.startsAtOrAfter == 0)\n                ? block.timestamp\n                : stageConfiguration.startsAtOrAfter,\n            stageConfiguration.splitRate,\n            stageConfiguration.initialIssuanceRate,\n            stageConfiguration.priceCeilingIncreaseFrequency,\n            stageConfiguration.priceCeilingIncreasePercentage,\n            stageConfiguration.priceFloorTaxIntensity\n        );\n    }\n}\n"
			},
			"src/interfaces/IREVBasicDeployer.sol": {
				"content": "pragma solidity ^0.8.0;\n\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBRulesetDataHook} from \"@bananapus/core/src/interfaces/IJBRulesetDataHook.sol\";\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {JBRulesetConfig} from \"@bananapus/core/src/structs/JBRulesetConfig.sol\";\nimport {IBPSuckerRegistry} from \"@bananapus/suckers/src/interfaces/IBPSuckerRegistry.sol\";\n\nimport {REVBuybackHookConfig} from \"../structs/REVBuybackHookConfig.sol\";\nimport {REVSuckerDeploymentConfig} from \"../structs/REVSuckerDeploymentConfig.sol\";\nimport {REVConfig} from \"../structs/REVConfig.sol\";\n\ninterface IREVBasicDeployer {\n    event ReplaceSplitOperator(uint256 indexed revnetId, address indexed newSplitOperator, address caller);\n    event DeploySuckers(\n        uint256 indexed revnetId,\n        bytes32 indexed salt,\n        bytes encodedConfiguration,\n        REVSuckerDeploymentConfig suckerDeploymentConfiguration,\n        address caller\n    );\n    event DeployRevnet(\n        uint256 indexed revnetId,\n        REVConfig configuration,\n        JBTerminalConfig[] terminalConfigurations,\n        REVBuybackHookConfig buybackHookConfiguration,\n        REVSuckerDeploymentConfig suckerDeploymentConfiguration,\n        JBRulesetConfig[] rulesetConfigurations,\n        bytes encodedConfiguration,\n        bool isInProgress,\n        address caller\n    );\n\n    function EXIT_DELAY() external view returns (uint256);\n    function CONTROLLER() external view returns (IJBController);\n    function SUCKER_REGISTRY() external view returns (IBPSuckerRegistry);\n\n    function buybackHookOf(uint256 revnetId) external view returns (IJBRulesetDataHook);\n    function exitDelayOf(uint256 revnetId) external view returns (uint256);\n    function payHookSpecificationsOf(uint256 revnetId) external view returns (JBPayHookSpecification[] memory);\n\n    function deployRevnetWith(\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration\n    )\n        external\n        returns (uint256 revnetId);\n\n    function deploySuckersFor(\n        uint256 projectId,\n        bytes memory encodedConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration\n    )\n        external;\n}\n"
			},
			"src/structs/REVBuybackHookConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBBuybackHook} from \"@bananapus/buyback-hook/src/interfaces/IJBBuybackHook.sol\";\nimport {REVBuybackPoolConfig} from \"./REVBuybackPoolConfig.sol\";\n\n/// @custom:member hook The buyback hook to use.\n/// @custom:member poolConfigurations The pools to setup on the given buyback contract.\nstruct REVBuybackHookConfig {\n    IJBBuybackHook hook;\n    REVBuybackPoolConfig[] poolConfigurations;\n}\n"
			},
			"src/structs/REVBuybackPoolConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token to setup a pool for.\n/// @custom:member poolFee The fee of the pool in which swaps occur when seeking the best price for a new participant.\n/// This incentivizes liquidity providers. Out of 1_000_000. A common value is 1%, or 10_000. Other passible values are\n/// 0.3% and 0.1%.\n/// @custom:member twapWindow The time window to take into account when quoting a price based on TWAP.\n/// @custom:member twapSlippageTolerance The pricetolerance to accept when quoting a price based on TWAP.\nstruct REVBuybackPoolConfig {\n    address token;\n    uint24 fee;\n    uint32 twapWindow;\n    uint32 twapSlippageTolerance;\n}\n"
			},
			"src/structs/REVConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {REVStageConfig} from \"./REVStageConfig.sol\";\nimport {REVDescription} from \"./REVDescription.sol\";\n\n/// @custom:member description The description of the revnet.\n/// @custom:member baseCurrency The currency that the issuance is based on.\n/// @custom:member premintTokenAmount The number of tokens that should be preminted to the initial operator.\n/// @custom:member premintChainId The ID of the chain on which the premint should be honored.\n/// @custom:member initialSplitOperator The address that will receive the token premint and initial production split,\n/// and who\n/// is\n/// allowed to change who the operator is. Only the operator can replace itself after deployment.\n/// @custom:member stageConfigurations The periods of changing constraints.\nstruct REVConfig {\n    REVDescription description;\n    uint32 baseCurrency;\n    uint256 premintTokenAmount;\n    uint256 premintChainId;\n    address initialSplitOperator;\n    REVStageConfig[] stageConfigurations;\n}\n"
			},
			"src/structs/REVDescription.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member name The name of the ERC-20 token being create for the revnet.\n/// @custom:member ticker The ticker of the ERC-20 token being created for the revnet.\n/// @custom:member uri The metadata URI containing revnet's info.\n/// @custom:member salt Revnets deployed across chains by the same address with the same salt will have the same\n/// address.\nstruct REVDescription {\n    string name;\n    string ticker;\n    string uri;\n    bytes32 salt;\n}\n"
			},
			"src/structs/REVStageConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member startsAtOrAfter The timestamp to start a stage at the given rate at or after.\n/// @custom:member splitRate The percentage of newly issued tokens that should be split with the operator, out\n/// of\n/// 10_000 (JBConstants.MAX_RESERVED_RATE).\n/// @custom:member initialIssuanceRate The number of tokens that should be minted initially per 1 unit of the base\n/// currency contributed to the revnet.\n/// @custom:member priceCeilingIncreaseFrequency The number of seconds between applied price ceiling increases. This\n/// should be at least 24 hours.\n/// @custom:member priceCeilingIncreasePercentage The rate at which the price ceiling should increase over time, thus\n/// decreasing the rate of issuance. This percentage is out\n/// of 1_000_000_000 (JBConstants.MAX_DECAY_RATE). 0% corresponds to no price ceiling increase, everyone is treated\n/// equally over time.\n/// @custom:member priceFloorTaxIntensity The factor determining how much each token can reclaim from the revnet once\n/// redeemed.\n/// This percentage is out of 10_000 (JBConstants.MAX_REDEMPTION_RATE). 0% corresponds to no floor tax when\n/// redemptions are made, everyone's redemptions are treated equally. The higher the intensity, the higher the tax.\nstruct REVStageConfig {\n    uint40 startsAtOrAfter;\n    uint16 splitRate;\n    uint112 initialIssuanceRate;\n    uint40 priceCeilingIncreaseFrequency;\n    uint32 priceCeilingIncreasePercentage;\n    uint16 priceFloorTaxIntensity;\n}\n"
			},
			"src/structs/REVSuckerDeploymentConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BPSuckerDeployerConfig} from \"@bananapus/suckers/src/structs/BPSuckerDeployerConfig.sol\";\n\n/// @custom:member deployerConfigurations The information for how to suck tokens to other chains.\n/// @custom:member salt The salt to use for creating suckers so that they use the same address across chains.\nstruct REVSuckerDeploymentConfig {\n    BPSuckerDeployerConfig[] deployerConfigurations;\n    bytes32 salt;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721Hook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\n\ninterface IJB721Hook {\n    function projectId() external view returns (uint256);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesets} from \"@bananapus/core/src/interfaces/IJBRulesets.sol\";\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\n\nimport {IJB721Hook} from \"./IJB721Hook.sol\";\nimport {IJB721TokenUriResolver} from \"./IJB721TokenUriResolver.sol\";\nimport {IJB721TiersHookStore} from \"./IJB721TiersHookStore.sol\";\nimport {JB721InitTiersConfig} from \"./../structs/JB721InitTiersConfig.sol\";\nimport {JB721TierConfig} from \"./../structs/JB721TierConfig.sol\";\nimport {JB721TiersHookFlags} from \"./../structs/JB721TiersHookFlags.sol\";\nimport {JB721TiersMintReservesConfig} from \"./../structs/JB721TiersMintReservesConfig.sol\";\n\ninterface IJB721TiersHook is IJB721Hook {\n    event Mint(\n        uint256 indexed tokenId,\n        uint256 indexed tierId,\n        address indexed beneficiary,\n        uint256 totalAmountPaid,\n        address caller\n    );\n\n    event MintReservedNft(uint256 indexed tokenId, uint256 indexed tierId, address indexed beneficiary, address caller);\n\n    event AddTier(uint256 indexed tierId, JB721TierConfig tier, address caller);\n\n    event RemoveTier(uint256 indexed tierId, address caller);\n\n    event SetEncodedIPFSUri(uint256 indexed tierId, bytes32 encodedIPFSUri, address caller);\n\n    event SetBaseUri(string indexed baseUri, address caller);\n\n    event SetContractUri(string indexed contractUri, address caller);\n\n    event SetTokenUriResolver(IJB721TokenUriResolver indexed newResolver, address caller);\n\n    event AddPayCredits(\n        uint256 indexed amount, uint256 indexed newTotalCredits, address indexed account, address caller\n    );\n\n    event UsePayCredits(\n        uint256 indexed amount, uint256 indexed newTotalCredits, address indexed account, address caller\n    );\n\n    function CODE_ORIGIN() external view returns (address);\n\n    function STORE() external view returns (IJB721TiersHookStore);\n\n    function RULESETS() external view returns (IJBRulesets);\n\n    function pricingContext() external view returns (uint256, uint256, IJBPrices);\n\n    function payCreditsOf(address addr) external view returns (uint256);\n\n    function firstOwnerOf(uint256 tokenId) external view returns (address);\n\n    function baseURI() external view returns (string memory);\n\n    function contractURI() external view returns (string memory);\n\n    function adjustTiers(JB721TierConfig[] memory tierDataToAdd, uint256[] memory tierIdsToRemove) external;\n\n    function mintPendingReservesFor(JB721TiersMintReservesConfig[] memory reserveMintConfigs) external;\n\n    function mintPendingReservesFor(uint256 tierId, uint256 count) external;\n\n    function mintFor(uint16[] calldata tierIds, address beneficiary) external returns (uint256[] memory tokenIds);\n\n    function setMetadata(\n        string memory baseUri,\n        string calldata contractMetadataUri,\n        IJB721TokenUriResolver tokenUriResolver,\n        uint256 encodedIPFSUriTierId,\n        bytes32 encodedIPFSUri\n    )\n        external;\n\n    function initialize(\n        uint256 projectId,\n        string memory name,\n        string memory symbol,\n        IJBRulesets rulesets,\n        string memory baseUri,\n        IJB721TokenUriResolver tokenUriResolver,\n        string memory contractUri,\n        JB721InitTiersConfig memory tiersConfig,\n        IJB721TiersHookStore store,\n        JB721TiersHookFlags memory flags\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBDeploy721TiersHookConfig} from \"../structs/JBDeploy721TiersHookConfig.sol\";\nimport {IJB721TiersHook} from \"./IJB721TiersHook.sol\";\n\ninterface IJB721TiersHookDeployer {\n    event HookDeployed(uint256 indexed projectId, IJB721TiersHook newHook);\n\n    function deployHookFor(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig memory deployTiersHookConfig\n    )\n        external\n        returns (IJB721TiersHook hook);\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TiersHookStore.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TokenUriResolver} from \"./IJB721TokenUriResolver.sol\";\nimport {JB721TierConfig} from \"../structs/JB721TierConfig.sol\";\nimport {JB721Tier} from \"../structs/JB721Tier.sol\";\nimport {JB721TiersHookFlags} from \"../structs/JB721TiersHookFlags.sol\";\n\ninterface IJB721TiersHookStore {\n    event CleanTiers(address indexed hook, address caller);\n\n    function totalSupplyOf(address hook) external view returns (uint256);\n\n    function balanceOf(address hook, address owner) external view returns (uint256);\n\n    function maxTierIdOf(address hook) external view returns (uint256);\n\n    function tiersOf(\n        address hook,\n        uint256[] calldata categories,\n        bool includeResolvedUri,\n        uint256 startingSortIndex,\n        uint256 size\n    )\n        external\n        view\n        returns (JB721Tier[] memory tiers);\n\n    function tierOf(address hook, uint256 id, bool includeResolvedUri) external view returns (JB721Tier memory tier);\n\n    function tierBalanceOf(address hook, address owner, uint256 tier) external view returns (uint256);\n\n    function tierOfTokenId(\n        address hook,\n        uint256 tokenId,\n        bool includeResolvedUri\n    )\n        external\n        view\n        returns (JB721Tier memory tier);\n\n    function tierIdOfToken(uint256 tokenId) external pure returns (uint256);\n\n    function encodedIPFSUriOf(address hook, uint256 tierId) external view returns (bytes32);\n\n    function redemptionWeightOf(address hook, uint256[] memory tokenIds) external view returns (uint256 weight);\n\n    function totalRedemptionWeight(address hook) external view returns (uint256 weight);\n\n    function numberOfPendingReservesFor(address hook, uint256 tierId) external view returns (uint256);\n\n    function numberOfReservesMintedFor(address hook, uint256 tierId) external view returns (uint256);\n\n    function numberOfBurnedFor(address hook, uint256 tierId) external view returns (uint256);\n\n    function isTierRemoved(address hook, uint256 tierId) external view returns (bool);\n\n    function flagsOf(address hook) external view returns (JB721TiersHookFlags memory);\n\n    function votingUnitsOf(address hook, address account) external view returns (uint256 units);\n\n    function tierVotingUnitsOf(address hook, address account, uint256 tierId) external view returns (uint256 units);\n\n    function defaultReserveBeneficiaryOf(address hook) external view returns (address);\n\n    function reserveBeneficiaryOf(address hook, uint256 tierId) external view returns (address);\n\n    function tokenUriResolverOf(address hook) external view returns (IJB721TokenUriResolver);\n\n    function encodedTierIPFSUriOf(address hook, uint256 tokenId) external view returns (bytes32);\n\n    function recordAddTiers(JB721TierConfig[] memory tierData) external returns (uint256[] memory tierIds);\n\n    function recordMintReservesFor(uint256 tierId, uint256 count) external returns (uint256[] memory tokenIds);\n\n    function recordBurn(uint256[] memory tokenIds) external;\n\n    function recordMint(\n        uint256 amount,\n        uint16[] calldata tierIds,\n        bool isOwnerMint\n    )\n        external\n        returns (uint256[] memory tokenIds, uint256 leftoverAmount);\n\n    function recordTransferForTier(uint256 tierId, address from, address to) external;\n\n    function recordRemoveTierIds(uint256[] memory tierIds) external;\n\n    function recordSetTokenUriResolver(IJB721TokenUriResolver resolver) external;\n\n    function recordSetEncodedIPFSUriOf(uint256 tierId, bytes32 encodedIPFSUri) external;\n\n    function recordFlags(JB721TiersHookFlags calldata flag) external;\n\n    function cleanTiers(address hook) external;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/interfaces/IJB721TokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJB721TokenUriResolver {\n    function tokenUriOf(address nft, uint256 tokenId) external view returns (string memory tokenUri);\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721InitTiersConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {JB721TierConfig} from \"./JB721TierConfig.sol\";\n\n/// @notice Config to initialize a `JB721TiersHook` with tiers and price data.\n/// @dev The `tiers` must be sorted by price (from least to greatest).\n/// @custom:member tiers The tiers to initialize the hook with.\n/// @custom:member currency The currency that the tier prices are denoted in. See `JBPrices`.\n/// @custom:member decimals The number of decimals in the fixed point tier prices.\n/// @custom:member prices A contract that exposes price feeds that can be used to calculate prices in different\n/// currencies. To only accept payments in `currency`, set `prices` to the zero address. See `JBPrices`.\nstruct JB721InitTiersConfig {\n    JB721TierConfig[] tiers;\n    uint32 currency;\n    uint8 decimals;\n    IJBPrices prices;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721Tier.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member id The tier's ID.\n/// @custom:member price The price to buy an NFT in this tier, in terms of the currency in its `JBInitTiersConfig`.\n/// @custom:member remainingSupply The remaining number of NFTs which can be minted from this tier.\n/// @custom:member initialSupply The total number of NFTs which can be minted from this tier.\n/// @custom:member votingUnits The number of votes that each NFT in this tier gets.\n/// @custom:member reserveFrequency The frequency at which an extra NFT is minted for the `reserveBeneficiary` from this\n/// tier. With a `reserveFrequency` of 5, an extra NFT will be minted for the `reserveBeneficiary` for every 5 NFTs\n/// purchased.\n/// @custom:member reserveBeneficiary The address which receives any reserve NFTs from this tier.\n/// @custom:member encodedIPFSUri The IPFS URI to use for each NFT in this tier.\n/// @custom:member category The category that NFTs in this tier belongs to. Used to group NFT tiers.\n/// @custom:member allowOwnerMint A boolean indicating whether the contract's owner can mint NFTs from this tier\n/// on-demand.\n/// @custom:member cannotBeRemoved A boolean indicating whether attempts to remove this tier will revert.\n/// @custom:member transfersPausable A boolean indicating whether transfers for NFTs in tier can be paused.\n/// @custom:member resolvedUri A resolved token URI for NFTs in this tier. Only available if the NFT this tier belongs\n/// to has a resolver.\nstruct JB721Tier {\n    uint256 id;\n    uint256 price;\n    uint256 remainingSupply;\n    uint256 initialSupply;\n    uint256 votingUnits;\n    uint256 reserveFrequency;\n    address reserveBeneficiary;\n    bytes32 encodedIPFSUri;\n    uint256 category;\n    bool allowOwnerMint;\n    bool transfersPausable;\n    bool cannotBeRemoved;\n    string resolvedUri;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TierConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Config for a single NFT tier within a `JB721TiersHook`.\n/// @custom:member price The price to buy an NFT in this tier, in terms of the currency in its `JBInitTiersConfig`.\n/// @custom:member initialSupply The total number of NFTs which can be minted from this tier.\n/// @custom:member votingUnits The number of votes that each NFT in this tier gets if `useVotingUnits` is true.\n/// @custom:member reserveFrequency The frequency at which an extra NFT is minted for the `reserveBeneficiary` from this\n/// tier. With a `reserveFrequency` of 5, an extra NFT will be minted for the `reserveBeneficiary` for every 5 NFTs\n/// purchased.\n/// @custom:member reserveBeneficiary The address which receives any reserve NFTs from this tier. Overrides the default\n/// reserve beneficiary if one is set.\n/// @custom:member encodedIPFSUri The IPFS URI to use for each NFT in this tier.\n/// @custom:member category The category that NFTs in this tier belongs to. Used to group NFT tiers.\n/// @custom:member allowOwnerMint A boolean indicating whether the contract's owner can mint NFTs from this tier\n/// on-demand.\n/// @custom:member useReserveBeneficiaryAsDefault A boolean indicating whether this tier's `reserveBeneficiary` should\n/// be stored as the default beneficiary for all tiers.\n/// @custom:member transfersPausable A boolean indicating whether transfers for NFTs in tier can be paused.\n/// @custom:member useVotingUnits A boolean indicating whether the `votingUnits` should be used to calculate voting\n/// power. If `useVotingUnits` is false, voting power is based on the tier's price.\n/// @custom:member cannotBeRemoved If the tier cannot be removed once added.\nstruct JB721TierConfig {\n    uint104 price;\n    uint32 initialSupply;\n    uint32 votingUnits;\n    uint16 reserveFrequency;\n    address reserveBeneficiary;\n    bytes32 encodedIPFSUri;\n    uint24 category;\n    bool allowOwnerMint;\n    bool useReserveBeneficiaryAsDefault;\n    bool transfersPausable;\n    bool useVotingUnits;\n    bool cannotBeRemoved;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TiersHookFlags.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member noNewTiersWithReserves A boolean indicating whether attempts to add new tiers with a non-zero\n/// `reserveFrequency` will revert.\n/// @custom:member noNewTiersWithVotes A boolean indicating whether attempts to add new tiers with non-zero\n/// `votingUnits` will revert.\n/// @custom:member noNewTiersWithOwnerMinting A boolean indicating whether attempts to add new tiers with\n/// `allowOwnerMint` set to true will revert.\n/// @custom:member preventOverspending A boolean indicating whether payments attempting to spend more than the price of\n/// the NFTs being minted will revert.\nstruct JB721TiersHookFlags {\n    bool noNewTiersWithReserves;\n    bool noNewTiersWithVotes;\n    bool noNewTiersWithOwnerMinting;\n    bool preventOverspending;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JB721TiersMintReservesConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member tierId The ID of the tier to mint from.\n/// @custom:member count The number of NFTs to mint from that tier.\nstruct JB721TiersMintReservesConfig {\n    uint256 tierId;\n    uint256 count;\n}\n"
			},
			"node_modules/@bananapus/721-hook/src/structs/JBDeploy721TiersHookConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesets} from \"@bananapus/core/src/interfaces/IJBRulesets.sol\";\nimport {IJB721TokenUriResolver} from \"../interfaces/IJB721TokenUriResolver.sol\";\nimport {JB721InitTiersConfig} from \"./JB721InitTiersConfig.sol\";\nimport {JB721TiersHookFlags} from \"./JB721TiersHookFlags.sol\";\n\n/// @custom:member name The NFT collection's name.\n/// @custom:member symbol The NFT collection's symbol.\n/// @custom:member rulesets The contract storing and managing project rulesets.\n/// @custom:member baseUri The URI to use as a base for full NFT URIs.\n/// @custom:member tokenUriResolver The contract responsible for resolving the URI for each NFT.\n/// @custom:member contractUri The URI where this contract's metadata can be found.\n/// @custom:member tiersConfig The NFT tiers and pricing config to launch the hook with.\n/// @custom:member reserveBeneficiary The default reserved beneficiary for all tiers.\n/// @custom:member store The contract to store and manage this hook's data.\n/// @custom:member flags A set of boolean options to configure the hook with.\nstruct JBDeploy721TiersHookConfig {\n    string name;\n    string symbol;\n    IJBRulesets rulesets;\n    string baseUri;\n    IJB721TokenUriResolver tokenUriResolver;\n    string contractUri;\n    JB721InitTiersConfig tiersConfig;\n    address reserveBeneficiary;\n    JB721TiersHookFlags flags;\n}\n"
			},
			"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IJBPermissioned} from \"./../interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./../interfaces/IJBPermissions.sol\";\n\n/// @notice Modifiers to allow access to transactions based on which permissions the message's sender has.\nabstract contract JBPermissioned is Context, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n    error UNAUTHORIZED();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    constructor(IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Require the message sender to be the account or have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view {\n        address sender = _msgSender();\n        if (\n            sender != account && !PERMISSIONS.hasPermission(sender, account, projectId, permissionId)\n                && !PERMISSIONS.hasPermission(sender, account, 0, permissionId)\n        ) revert UNAUTHORIZED();\n    }\n\n    /// @notice If the 'alsoGrantAccessIf' condition is truthy, proceed. Otherwise, require the message sender to be the\n    /// account or\n    /// have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n    {\n        if (alsoGrantAccessIf) return;\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId, uint256 indexed pricingCurrency, uint256 indexed unitCurrency, IJBPriceFeed feed\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed priceFeed\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice Library to parse and create metadata to store {id: data} entries.\n *\n * @dev    Metadata are built as:\n *         - 32B of reserved space for the protocol\n *         - a lookup table `Id: offset`, defining the offset of the data for a given 4 bytes id.\n *           The offset fits 1 bytes, the ID 4 bytes. This table is padded to 32B.\n *         - the data for each id, padded to 32B each\n *\n *            +-----------------------+ offset: 0\n *            | 32B reserved          |\n *            +-----------------------+ offset: 1 = end of first 32B\n *            |      (ID1,offset1)    |\n *            |      (ID2,offset2)    |\n *            |       0's padding     |\n *            +-----------------------+ offset: offset1 = 1 + number of words taken by the padded table\n *            |       id1 data1       |\n *            | 0's padding           |\n *            +-----------------------+ offset: offset2 = offset1 + number of words taken by the data1\n *            |       id2 data2       |\n *            | 0's padding           |\n *            +-----------------------+\n */\nlibrary JBMetadataResolver {\n    error LENGTH_MISMATCH();\n    error METADATA_TOO_LONG();\n    error METADATA_TOO_SHORT();\n\n    // The various sizes used in bytes.\n    uint256 constant ID_SIZE = 4;\n    uint256 constant ID_OFFSET_SIZE = 1;\n    uint256 constant WORD_SIZE = 32;\n\n    // The size that an ID takes in the lookup table (Identifier + Offset).\n    uint256 constant TOTAL_ID_SIZE = 5; // ID_SIZE + ID_OFFSET_SIZE;\n\n    // The amount of bytes to go forward to get to the offset of the next ID (aka. the end of the offset of the current\n    // ID).\n    uint256 constant NEXT_ID_OFFSET = 9; // TOTAL_ID_SIZE + ID_SIZE;\n\n    // 1 word (32B) is reserved for the protocol .\n    uint256 constant RESERVED_SIZE = 32; // 1 * WORD_SIZE;\n    uint256 constant MIN_METADATA_LENGTH = 37; // RESERVED_SIZE + ID_SIZE + ID_OFFSET_SIZE;\n\n    /**\n     * @notice Parse the metadata to find the data for a specific ID\n     *\n     * @dev    Returns false and an empty bytes if no data is found\n     *\n     * @param  id             The ID to find\n     * @param  metadata       The metadata to parse\n     *\n     * @return found          Whether the {id:data} was found\n     * @return targetData The data for the ID (can be empty)\n     */\n    function getDataFor(bytes4 id, bytes memory metadata) internal pure returns (bool found, bytes memory targetData) {\n        // Either no data or empty one with only one selector (32+4+1)\n        if (metadata.length <= MIN_METADATA_LENGTH) return (false, \"\");\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)\n        uint256 firstOffset = uint8(metadata[RESERVED_SIZE + ID_SIZE]);\n\n        // Parse the id's to find id, stop when next offset == 0 or current = first offset\n        for (uint256 i = RESERVED_SIZE; metadata[i + ID_SIZE] != bytes1(0) && i < firstOffset * WORD_SIZE;) {\n            uint256 currentOffset = uint256(uint8(metadata[i + ID_SIZE]));\n\n            bytes4 parsedId;\n            assembly {\n                parsedId := mload(add(add(metadata, 0x20), i))\n            }\n\n            // _id found?\n            if (parsedId == id) {\n                // Are we at the end of the lookup table (either at the start of data's or next offset is 0/in the\n                // padding)\n                // If not, only return until from this offset to the begining of the next offset\n                uint256 end = (i + NEXT_ID_OFFSET >= firstOffset * WORD_SIZE || metadata[i + NEXT_ID_OFFSET] == 0)\n                    ? metadata.length\n                    : uint256(uint8(metadata[i + NEXT_ID_OFFSET])) * WORD_SIZE;\n\n                return (true, _sliceBytes(metadata, currentOffset * WORD_SIZE, end));\n            }\n            unchecked {\n                i += TOTAL_ID_SIZE;\n            }\n        }\n    }\n\n    /**\n     * @notice Add an {id: data} entry to an existing metadata. This is an append-only mechanism.\n     *\n     * @param originalMetadata The original metadata\n     * @param idToAdd          The id to add\n     * @param dataToAdd        The data to add\n     *\n     * @return newMetadata    The new metadata with the entry added\n     */\n    function addToMetadata(\n        bytes memory originalMetadata,\n        bytes4 idToAdd,\n        bytes memory dataToAdd\n    )\n        internal\n        pure\n        returns (bytes memory newMetadata)\n    {\n        // Empty original metadata and maybe something in the first 32 bytes: create new metadata\n        if (originalMetadata.length <= RESERVED_SIZE) {\n            return abi.encodePacked(bytes32(originalMetadata), bytes32(abi.encodePacked(idToAdd, uint8(2))), dataToAdd);\n        }\n\n        // There is something in the table offset, but not a valid entry - avoid overwriting\n        if (originalMetadata.length < RESERVED_SIZE + ID_SIZE + 1) revert METADATA_TOO_SHORT();\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)...\n        uint256 firstOffset = uint8(originalMetadata[RESERVED_SIZE + ID_SIZE]);\n\n        // ...go back to the beginning of the previous word (ie the last word of the table, as it can be padded)\n        uint256 lastWordOfTable = firstOffset - 1;\n\n        // The last offset stored in the table and its index\n        uint256 lastOffset;\n\n        uint256 lastOffsetIndex;\n\n        // The number of words taken by the last data stored\n        uint256 numberOfWordslastData;\n\n        // Iterate to find the last entry of the table, lastOffset - we start from the end as the first value\n        // encountered\n        // will be the last offset\n        for (uint256 i = firstOffset * WORD_SIZE - 1; i > lastWordOfTable * WORD_SIZE - 1; i--) {\n            // If the byte is not 0, this is the last offset we're looking for\n            if (originalMetadata[i] != 0) {\n                lastOffset = uint8(originalMetadata[i]);\n                lastOffsetIndex = i;\n\n                // No rounding as this should be padded to 32B\n                numberOfWordslastData = (originalMetadata.length - lastOffset * WORD_SIZE) / WORD_SIZE;\n\n                // Copy the reserved word and the table and remove the previous padding\n                newMetadata = _sliceBytes(originalMetadata, 0, lastOffsetIndex + 1);\n\n                // Check if the new entry is still fitting in this word\n                if (i + TOTAL_ID_SIZE >= firstOffset * WORD_SIZE) {\n                    // Increment every offset by 1 (as the table now takes one more word)\n                    for (uint256 j = RESERVED_SIZE + ID_SIZE; j < lastOffsetIndex + 1; j += TOTAL_ID_SIZE) {\n                        newMetadata[j] = bytes1(uint8(originalMetadata[j]) + 1);\n                    }\n\n                    // Increment the last offset so the new offset will be properly set too\n                    lastOffset++;\n                }\n\n                break;\n            }\n        }\n\n        // Add the new entry after the last entry of the table, the new offset is the last offset + the number of words\n        // taken by the last data\n        newMetadata = abi.encodePacked(newMetadata, idToAdd, bytes1(uint8(lastOffset + numberOfWordslastData)));\n\n        // Pad as needed - inlined for gas saving\n        uint256 paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Add existing data at the end\n        newMetadata = abi.encodePacked(\n            newMetadata, _sliceBytes(originalMetadata, firstOffset * WORD_SIZE, originalMetadata.length)\n        );\n\n        // Pad as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Append new data at the end\n        newMetadata = abi.encodePacked(newMetadata, dataToAdd);\n\n        // Pad again again as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n    }\n\n    /**\n     * @notice Create the metadata for a list of {id:data}\n     *\n     * @dev    Intended for offchain use (gas heavy)\n     *\n     * @param _ids             The list of ids\n     * @param _datas       The list of corresponding datas\n     *\n     * @return metadata       The resulting metadata\n     */\n    function createMetadata(\n        bytes4[] memory _ids,\n        bytes[] memory _datas\n    )\n        internal\n        pure\n        returns (bytes memory metadata)\n    {\n        if (_ids.length != _datas.length) revert LENGTH_MISMATCH();\n\n        // Add a first empty 32B for the protocol reserved word\n        metadata = abi.encodePacked(bytes32(0));\n\n        // First offset for the data is after the first reserved word...\n        uint256 _offset = 1;\n\n        // ... and after the id/offset lookup table, rounding up to 32 bytes words if not a multiple\n        _offset += ((_ids.length * JBMetadataResolver.TOTAL_ID_SIZE) - 1) / JBMetadataResolver.WORD_SIZE + 1;\n\n        // For each id, add it to the lookup table with the next free offset, then increment the offset by the data\n        // length (rounded up)\n        for (uint256 _i; _i < _ids.length; ++_i) {\n            metadata = abi.encodePacked(metadata, _ids[_i], bytes1(uint8(_offset)));\n            _offset += _datas[_i].length / JBMetadataResolver.WORD_SIZE;\n\n            // Overflowing a bytes1?\n            if (_offset > 2 ** 8) revert METADATA_TOO_LONG();\n        }\n\n        // Pad the table to a multiple of 32B\n        uint256 _paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n            ? metadata.length\n            : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n        assembly {\n            mstore(metadata, _paddedLength)\n        }\n\n        // Add each metadata to the array, each padded to 32 bytes\n        for (uint256 _i; _i < _datas.length; _i++) {\n            metadata = abi.encodePacked(metadata, _datas[_i]);\n            _paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n                ? metadata.length\n                : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n\n            assembly {\n                mstore(metadata, _paddedLength)\n            }\n        }\n    }\n\n    /// @notice Slice bytes from a start index to an end index.\n    /// @param data The bytes array to slice\n    /// @param start The start index to slice at.\n    /// @param end The end index to slice at.\n    /// @param slicedBytes The sliced array.\n    function _sliceBytes(\n        bytes memory data,\n        uint256 start,\n        uint256 end\n    )\n        internal\n        pure\n        returns (bytes memory slicedBytes)\n    {\n        assembly {\n            let length := sub(end, start)\n\n            // Allocate memory at the freemem(add 0x20 to include the length)\n            slicedBytes := mload(0x40)\n            mstore(0x40, add(add(slicedBytes, length), 0x20))\n\n            // Store the length (first element)\n            mstore(slicedBytes, length)\n\n            // compute the actual data first offset only once\n            let startBytes := add(add(data, 0x20), start)\n\n            // same for the out array\n            let sliceBytesStartOfData := add(slicedBytes, 0x20)\n\n            // store dem data\n            for { let i := 0 } lt(i, end) { i := add(i, 0x20) } {\n                mstore(add(sliceBytesStartOfData, i), mload(add(startBytes, i)))\n            }\n        }\n    }\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\n\nimport {JBOwnableOverrides} from \"./JBOwnableOverrides.sol\";\n\ncontract JBOwnable is JBOwnableOverrides {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    constructor(IJBProjects projects, IJBPermissions permissions) JBOwnableOverrides(projects, permissions) {}\n\n    /// @notice Reverts if called by an address that is not the owner and does not have permission from the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    function _emitTransferEvent(\n        address previousOwner,\n        address newOwner,\n        uint88 newProjectId\n    )\n        internal\n        virtual\n        override\n    {\n        emit OwnershipTransferred(previousOwner, newProjectId == 0 ? newOwner : PROJECTS.ownerOf(newProjectId));\n    }\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnableOverrides.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBPermissioned} from \"@bananapus/core/src/interfaces/IJBPermissioned.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\n\nimport {JBOwner} from \"./struct/JBOwner.sol\";\nimport {IJBOwnable} from \"./interfaces/IJBOwnable.sol\";\n\n/// @notice Access control module to grant exclusive access to a specified address (the owner) for specific functions.\n/// The owner can also grant access permissions to other addresses via `JBPermissions`.\n/// @dev Inherit this contract to make the `onlyOwner` modifier available. When applied to a function, this modifier\n/// restricts use to the owner and addresses with the appropriate permission from the owner.\n/// @dev Supports meta-transactions.\nabstract contract JBOwnableOverrides is Context, IJBOwnable, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors --------------------------//\n    //*********************************************************************//\n\n    error UNAUTHORIZED();\n    error INVALID_NEW_OWNER();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable PERMISSIONS;\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable PROJECTS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice This contract's owner information.\n    JBOwner public override jbOwner;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    constructor(IJBProjects projects, IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n        PROJECTS = projects;\n\n        _transferOwnership(_initialOwner());\n    }\n\n    //*********************************************************************//\n    // --------------------------- public methods ------------------------ //\n    //*********************************************************************//\n\n    /// @notice Returns the owner's address based on this contract's `JBOwner` owner information.\n    function owner() public view virtual returns (address) {\n        JBOwner memory ownerInfo = jbOwner;\n\n        if (ownerInfo.projectId == 0) {\n            return ownerInfo.owner;\n        }\n\n        return PROJECTS.ownerOf(ownerInfo.projectId);\n    }\n\n    /// @notice Gives up ownership of this contract, making it impossible to call `onlyOwner`/`_checkOwner` functions.\n    /// Can only be called by the current owner.\n    function renounceOwnership() public virtual {\n        _checkOwner();\n        _transferOwnership(address(0), 0);\n    }\n\n    /// @notice Transfers ownership of this contract to a new account (the `newOwner`). Can only be called by the\n    /// current owner.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function transferOwnership(address newOwner) public virtual {\n        _checkOwner();\n        if (newOwner == address(0)) {\n            revert INVALID_NEW_OWNER();\n        }\n\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfer ownership of this contract to a new Juicebox project.\n    /// @dev The `projectId` must fit within a `uint88`.\n    /// @param projectId The ID of the project that should receive ownership of this contract.\n    function transferOwnershipToProject(uint256 projectId) public virtual {\n        _checkOwner();\n        if (projectId == 0 || projectId > type(uint88).max) {\n            revert INVALID_NEW_OWNER();\n        }\n\n        _transferOwnership(address(0), uint88(projectId));\n    }\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function setPermissionId(uint8 permissionId) public virtual {\n        _checkOwner();\n        _setPermissionId(permissionId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal methods ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @dev Internal function without access restriction.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function _setPermissionId(uint8 permissionId) internal virtual {\n        jbOwner.permissionId = permissionId;\n        emit PermissionIdChanged(permissionId);\n    }\n\n    /// @notice Helper to allow for drop-in replacement of OpenZeppelin.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function _transferOwnership(address newOwner) internal virtual {\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfers this contract's ownership to an address (`newOwner`) OR a Juicebox project (`projectId`).\n    /// @dev Updates this contract's `JBOwner` owner information.\n    /// @dev If both `newOwner` and `projectId` are set, this will revert.\n    /// @dev Internal function without access restriction.\n    /// @param newOwner The address that should receive ownership of this contract.\n    /// @param projectId The ID of the project that this contract should respect the ownership of.\n    function _transferOwnership(address newOwner, uint88 projectId) internal virtual {\n        // Can't set both a new owner and a new project ID.\n        if (projectId != 0 && newOwner != address(0)) {\n            revert INVALID_NEW_OWNER();\n        }\n        // Load the owner information from storage.\n        JBOwner memory ownerInfo = jbOwner;\n        // Get the address of the old owner.\n        address oldOwner = ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId);\n        // Update the stored owner information to the new owner and reset the `permissionId`.\n        // This is to prevent permissions clashes for the new user/owner.\n        jbOwner = JBOwner({owner: newOwner, projectId: projectId, permissionId: 0});\n        // Emit a transfer event with the new owner's address.\n        _emitTransferEvent(oldOwner, newOwner, projectId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Reverts if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        JBOwner memory ownerInfo = jbOwner;\n\n        _requirePermissionFrom({\n            account: ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId),\n            projectId: ownerInfo.projectId,\n            permissionId: ownerInfo.permissionId\n        });\n    }\n\n    /// @notice Only allows the specified account or an operator with the specified permission ID from that account to\n    /// proceed.\n    /// @param account The account to allow.\n    /// @param projectId The ID of the project to look for an operator within.\n    /// @param permissionId The ID of the permission to check for.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view virtual {\n        address sender = _msgSender();\n        if (\n            sender != account && !PERMISSIONS.hasPermission(sender, account, projectId, permissionId)\n                && !PERMISSIONS.hasPermission(sender, account, 0, permissionId)\n        ) revert UNAUTHORIZED();\n    }\n\n    /// @notice If the `override` flag is true, proceed. Otherwise, only allows the specified account or an operator\n    /// with the specified permission ID from that account to proceed.\n    /// @param account The account to allow.\n    /// @param projectId The ID of the pproject to look for an operator within. TODO: remove\n    /// @param permissionId The ID of the permission to check for.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.     */\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n        virtual\n    {\n        // Return early if the override flag is true.\n        if (alsoGrantAccessIf) return;\n        // Otherwise, perform a standard check.\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n\n    /// @notice returns the address that should become the owner on deployment.\n    /// @return _owner the address that will become the owner when this contract is deployed.\n    function _initialOwner() internal view virtual returns (address _owner) {\n        return _msgSender();\n    }\n\n    /// @notice Either `newOwner` or `newProjectId` is non-zero or both are zero. But they can never both be non-zero.\n    function _emitTransferEvent(address previousOwner, address newOwner, uint88 newProjectId) internal virtual;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/interfaces/IJBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IJBOwnable {\n    event PermissionIdChanged(uint8 newIndex);\n\n    function jbOwner() external view returns (address owner, uint88 projectOwner, uint8 permissionId);\n\n    function transferOwnershipToProject(uint256 projectId) external;\n\n    function setPermissionId(uint8 permissionId) external;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/struct/JBOwner.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/// @notice Owner information for a given instance of `JBOwnableOverrides`.\n/// @custom:member owner If `projectId` is 0 and this is set, this static address has owner access.\n/// @custom:member projectId Unless this is 0, this project's owner has owner access.\n/// @custom:member permissionId The ID of the permission required from the project's owner to have owner access. See\n/// `JBPermissions` in `juice-contracts-v4`.\nstruct JBOwner {\n    address owner;\n    uint88 projectId;\n    uint8 permissionId;\n}\n"
			},
			"node_modules/@croptop/core/src/CTPublisher.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBTerminal} from \"@bananapus/core/src/interfaces/terminal/IJBTerminal.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\nimport {JBMetadataResolver} from \"@bananapus/core/src/libraries/JBMetadataResolver.sol\";\nimport {JBRulesetMetadata} from \"@bananapus/core/src/structs/JBRulesetMetadata.sol\";\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {JB721Tier} from \"@bananapus/721-hook/src/structs/JB721Tier.sol\";\nimport {JB721TierConfig} from \"@bananapus/721-hook/src/structs/JB721TierConfig.sol\";\nimport {JBOwnable} from \"@bananapus/ownable/src/JBOwnable.sol\";\n\nimport {CTAllowedPost} from \"./structs/CTAllowedPost.sol\";\nimport {CTPost} from \"./structs/CTPost.sol\";\n\n/// @notice A contract that facilitates the permissioned publishing of NFT posts to a Juicebox project.\ncontract CTPublisher is JBPermissioned {\n    error TOTAL_SUPPY_MUST_BE_POSITIVE();\n    error EMPTY_ENCODED_IPFS_URI(bytes32 encodedUri);\n    error INCOMPATIBLE_PROJECT(uint256 projectId, address dataSource, bytes4 expectedInterfaceId);\n    error INSUFFICIENT_ETH_SENT(uint256 expected, uint256 sent);\n    error NOT_IN_ALLOW_LIST(address[] allowedAddresses);\n    error MAX_TOTAL_SUPPLY_LESS_THAN_MIN();\n    error HOOK_NOT_PROVIDED();\n    error PRICE_TOO_SMALL(uint256 minimumPrice);\n    error TOTAL_SUPPLY_TOO_SMALL(uint256 minimumTotalSupply);\n    error TOTAL_SUPPLY_TOO_BIG(uint256 maximumTotalSupply);\n    error UNAUTHORIZED_TO_POST_IN_CATEGORY();\n\n    event ConfigurePostingCriteria(uint256 indexed projectId, CTAllowedPost[] allowedPosts, address caller);\n\n    event Mint(\n        uint256 indexed projectId,\n        address indexed nftBeneficiary,\n        address indexed feeBeneficiary,\n        CTPost[] posts,\n        uint256 fee,\n        address caller\n    );\n\n    /// @notice Packed values that determine the allowance of posts.\n    /// @custom:param projectId The ID of the project.\n    /// @custom:param nft The NFT contract for which this allowance applies.\n    /// @custom:param category The category for which the allowance applies\n    mapping(uint256 projectId => mapping(address nft => mapping(uint256 category => uint256))) internal\n        _packedAllowanceFor;\n\n    /// @notice Stores addresses that are allowed to post onto an NFT category.\n    /// @custom:param projectId The ID of the project.\n    /// @custom:param nft The NFT contract for which this allowance applies.\n    /// @custom:param category The category for which the allowance applies.\n    /// @custom:param address The address to check an allowance for.\n    mapping(uint256 projectId => mapping(address nft => mapping(uint256 category => address[]))) internal\n        _allowedAddresses;\n\n    /// @notice The ID of the tier that an IPFS metadata has been saved to.\n    /// @custom:param projectId The ID of the project.\n    /// @custom:param encodedIPFSUri The IPFS URI.\n    mapping(uint256 projectId => mapping(bytes32 encodedIPFSUri => uint256)) public tierIdForEncodedIPFSUriOf;\n\n    /// @notice The divisor that describes the fee that should be taken.\n    /// @dev This is equal to 100 divided by the fee percent.\n    uint256 public constant FEE_DIVISOR = 20;\n\n    /// @notice The controller that directs the projects being posted to.\n    IJBController public immutable CONTROLLER;\n\n    /// @notice The ID of the project to which fees will be routed.\n    uint256 public immutable FEE_PROJECT_ID;\n\n    /// @notice Get the tiers for the provided encoded IPFS URIs.\n    /// @param projectId The ID of the project from which the tiers are being sought.\n    /// @param nft The NFT from which to get tiers.\n    /// @param encodedIPFSUris The URIs to get tiers of.\n    /// @return tiers The tiers that correspond to the provided encoded IPFS URIs. If there's no tier yet, an empty tier\n    /// is returned.\n    function tiersFor(\n        uint256 projectId,\n        address nft,\n        bytes32[] memory encodedIPFSUris\n    )\n        external\n        view\n        returns (JB721Tier[] memory tiers)\n    {\n        uint256 numberOfEncodedIPFSUris = encodedIPFSUris.length;\n\n        // Initialize the tier array being returned.\n        tiers = new JB721Tier[](numberOfEncodedIPFSUris);\n\n        if (nft == address(0)) {\n            // Get the projects current data source from its current ruleset's metadata.\n            (, JBRulesetMetadata memory metadata) = CONTROLLER.currentRulesetOf(projectId);\n\n            // Set the NFT as the data hook.\n            nft = metadata.dataHook;\n        }\n\n        // Get the tier for each provided encoded IPFS URI.\n        for (uint256 i; i < numberOfEncodedIPFSUris; i++) {\n            // Check if there's a tier ID stored for the encoded IPFS URI.\n            uint256 tierId = tierIdForEncodedIPFSUriOf[projectId][encodedIPFSUris[i]];\n\n            // If there's a tier ID stored, resolve it.\n            if (tierId != 0) {\n                tiers[i] = IJB721TiersHook(nft).STORE().tierOf(nft, tierId, false);\n            }\n        }\n    }\n\n    /// @notice Post allowances for a particular category on a particular NFT.\n    /// @param projectId The ID of the project.\n    /// @param nft The NFT contract for which this allowance applies.\n    /// @param category The category for which this allowance applies.\n    /// @return minimumPrice The minimum price that a poster must pay to record a new NFT.\n    /// @return minimumTotalSupply The minimum total number of available tokens that a minter must set to record a new\n    /// NFT.\n    /// @return maximumTotalSupply The max total supply of NFTs that can be made available when minting. Leave as 0 for\n    /// max.\n    /// @return allowedAddresses The addresses allowed to post. Returns empty if all addresses are allowed.\n    function allowanceFor(\n        uint256 projectId,\n        address nft,\n        uint256 category\n    )\n        public\n        view\n        returns (\n            uint256 minimumPrice,\n            uint256 minimumTotalSupply,\n            uint256 maximumTotalSupply,\n            address[] memory allowedAddresses\n        )\n    {\n        if (nft == address(0)) {\n            // Get the projects current data source from its current funding cyce's metadata.\n            (, JBRulesetMetadata memory metadata) = CONTROLLER.currentRulesetOf(projectId);\n\n            // Set the NFT as the data hook.\n            nft = metadata.dataHook;\n        }\n\n        // Get a reference to the packed values.\n        uint256 packed = _packedAllowanceFor[projectId][nft][category];\n\n        // minimum price in bits 0-103 (104 bits).\n        minimumPrice = uint256(uint104(packed));\n        // minimum supply in bits 104-135 (32 bits).\n        minimumTotalSupply = uint256(uint32(packed >> 104));\n        // minimum supply in bits 136-67 (32 bits).\n        maximumTotalSupply = uint256(uint32(packed >> 136));\n\n        allowedAddresses = _allowedAddresses[projectId][nft][category];\n    }\n\n    /// @param controller The controller that directs the projects being posted to.\n    /// @param permissions A contract storing permissions.\n    /// @param feeProjectId The ID of the project to which fees will be routed.\n    constructor(\n        IJBController controller,\n        IJBPermissions permissions,\n        uint256 feeProjectId\n    )\n        JBPermissioned(permissions)\n    {\n        CONTROLLER = controller;\n        FEE_PROJECT_ID = feeProjectId;\n    }\n\n    /// @notice Publish an NFT to become mintable, and mint a first copy.\n    /// @dev A fee is taken into the appropriate treasury.\n    /// @param projectId The ID of the project to which the NFT should be added.\n    /// @param posts An array of posts that should be published as NFTs to the specified project.\n    /// @param nftBeneficiary The beneficiary of the NFT mints.\n    /// @param feeBeneficiary The beneficiary of the fee project's token.\n    /// @param additionalPayMetadata Metadata bytes that should be included in the pay function's metadata. This\n    /// prepends the\n    /// payload needed for NFT creation.\n    /// @param feeMetadata The metadata to send alongside the fee payment.\n    function mintFrom(\n        uint256 projectId,\n        CTPost[] memory posts,\n        address nftBeneficiary,\n        address feeBeneficiary,\n        bytes calldata additionalPayMetadata,\n        bytes calldata feeMetadata\n    )\n        external\n        payable\n    {\n        // Keep a reference a reference to the fee.\n        uint256 fee;\n\n        // Keep a reference to the mint metadata.\n        bytes memory mintMetadata;\n\n        {\n            // Get the projects current data source from its current funding cyce's metadata.\n            (, JBRulesetMetadata memory metadata) = CONTROLLER.currentRulesetOf(projectId);\n\n            // Check to make sure the project's current data source is a IJBTiered721Delegate.\n            if (!IERC165(metadata.dataHook).supportsInterface(type(IJB721TiersHook).interfaceId)) {\n                revert INCOMPATIBLE_PROJECT(projectId, metadata.dataHook, type(IJB721TiersHook).interfaceId);\n            }\n\n            // Setup the posts.\n            (JB721TierConfig[] memory tiersToAdd, uint256[] memory tierIdsToMint, uint256 totalPrice) =\n                _setupPosts(projectId, metadata.dataHook, posts);\n\n            // Keep a reference to the fee that will be paid.\n            fee = projectId == FEE_PROJECT_ID ? 0 : (totalPrice / FEE_DIVISOR);\n\n            // Make sure the amount sent to this function is at least the specified price of the tier plus the fee.\n            if (totalPrice + fee < msg.value) {\n                revert INSUFFICIENT_ETH_SENT(totalPrice, msg.value);\n            }\n\n            // Add the new tiers.\n            IJB721TiersHook(metadata.dataHook).adjustTiers(tiersToAdd, new uint256[](0));\n\n            // Create the metadata for the payment to specify the tier IDs that should be minted. We create manually the\n            // original metadata, following\n            // the specifications from the JBMetadataResolver library.\n            mintMetadata = JBMetadataResolver.addToMetadata({\n                originalMetadata: additionalPayMetadata,\n                idToAdd: bytes4(bytes20(metadata.dataHook)),\n                dataToAdd: abi.encode(true, tierIdsToMint)\n            });\n\n            // Store the referal id in the first 32 bytes of the metadata (push to stack for immutable in assembly)\n            uint256 feeProjectId = FEE_PROJECT_ID;\n\n            assembly {\n                mstore(add(mintMetadata, 32), feeProjectId)\n            }\n        }\n\n        {\n            // Get a reference to the project's current ETH payment terminal.\n            IJBTerminal projectTerminal = CONTROLLER.DIRECTORY().primaryTerminalOf(projectId, JBConstants.NATIVE_TOKEN);\n\n            // Keep a reference to the amount being paid.\n            uint256 payValue = msg.value - fee;\n\n            // Make the payment.\n            projectTerminal.pay{value: payValue}({\n                projectId: projectId,\n                token: JBConstants.NATIVE_TOKEN,\n                amount: payValue,\n                beneficiary: nftBeneficiary,\n                minReturnedTokens: 0,\n                memo: \"Minted from Croptop\",\n                metadata: mintMetadata\n            });\n        }\n\n        // Pay a fee if there are funds left.\n        if (address(this).balance != 0) {\n            // Get a reference to the fee project's current ETH payment terminal.\n            IJBTerminal feeTerminal = CONTROLLER.DIRECTORY().primaryTerminalOf(FEE_PROJECT_ID, JBConstants.NATIVE_TOKEN);\n\n            // Make the fee payment.\n            feeTerminal.pay{value: address(this).balance}({\n                projectId: FEE_PROJECT_ID,\n                amount: address(this).balance,\n                token: JBConstants.NATIVE_TOKEN,\n                beneficiary: feeBeneficiary,\n                minReturnedTokens: 0,\n                memo: \"\",\n                metadata: feeMetadata\n            });\n        }\n\n        emit Mint(projectId, nftBeneficiary, feeBeneficiary, posts, fee, msg.sender);\n    }\n\n    /// @notice Collection owners can set the allowed criteria for publishing a new NFT to their project.\n    /// @param projectId The ID of the project having its publishing allowances set.\n    /// @param allowedPosts An array of criteria for allowed posts.\n    function configurePostingCriteriaFor(uint256 projectId, CTAllowedPost[] memory allowedPosts) public {\n        // Keep a reference to the number of post criteria.\n        uint256 numberOfAllowedPosts = allowedPosts.length;\n\n        // Keep a reference to the post criteria being iterated on.\n        CTAllowedPost memory allowedPost;\n\n        // For each post criteria, save the specifications.\n        for (uint256 i; i < numberOfAllowedPosts; i++) {\n            // Set the post criteria being iterated on.\n            allowedPost = allowedPosts[i];\n\n            // Enforce permissions.\n            _requirePermissionFrom({\n                account: JBOwnable(allowedPost.nft).owner(),\n                projectId: projectId,\n                permissionId: JBPermissionIds.ADJUST_721_TIERS\n            });\n\n            // Make sure there is a minimum supply.\n            if (allowedPost.minimumTotalSupply == 0) {\n                revert TOTAL_SUPPY_MUST_BE_POSITIVE();\n            }\n\n            // Make sure there is a minimum supply.\n            if (allowedPost.minimumTotalSupply > allowedPost.maximumTotalSupply) {\n                revert MAX_TOTAL_SUPPLY_LESS_THAN_MIN();\n            }\n\n            uint256 packed;\n            // minimum price in bits 0-103 (104 bits).\n            packed |= uint256(allowedPost.minimumPrice);\n            // minimum total supply in bits 104-135 (32 bits).\n            packed |= uint256(allowedPost.minimumTotalSupply) << 104;\n            // maximum total supply in bits 136-167 (32 bits).\n            packed |= uint256(allowedPost.maximumTotalSupply) << 136;\n            // Store the packed value.\n            _packedAllowanceFor[projectId][allowedPost.nft][allowedPost.category] = packed;\n\n            // Store the allow list.\n            uint256 numberOfAddresses = allowedPost.allowedAddresses.length;\n            // Reset the addresses.\n            delete _allowedAddresses[projectId][allowedPost.nft][allowedPost.category];\n            // Add the number allowed addresses.\n            if (numberOfAddresses != 0) {\n                // Keep a reference to the storage of the allowed addresses.\n                for (uint256 j = 0; j < numberOfAddresses; j++) {\n                    _allowedAddresses[projectId][allowedPost.nft][allowedPost.category].push(\n                        allowedPost.allowedAddresses[j]\n                    );\n                }\n            }\n        }\n\n        emit ConfigurePostingCriteria(projectId, allowedPosts, msg.sender);\n    }\n\n    /// @notice Setup the posts.\n    /// @param projectId The ID of the project having posts set up.\n    /// @param nft The NFT address on which the posts will apply.\n    /// @param posts An array of posts that should be published as NFTs to the specified project.\n    /// @return tiersToAdd The tiers that will be created to represent the posts.\n    /// @return tierIdsToMint The tier IDs of the posts that should be minted once published.\n    /// @return totalPrice The total price being paid.\n    function _setupPosts(\n        uint256 projectId,\n        address nft,\n        CTPost[] memory posts\n    )\n        internal\n        returns (JB721TierConfig[] memory tiersToAdd, uint256[] memory tierIdsToMint, uint256 totalPrice)\n    {\n        // Keep a reference to the number of posts being published.\n        uint256 numberOfMints = posts.length;\n\n        // Set the max size of the tier data that will be added.\n        tiersToAdd = new JB721TierConfig[](numberOfMints);\n\n        // Set the size of the tier IDs of the posts that should be minted once published.\n        tierIdsToMint = new uint256[](numberOfMints);\n\n        // The tier ID that will be created, and the first one that should be minted from, is one more than the current\n        // max.\n        uint256 startingTierId = IJB721TiersHook(nft).STORE().maxTierIdOf(nft) + 1;\n\n        // Keep a reference to the post being iterated on.\n        CTPost memory post;\n\n        // Keep a reference to the total number of tiers being added.\n        uint256 numberOfTiersBeingAdded;\n\n        // For each post, create tiers after validating to make sure they fulfill the allowance specified by the\n        // project's owner.\n        for (uint256 i; i < numberOfMints; i++) {\n            // Get the current post being iterated on.\n            post = posts[i];\n\n            // Make sure the post includes an encodedIPFSUri.\n            if (post.encodedIPFSUri == bytes32(\"\")) {\n                revert EMPTY_ENCODED_IPFS_URI(post.encodedIPFSUri);\n            }\n\n            // Scoped section to prevent stack too deep.\n            {\n                // Check if there's an ID of a tier already minted for this encodedIPFSUri.\n                uint256 tierId = tierIdForEncodedIPFSUriOf[projectId][post.encodedIPFSUri];\n\n                if (tierId != 0) tierIdsToMint[i] = tierId;\n            }\n\n            // If no tier already exists, post the tier.\n            if (tierIdsToMint[i] == 0) {\n                // Scoped error handling section to prevent Stack Too Deep.\n                {\n                    // Get references to the allowance.\n                    (\n                        uint256 minimumPrice,\n                        uint256 minimumTotalSupply,\n                        uint256 maximumTotalSupply,\n                        address[] memory addresses\n                    ) = allowanceFor(projectId, nft, post.category);\n\n                    // Make sure the category being posted to allows publishing.\n                    if (minimumTotalSupply == 0) {\n                        revert UNAUTHORIZED_TO_POST_IN_CATEGORY();\n                    }\n\n                    // Make sure the price being paid for the post is at least the allowed minimum price.\n                    if (post.price < minimumPrice) {\n                        revert PRICE_TOO_SMALL(minimumPrice);\n                    }\n\n                    // Make sure the total supply being made available for the post is at least the allowed minimum\n                    // total supply.\n                    if (post.totalSupply < minimumTotalSupply) {\n                        revert TOTAL_SUPPLY_TOO_SMALL(minimumTotalSupply);\n                    }\n\n                    // Make sure the total supply being made available for the post is at most the allowed maximum total\n                    // supply.\n                    if (post.totalSupply > maximumTotalSupply) {\n                        revert TOTAL_SUPPLY_TOO_BIG(maximumTotalSupply);\n                    }\n\n                    // Make sure the address is allowed to post.\n                    if (addresses.length != 0 && !_isAllowed(msg.sender, addresses)) {\n                        revert NOT_IN_ALLOW_LIST(addresses);\n                    }\n                }\n\n                // Set the tier.\n                tiersToAdd[numberOfTiersBeingAdded] = JB721TierConfig({\n                    price: uint80(post.price),\n                    initialSupply: post.totalSupply,\n                    votingUnits: 0,\n                    reserveFrequency: 0,\n                    reserveBeneficiary: address(0),\n                    encodedIPFSUri: post.encodedIPFSUri,\n                    category: uint8(post.category),\n                    allowOwnerMint: false,\n                    useReserveBeneficiaryAsDefault: false,\n                    transfersPausable: false,\n                    useVotingUnits: true,\n                    cannotBeRemoved: false\n                });\n\n                // Set the ID of the tier to mint.\n                tierIdsToMint[i] = startingTierId + numberOfTiersBeingAdded++;\n\n                // Save the encodedIPFSUri as minted.\n                tierIdForEncodedIPFSUriOf[projectId][post.encodedIPFSUri] = tierIdsToMint[i];\n            }\n\n            // Increment the total price.\n            totalPrice += post.price;\n        }\n\n        // Resize the array if there's a mismatch in length.\n        if (numberOfTiersBeingAdded != numberOfMints) {\n            assembly (\"memory-safe\") {\n                mstore(tiersToAdd, numberOfTiersBeingAdded)\n            }\n        }\n    }\n\n    /// @notice Check if an address is included in an allow list.\n    /// @param addrs The candidate address.\n    /// @param addresses An array of allowed addresses.\n    function _isAllowed(address addrs, address[] memory addresses) internal pure returns (bool) {\n        uint256 numberOfAddresses = addresses.length;\n        for (uint256 i; i < numberOfAddresses; i++) {\n            if (addrs == addresses[i]) return true;\n        }\n        return false;\n    }\n}\n"
			},
			"node_modules/@croptop/core/src/structs/CTAllowedPost.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Criteria for allowed posts.\n/// @custom:member nft The NFT to which this allowance applies.\n/// @custom:member category A category that should allow posts.\n/// @custom:member minimumPrice The minimum price that a post to the specified category should cost.\n/// @custom:member minimumTotalSupply The minimum total supply of NFTs that can be made available when minting.\n/// @custom:member maxTotalSupply The max total supply of NFTs that can be made available when minting. Leave as 0 for\n/// max.\n/// @custom:member allowedAddresses A list of addresses that are allowed to post on the category through Croptop.\nstruct CTAllowedPost {\n    address nft;\n    uint256 category;\n    uint256 minimumPrice;\n    uint256 minimumTotalSupply;\n    uint256 maximumTotalSupply;\n    address[] allowedAddresses;\n}\n"
			},
			"node_modules/@croptop/core/src/structs/CTPost.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A post to be published.\n/// @custom:member encodedIPFSUri The encoded IPFS URI of the post that is being published.\n/// @custom:member totalSupply The number of NFTs that should be made available, including the 1 that will be minted\n/// alongside this transaction.\n/// @custom:member price The price being paid for buying the post that is being published.\n/// @custom:member category The category that the post should be published in.\nstruct CTPost {\n    bytes32 encodedIPFSUri;\n    uint32 totalSupply;\n    uint88 price;\n    uint16 category;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
			},
			"src/REVCroptopDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {CTPublisher} from \"@croptop/core/src/CTPublisher.sol\";\nimport {CTAllowedPost} from \"@croptop/core/src/structs/CTAllowedPost.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBPermissioned} from \"@bananapus/core/src/interfaces/IJBPermissioned.sol\";\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {JBPermissionsData} from \"@bananapus/core/src/structs/JBPermissionsData.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {IJB721TiersHookDeployer} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHookDeployer.sol\";\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {IBPSuckerRegistry} from \"@bananapus/suckers/src/interfaces/IBPSuckerRegistry.sol\";\n\nimport {IREVCroptopDeployer} from \"./interfaces/IREVCroptopDeployer.sol\";\nimport {REVDeploy721TiersHookConfig} from \"./structs/REVDeploy721TiersHookConfig.sol\";\nimport {REVConfig} from \"./structs/REVConfig.sol\";\nimport {REVCroptopAllowedPost} from \"./structs/REVCroptopAllowedPost.sol\";\nimport {REVBuybackHookConfig} from \"./structs/REVBuybackHookConfig.sol\";\nimport {REVSuckerDeploymentConfig} from \"./structs/REVSuckerDeploymentConfig.sol\";\nimport {REVTiered721HookDeployer} from \"./REVTiered721HookDeployer.sol\";\n\n/// @notice A contract that facilitates deploying a basic revnet that also can mint tiered 721s via the croptop\n/// publisher.\ncontract REVCroptopDeployer is REVTiered721HookDeployer, IREVCroptopDeployer {\n    /// @notice The croptop publisher that facilitates the permissioned publishing of 721 posts to a revnet.\n    CTPublisher public override PUBLISHER;\n\n    /// @notice The permissions that the croptop publisher should be granted. This is set once in the constructor to\n    /// contain only the ADJUST_TIERS operation.\n    /// @dev This should only be set in the constructor.\n    uint256[] internal _CROPTOP_PERMISSIONS_INDEXES;\n\n    /// @param controller The controller that revnets are made from.\n    /// @param hookDeployer The 721 tiers hook deployer.\n    /// @param publisher The croptop publisher that facilitates the permissioned publishing of 721 posts to a revnet.\n    /// @param suckerRegistry The registry that deploys and tracks each project's suckers.\n    constructor(\n        IJBController controller,\n        IJB721TiersHookDeployer hookDeployer,\n        CTPublisher publisher,\n        IBPSuckerRegistry suckerRegistry\n    )\n        REVTiered721HookDeployer(controller, hookDeployer, suckerRegistry)\n    {\n        PUBLISHER = publisher;\n        _CROPTOP_PERMISSIONS_INDEXES.push(JBPermissionIds.ADJUST_721_TIERS);\n    }\n\n    /// @notice Deploy a revnet that supports 721 sales.\n    /// @param configuration The data needed to deploy a basic revnet.\n    /// @param terminalConfigurations The terminals that the network uses to accept payments through.\n    /// @param buybackHookConfiguration Data used for setting up the buyback hook to use when determining the best price\n    /// for new participants.\n    /// @param suckerDeploymentConfiguration Information about how this revnet relates to other's across chains.\n    /// @param hookConfiguration Data used for setting up the 721 tiers.\n    /// @param otherPayHooksSpecifications Any hooks that should run when the revnet is paid alongside the 721 hook.\n    /// @param extraHookMetadata Extra metadata to attach to the cycle for the delegates to use.\n    /// @param allowedPosts The type of posts that the network should allow.\n    /// @return revnetId The ID of the newly created revnet.\n    /// @return hook The address of the 721 hook that was deployed on the revnet.\n    function deployCroptopRevnetWith(\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration,\n        REVDeploy721TiersHookConfig memory hookConfiguration,\n        JBPayHookSpecification[] memory otherPayHooksSpecifications,\n        uint16 extraHookMetadata,\n        REVCroptopAllowedPost[] memory allowedPosts\n    )\n        public\n        override\n        returns (uint256 revnetId, IJB721TiersHook hook)\n    {\n        // Deploy the revnet with tiered 721 hooks.\n        (revnetId, hook) = super.deployTiered721RevnetWith({\n            configuration: configuration,\n            terminalConfigurations: terminalConfigurations,\n            buybackHookConfiguration: buybackHookConfiguration,\n            hookConfiguration: hookConfiguration,\n            otherPayHooksSpecifications: otherPayHooksSpecifications,\n            extraHookMetadata: extraHookMetadata,\n            suckerDeploymentConfiguration: suckerDeploymentConfiguration\n        });\n\n        // Keep a reference to the number of allowed posts.\n        uint256 numberOfAllowedPosts = allowedPosts.length;\n\n        // Keep a reference to the formatted allowed posts.\n        CTAllowedPost[] memory formattedAllowedPosts = new CTAllowedPost[](numberOfAllowedPosts);\n\n        // Keep a reference to the post being iterated on.\n        REVCroptopAllowedPost memory post;\n\n        // Specify the hook for each allowed post.\n        for (uint256 i; i < numberOfAllowedPosts; i++) {\n            // Set the post being iterated on.\n            post = allowedPosts[i];\n\n            // Set the formated post.\n            formattedAllowedPosts[i] = CTAllowedPost({\n                nft: address(hook),\n                category: post.category,\n                minimumPrice: post.minimumPrice,\n                minimumTotalSupply: post.minimumTotalSupply,\n                maximumTotalSupply: post.maximumTotalSupply,\n                allowedAddresses: post.allowedAddresses\n            });\n        }\n\n        // Configure allowed posts.\n        if (allowedPosts.length != 0) {\n            PUBLISHER.configurePostingCriteriaFor({projectId: revnetId, allowedPosts: formattedAllowedPosts});\n        }\n\n        // Give the croptop publisher permission to post on this contract's behalf.\n        IJBPermissioned(address(CONTROLLER)).PERMISSIONS().setPermissionsFor({\n            account: address(this),\n            permissionsData: JBPermissionsData({\n                operator: address(PUBLISHER),\n                projectId: revnetId,\n                permissionIds: _CROPTOP_PERMISSIONS_INDEXES\n            })\n        });\n    }\n}\n"
			},
			"src/REVPayHookDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {IJBBuybackHook} from \"@bananapus/buyback-hook/src/interfaces/IJBBuybackHook.sol\";\nimport {IBPSuckerRegistry} from \"@bananapus/suckers/src/interfaces/IBPSuckerRegistry.sol\";\n\nimport {IREVPayHookDeployer} from \"./interfaces/IREVPayHookDeployer.sol\";\nimport {REVConfig} from \"./structs/REVConfig.sol\";\nimport {REVBuybackHookConfig} from \"./structs/REVBuybackHookConfig.sol\";\nimport {REVSuckerDeploymentConfig} from \"./structs/REVSuckerDeploymentConfig.sol\";\nimport {REVBasicDeployer} from \"./REVBasicDeployer.sol\";\n\n/// @notice A contract that facilitates deploying a basic revnet that also calls other hooks when paid.\ncontract REVPayHookDeployer is REVBasicDeployer, IREVPayHookDeployer {\n    /// @param controller The controller that revnets are made from.\n    /// @param suckerRegistry The registry that deploys and tracks each project's suckers.\n    constructor(\n        IJBController controller,\n        IBPSuckerRegistry suckerRegistry\n    )\n        REVBasicDeployer(controller, suckerRegistry)\n    {}\n\n    //*********************************************************************//\n    // ---------------------- public transactions ------------------------ //\n    //*********************************************************************//\n\n    /// @notice Deploy a basic revnet that also calls other specified pay hooks.\n    /// @param configuration The data needed to deploy a basic revnet.\n    /// @param terminalConfigurations The terminals that the network uses to accept payments through.\n    /// @param buybackHookConfiguration Data used for setting up the buyback hook to use when determining the best price\n    /// for new participants.\n    /// @param suckerDeploymentConfiguration Information about how this revnet relates to other's across chains.\n    /// @param payHookSpecifications Any hooks that should run when the revnet is paid.\n    /// @param extraHookMetadata Extra metadata to attach to the cycle for the delegates to use.\n    /// @return revnetId The ID of the newly created revnet.\n    function deployPayHookRevnetWith(\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration,\n        JBPayHookSpecification[] memory payHookSpecifications,\n        uint16 extraHookMetadata\n    )\n        public\n        override\n        returns (uint256 revnetId)\n    {\n        // Deploy the revnet\n        revnetId = _deployRevnetWith({\n            configuration: configuration,\n            terminalConfigurations: terminalConfigurations,\n            buybackHookConfiguration: buybackHookConfiguration,\n            dataHook: IJBBuybackHook(address(this)),\n            extraHookMetadata: extraHookMetadata,\n            suckerDeploymentConfiguration: suckerDeploymentConfiguration\n        });\n\n        // Store the pay hooks.\n        // Keep a reference to the number of pay hooks are being stored.\n        uint256 numberOfPayHookSpecifications = payHookSpecifications.length;\n\n        // Store the pay hooks.\n        for (uint256 i; i < numberOfPayHookSpecifications; i++) {\n            // Store the value.\n            _payHookSpecificationsOf[revnetId].push(payHookSpecifications[i]);\n        }\n\n        emit StoredPayHookSpecifications(revnetId, payHookSpecifications, msg.sender);\n    }\n}\n"
			},
			"src/REVTiered721HookDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {JBOwnable} from \"@bananapus/ownable/src/JBOwnable.sol\";\nimport {IJBPayHook} from \"@bananapus/core/src/interfaces/IJBPayHook.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {IJB721TiersHookDeployer} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHookDeployer.sol\";\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {IBPSuckerRegistry} from \"@bananapus/suckers/src/interfaces/IBPSuckerRegistry.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\n\nimport {IREVTiered721HookDeployer} from \"./interfaces/IREVTiered721HookDeployer.sol\";\nimport {REVDeploy721TiersHookConfig} from \"./structs/REVDeploy721TiersHookConfig.sol\";\nimport {REVConfig} from \"./structs/REVConfig.sol\";\nimport {REVBuybackHookConfig} from \"./structs/REVBuybackHookConfig.sol\";\nimport {REVSuckerDeploymentConfig} from \"./structs/REVSuckerDeploymentConfig.sol\";\nimport {REVPayHookDeployer} from \"./REVPayHookDeployer.sol\";\n\n/// @notice A contract that facilitates deploying a basic revnet that also can mint tiered 721s.\ncontract REVTiered721HookDeployer is REVPayHookDeployer, IREVTiered721HookDeployer {\n    /// @notice The contract responsible for deploying the tiered 721 hook.\n    IJB721TiersHookDeployer public immutable override HOOK_DEPLOYER;\n\n    /// @param controller The controller that revnets are made from.\n    /// @param hookDeployer The 721 tiers hook deployer.\n    /// @param suckerRegistry The registry that deploys and tracks each project's suckers.\n    constructor(\n        IJBController controller,\n        IJB721TiersHookDeployer hookDeployer,\n        IBPSuckerRegistry suckerRegistry\n    )\n        REVPayHookDeployer(controller, suckerRegistry)\n    {\n        HOOK_DEPLOYER = hookDeployer;\n    }\n\n    /// @notice Deploy a revnet that supports 721 sales.\n    /// @param configuration The data needed to deploy a basic revnet.\n    /// @param terminalConfigurations The terminals that the network uses to accept payments through.\n    /// @param buybackHookConfiguration Data used for setting up the buyback hook to use when determining the best price\n    /// for new participants.\n    /// @param suckerDeploymentConfiguration Information about how this revnet relates to other's across chains.\n    /// @param hookConfiguration Data used for setting up the 721 tiers.\n    /// @param otherPayHooksSpecifications Any hooks that should run when the revnet is paid alongside the 721 hook.\n    /// @param extraHookMetadata Extra metadata to attach to the cycle for the delegates to use.\n    /// @return revnetId The ID of the newly created revnet.\n    /// @return hook The address of the 721 hook that was deployed on the revnet.\n    function deployTiered721RevnetWith(\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration,\n        REVDeploy721TiersHookConfig memory hookConfiguration,\n        JBPayHookSpecification[] memory otherPayHooksSpecifications,\n        uint16 extraHookMetadata\n    )\n        public\n        override\n        returns (uint256 revnetId, IJB721TiersHook hook)\n    {\n        // Get the revnet ID, optimistically knowing it will be one greater than the current count.\n        revnetId = CONTROLLER.PROJECTS().count() + 1;\n\n        // Keep a reference to the number of pay hooks passed in.\n        uint256 numberOfOtherPayHooks = otherPayHooksSpecifications.length;\n\n        // Track an updated list of pay hooks that'll also fit the tiered 721 hook.\n        JBPayHookSpecification[] memory payHookSpecifications = new JBPayHookSpecification[](numberOfOtherPayHooks + 1);\n\n        // Repopulate the updated list with the params passed in.\n        for (uint256 i; i < numberOfOtherPayHooks; i++) {\n            payHookSpecifications[i] = otherPayHooksSpecifications[i];\n        }\n\n        // Deploy the tiered 721 hook contract.\n        hook = HOOK_DEPLOYER.deployHookFor(revnetId, hookConfiguration.baseline721HookConfiguration);\n\n        // If needed, give the operator permission to add and remove tiers.\n        if (hookConfiguration.operatorCanAdjustTiers) {\n            _SPLIT_OPERATOR_PERMISSIONS_INDEXES.push(JBPermissionIds.ADJUST_721_TIERS);\n        }\n\n        // If needed, give the operator permission to set the 721's metadata.\n        if (hookConfiguration.operatorCanUpdateMetadata) {\n            _SPLIT_OPERATOR_PERMISSIONS_INDEXES.push(JBPermissionIds.UPDATE_721_METADATA);\n        }\n\n        // If needed, give the operator permission to mint 721's from tiers that allow it.\n        if (hookConfiguration.operatorCanMint) {\n            _SPLIT_OPERATOR_PERMISSIONS_INDEXES.push(JBPermissionIds.MINT_721);\n        }\n\n        // Add the tiered 721 hook at the end.\n        payHookSpecifications[numberOfOtherPayHooks] =\n            JBPayHookSpecification({hook: IJBPayHook(address(hook)), amount: 0, metadata: bytes(\"\")});\n\n        super.deployPayHookRevnetWith({\n            configuration: configuration,\n            terminalConfigurations: terminalConfigurations,\n            buybackHookConfiguration: buybackHookConfiguration,\n            payHookSpecifications: payHookSpecifications,\n            extraHookMetadata: extraHookMetadata,\n            suckerDeploymentConfiguration: suckerDeploymentConfiguration\n        });\n    }\n}\n"
			},
			"src/interfaces/IREVCroptopDeployer.sol": {
				"content": "pragma solidity ^0.8.0;\n\nimport {CTPublisher} from \"@croptop/core/src/CTPublisher.sol\";\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {REVBuybackHookConfig} from \"../structs/REVBuybackHookConfig.sol\";\nimport {REVSuckerDeploymentConfig} from \"../structs/REVSuckerDeploymentConfig.sol\";\nimport {REVConfig} from \"../structs/REVConfig.sol\";\nimport {REVDeploy721TiersHookConfig} from \"../structs/REVDeploy721TiersHookConfig.sol\";\nimport {REVCroptopAllowedPost} from \"../structs/REVCroptopAllowedPost.sol\";\nimport {IREVTiered721HookDeployer} from \"./IREVTiered721HookDeployer.sol\";\n\ninterface IREVCroptopDeployer is IREVTiered721HookDeployer {\n    function PUBLISHER() external view returns (CTPublisher);\n\n    function deployCroptopRevnetWith(\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration,\n        REVDeploy721TiersHookConfig memory hookConfiguration,\n        JBPayHookSpecification[] memory otherPayHooksSpecifications,\n        uint16 extraHookMetadata,\n        REVCroptopAllowedPost[] memory allowedPosts\n    )\n        external\n        returns (uint256 revnetId, IJB721TiersHook hook);\n}\n"
			},
			"src/interfaces/IREVPayHookDeployer.sol": {
				"content": "pragma solidity ^0.8.0;\n\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {REVBuybackHookConfig} from \"../structs/REVBuybackHookConfig.sol\";\nimport {REVSuckerDeploymentConfig} from \"../structs/REVSuckerDeploymentConfig.sol\";\nimport {REVConfig} from \"../structs/REVConfig.sol\";\nimport {IREVBasicDeployer} from \"./IREVBasicDeployer.sol\";\n\ninterface IREVPayHookDeployer is IREVBasicDeployer {\n    event StoredPayHookSpecifications(\n        uint256 indexed revnetId, JBPayHookSpecification[] payHookSpecifications, address caller\n    );\n\n    function deployPayHookRevnetWith(\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration,\n        JBPayHookSpecification[] memory payHookSpecifications,\n        uint16 extraHookMetadata\n    )\n        external\n        returns (uint256 revnetId);\n}\n"
			},
			"src/interfaces/IREVTiered721HookDeployer.sol": {
				"content": "pragma solidity ^0.8.0;\n\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {IJB721TiersHook} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHook.sol\";\nimport {IJB721TiersHookDeployer} from \"@bananapus/721-hook/src/interfaces/IJB721TiersHookDeployer.sol\";\n\nimport {REVDeploy721TiersHookConfig} from \"../structs/REVDeploy721TiersHookConfig.sol\";\nimport {REVBuybackHookConfig} from \"../structs/REVBuybackHookConfig.sol\";\nimport {REVSuckerDeploymentConfig} from \"../structs/REVSuckerDeploymentConfig.sol\";\nimport {REVConfig} from \"../structs/REVConfig.sol\";\nimport {IREVPayHookDeployer} from \"./IREVPayHookDeployer.sol\";\n\ninterface IREVTiered721HookDeployer is IREVPayHookDeployer {\n    function HOOK_DEPLOYER() external view returns (IJB721TiersHookDeployer);\n\n    function deployTiered721RevnetWith(\n        REVConfig memory configuration,\n        JBTerminalConfig[] memory terminalConfigurations,\n        REVBuybackHookConfig memory buybackHookConfiguration,\n        REVSuckerDeploymentConfig memory suckerDeploymentConfiguration,\n        REVDeploy721TiersHookConfig memory hookConfiguration,\n        JBPayHookSpecification[] memory otherPayHooksSpecifications,\n        uint16 extraHookMetadata\n    )\n        external\n        returns (uint256 revnetId, IJB721TiersHook hook);\n}\n"
			},
			"src/structs/REVCroptopAllowedPost.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Criteria for allowed posts.\n/// @custom:member category A category that should allow posts.\n/// @custom:member minimumPrice The minimum price that a post to the specified category should cost.\n/// @custom:member minimumTotalSupply The minimum total supply of NFTs that can be made available when minting.\n/// @custom:member maxTotalSupply The max total supply of NFTs that can be made available when minting. Leave as 0 for\n/// max.\n/// @custom:member allowedAddresses A list of addresses that are allowed to post on the category through Croptop.\nstruct REVCroptopAllowedPost {\n    uint256 category;\n    uint256 minimumPrice;\n    uint256 minimumTotalSupply;\n    uint256 maximumTotalSupply;\n    address[] allowedAddresses;\n}\n"
			},
			"src/structs/REVDeploy721TiersHookConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBDeploy721TiersHookConfig} from \"@bananapus/721-hook/src/structs/JBDeploy721TiersHookConfig.sol\";\n\n/// @custom:member baseline721HookConfiguration The baseline config.\n/// @custom:member operatorCanAdjustTiers A flag indicating if the revnet's operator can add tiers and remove tiers if\n/// the tier is allowed to be removed\n/// @custom:member operatorCanUpdateMetadata A flag indicating if the revnet's operator can update the 721's metadata.\n/// @custom:member operatorCanMint A flag indicating if the revnet's operator can mint 721's from tiers that allow it.\nstruct REVDeploy721TiersHookConfig {\n    JBDeploy721TiersHookConfig baseline721HookConfiguration;\n    bool operatorCanAdjustTiers;\n    bool operatorCanUpdateMetadata;\n    bool operatorCanMint;\n}\n"
			}
		}
	}
}